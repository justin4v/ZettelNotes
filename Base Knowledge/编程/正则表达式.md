#Regex
[文章参考](juejin.cn/post/6844903677119954958)

# 正则基础

**正则表达式（regular expression）** 
- 用一个字符串**描述一个特征**；
- 然后**验证另一个字符串是否符合特征**。

如：
表达式“*ab+*” 描述的特征是：
- 一个 'a' 和 任意个 'b' ；
- 那么 'ab', 'abb', 'abbbbbbbbbb' 都符合这个特征。

1. regex 表达式*整体作为规则去匹配另外一个字符串的内容*；
2. 并给出相应的*结果与副作用（side-effect)*.

## 单个普通字符

- **只能匹配单个字符**
- *字母、数字、汉字、下划线、标点符号*。
- regex 中*普通字符，匹配与之相同的一个字符*。



## 元字符
构造 regex 表达式的**基本元素**。

常用的元字符如下：

| 元字符   |    说明                                                              |
| ------ | ----------------------------------------------------------------- |
| .      | 匹配*除换行符以外的任意单个字符*            |
| \w     | 匹配*字母/数字/下划线*                   |
| \s     | 匹配*任意的空白符*                      |
| \d     | 匹配*数字*                |
| \b     | 匹配一个**单词边界**，单词和空格之间的位置，不匹配任何字符  |
| ^      | 匹配**整个字符串的开始位置**，不匹配任何字符。多行模式下匹配每一行开头 |
| $      | 匹配**整个字符串的结束位置**，不匹配任何字符     |

### 注意
注意其中匹配的模式：
- 匹配单个字符
- 匹配边界。`^pattern` / `pattern&` 要求字符串匹配（包含）整个 pattern， `^pattern$` 意味着*相等*。

## example
1. 匹配 abc 开头的字符串：
	```
	\babc 或者 ^abc
	```

2. 匹配8位数字：
	```
	^\d\d\d\d\d\d\d\d$
	```

2. 匹配1开头11位数字：
	```
	^1\d\d\d\d\d\d\d\d\d\d$
	```

## 重复限定符

**可匹配单个字符或表达式多次**
部分常用重复限定符如下：

| 语法  | 说明                                 |
| ----- | ------------------------------------ |
| *     | 重复零次或多次；贪婪模式，尽可能多 |
| +     | 重复一次或多次；贪婪模式 |
| ?     | 重复零次或一次；贪婪模式   |
| {n}   | 重复至少n次；贪婪模式    |
| {n,}  | 重复至少n次或更多次；贪婪模式  |
| {n,m} | 重复至少n次，至多m次；贪婪模式    |

简化前面的 regex：
1. 匹配1开头的11数字：`^1\d{10}`
2. 匹配以a开头，0个或多个b结尾：`^ab*$`

## 分组
1. 从`^ab*$`中看到，`*` 限定符*只会作用在左边最近的一个字符*；
2. 使用分组`小括号()` **同时限定多个字符**：
	1. 分组会保存结果到内存；
	2. 通常和捕获概念一起使用，称为捕获组；

匹配字符串中包含0到多个ab开头： `^(ab)*$`

## 转义

把元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是 \ 即可。

 如：要匹配**以 (ab) 开头**： ```^(\(ab\))*```

## 逻辑或

> 符号 `|`表示**逻辑或**

如
```
^(130|131|132|155|156|185|186|145|176)\d{8}$
```
## 区间
*括号 [] * 表示**区间**

如：
```
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

# 正则进阶

## 1. 零宽断言

> **断言**：断定*指定内容的前后，会出现满足指定规则的内容*
>
> **零宽**：*没有宽度*。
> - 正则中，*断言只匹配位置*；
> - 匹配结果*不会返回断言字符本身*。

### 正向先行断言

**正/负向、先/后行** 解释：
> **正向**：找到 **匹配 pattern** 的内容，*Is 逻辑，等号 "="*
>
> **负向**：找到 **不匹配 pattern** 的内容，*Not 逻辑，感叹号  "!"*
>
> **先行**：在 *pattern* 的内容**前面**查找 *expression* 的匹配，*expression 在 pattern 前面*。
>
> **后行**：在 *pattern* 的内容**后面**查找 *expression* 的匹配，*expression 在 pattern 后面*，pattern **加 “<”**。

语法：
> **正向先行断言 (正前瞻)**：   
>   - *语法*：*expression(?=pattern)*
>   - *作用*：返回 *pattern 前面匹配 expression 的内容*，不返回 pattern 本身。
>   - *含义*：断定 pattern 前面存在 expression 匹配的内容，并返回该内容
>   - pattern 和 expression 都是正则表达式 


如匹配
```
1"<span class="read-count">阅读数：641</span>"
```
中  `\</span>`  前面数字。
用*正向先行断言* `(?=</span>)` 匹配。
 代码：
```java
 String reg=".+(?=</span>)";
 String test = "<span class=\\"read-count\\">阅读数：641</span>";
 Pattern pattern = Pattern.compile(reg);
 Matcher mc =  pattern.matcher(test);
 while(mc.find()){
   System.out.println("匹配结果：")
   System.out.println(mc.group());
 }

//匹配结果：
//<span class="read-count">阅读数：641
```

### 正向后行断言

语法：
 **正向后行断言 (正后顾)**:  
 - *语法*：*(?<=pattern)expression*
-  *作用*：返回 pattern 后面匹配 expression 的内容，不返回本身
-  *含义*：断定 pattern 后面存在 expression 匹配的内容，并返回该内容


### 负向先行断言

 **负向先行断言（负前瞻）**  
- 语法：*expression(?!pattern)*
 - 作用：返回 pattern 前面不匹配 expression 的内容，不返回本身。
 - 含义：断定 pattern 前面存在不匹配 expression 的内容，并返回该内容 

如 “我爱祖国，我是祖国的花朵” 。
现在找到不是 '的花朵' 前面的祖国
用正则就可以这样写：
```
祖国(?!的花朵)
```

### 负向后行断言
语法：
**负向后行断言（负后顾）**  
- 语法：*(?<!pattern)expression*
- 作用：返回*pattern 后面不匹配 expression 的内容*，不返回本身
- 含义：断定 pattern 后面存在不匹配 expression 的内容，并返回该内容



### 总结
 零宽断言：
 1. 先用 pattern 限定搜索的范围（pattern 定位 + 搜索方向）
 2. 然后在限定范围中搜索 expression 匹配内容


## 2. 捕获和非捕获

1. **捕获：匹配表达式**
2. 捕获组：
	1. 匹配子表达式的内容；
	2. 结果保存到内存中*以数字或显式命名的组*里；
	3. 可以通过序号或名称获取匹配结果。

### 数字编号捕获组

 **语法：(exp)**
 解释：
 1. 从表达式左侧开始，每一个匹配括号中表达式的内容为一个捕获组。
 2. 第 0 组为整个表达式，不计入分组个数，第一组开始为分组。

如
- 内容：020-85653333
- 正则表达式为：(0\d{2})-(\d{8})
有如下分组：

| 序号 | 编号 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (0\d{2})     |     020      |
|  2   |  2   |     (\d{8})      |   85653333   |


Java 代码：
```java
String test = "020-85653333";
String reg="(0\\d{2})-(\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：
```
分组的个数有：2
第0个分组为：020-85653333
第1个分组为：020
第2个分组为：85653333
```

### 命名编号捕获组

 1. 语法：**(\?\<name\>exp)**；
 2. 解释： 分组的*命名由表达式中的 name 指定*。
 	比如区号也可以这样写: **(?\<quhao>\0\d{2})-(?\<haoma>\d{8})** 
表达式有如下分组：

| 序号 | 名称  |       分组       |     结果     |
| :--: | :---: | :--------------: | :----------: |
|  0   |   0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   | quhao |     (0\d{2})     |     020      |
|  2   | haoma |     (\d{8})      |   85653333   |

代码验证：
```java
String test = "020-85653333";
String reg="(?<quhao>0\\\\d{2})-(?<haoma>\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    System.out.println(mc.group("quhao"));
    System.out.println(mc.group("haoma"));
}
```

输出结果：
```
分组的个数有：2
分组名称为:quhao,匹配内容为：020
分组名称为:haoma,匹配内容为：85653333
```

### 非捕获组
1. 语法：**(?:exp)**
2. 解释：和捕获组刚好相反，标识不需要捕获的分组。

如上面的正则表达式，程序不需要用到第一个分组：

```
(?:\\0\\d{2})-(\\d{8})
```

| 序号 | 名称 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (\d{8})      |   85653333   |

验证：
```java
String test = "020-85653333";
String reg="(?:0\\\\d{2})-(\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：
```
分组的个数有：1
第0个分组为：020-85653333
第1个分组为：85653333
```

## 3. 反向引用

1. 捕获会返回一个捕获组**保存在内存中**。
2. 可**在正则表达式外部通过程序进行引用**，
3. 也可**在正则表达式内部进行引用，这种引用方式就是反向引用**。

根据捕获组的命名规则，反向引用可分为：

> **数字编号组反向引用**：\k或\number 
>
> **命名编号组反向引用**：\k或者\\'name'

**捕获组通常是和反向引用一起使用**。捕获组是匹配表达式的内容按序号或者命名保存在内存中的。

注意两个字眼：“内容” 和 “使用”。这里所说的**“内容”，是匹配结果**，而不是表达式本身。 这里所说的“使用”，主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧： 比如要**查找一串字母 "aabbbbgbddesddfiid" 里成对的字母** 

如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的， 现在我们先用**程序思维理一下思路**：

> 1）匹配到一个字母
>
> 2）匹配第下一个字母，检查是否和上一个字母是否一样 
>
> 3）如果一样，则匹配成功，否则失败

匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？ 

**可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件**。

 首先匹配一个字母：\w 我们**需要做成分组才能捕获，因此写成这样：(\w)**

然后以这个捕获组作为条件，可得：**(\w)\1** 

**\1 是数字编号组反向引用。表示引用前面第一个捕获组的内容**。 还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名。在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的** 。

因此要引用第一个捕获组，根据反向引用的捕获组命名规则，就需要 **\k<1>或者\1** 当然，通常都是是后者。 测试：

```java
String test = "aabbbbgbddesddfiid";
Pattern pattern = Pattern.compile("(\\w)\\1");
Matcher mc= pattern.matcher(test);
while(mc.find()){
    System.out.println(mc.group());
}
```

输出结果：

```
aa
bb
bb
dd
dd
ii
```

嗯，这就是我们想要的了。 在举个替换的例子，假如想要把字符串中abc换成a

```
String test = "abcbbabcbcgbddesddfiid";
String reg="(a)(b)c";
System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```
abbabcgbddesddfiid
```



### 4. 贪婪和非贪婪

#### 1.贪婪

我们都知道，贪婪就是不满足，尽可能多的要。 在正则中，贪婪也是差不多的意思:

> **贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。**
>
> 特性：**一次性读入整个字符串从左到右进行匹配，每当不匹配就在接口中舍弃最右边的字符。继续向后匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯）**，直到匹配成功或者把整个字符串舍弃完为止，因此**它是一种最大化的数据返回，能多不会少**。

**重复限定符就是贪婪量词**，比如表达式：

**\d{3,6}**

用来匹配3到6位数字，在这种情况下，**它是一种贪婪模式的匹配**，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。 如

```java
String reg="\\d{3,6}";        
String test="61762828 176 2991 871";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 44 871
贪婪模式：\\d{3,6}
匹配结果：617628
匹配结果：176
匹配结果：2991
匹配结果：871
```

由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。

 一个量词就如此贪婪了， 那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

> **多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰**。
>
> **如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先级从高到低，先最大数量匹配左边的剩余再分配下一个量词匹配。**
>
> 但是注意，**上述行为有一个前提：整个表达式能得到匹配**

```java
String reg="(\\d{1,2})(\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2})(\\d{3,4})
匹配结果：617628
匹配结果：2991
匹配结果：87321
```

> “617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628 
>
> "2991" 是前面的\d{1,2}匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)
>
> "87321"是前面的\d{1,2}匹配出了87，后面的匹配出了321



#### 2. 懒惰（非贪婪）

> 懒惰匹配：**当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。**
>
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

**懒惰量词是在贪婪量词后面加个“？”**

| 语法   | 说明                        |
| ------ | --------------------------- |
| *?     | 重复零次或更多次,但尽可能少 |
| +?     | 重复一次或更多次,但尽可能少 |
| ??     | 重复零次或一次,但尽可能少   |
| {n}?   | 重复n次,但尽可能少          |
| {n,}?  | 重复n次或更多次,但尽可能少  |
| {n,m}? | 重复n到m次,但尽可能少       |



```java
String reg="(\\d{1,2}?)(\\\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2}?)(\\d{3,4})
匹配结果：61762
匹配结果：2991
匹配结果：87321
```

解答：

> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762
>
> "2991" 是左边的懒惰匹配出2，右边的贪婪匹配出991
>
> "87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321



## 5. 反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些**常用的反义元字符**：

| 元字符 | 说明                                         |
| ------ | -------------------------------------------- |
| \W     | 匹配 任意不是字母或数字或下划线或汉字 的字符 |
| \S     | 匹配 任意不是空白符 的字符                   |
| \D     | 匹配 任意不是数字 的字符                     |
| \B     | 匹配 不是**单词**的开始或结束 的位置         |
| [^x]   | 匹配 除了 x 以外的任意字符                   |

