#Regex
[文章参考](juejin.cn/post/6844903677119954958)

# 正则基础

**正则表达式（regular expression）** 
- 用一个字符串**描述一个特征**；
- 然后**验证另一个字符串是否符合特征**。

如：
表达式“*ab+*” 描述的特征是：
- 一个 'a' 和 任意个 'b' ；
- 那么 'ab', 'abb', 'abbbbbbbbbb' 都符合这个特征。

1. regex 表达式*整体作为规则去匹配另外一个字符串的内容*；
2. 并给出相应的*结果与副作用（side-effect)*.

## 单个普通字符

- **只能匹配单个字符**
- *字母、数字、汉字、下划线、标点符号*。
- regex 中*普通字符，匹配与之相同的一个字符*。



## 元字符
构造 regex 表达式的**基本元素**。

常用的元字符如下：

| 元字符   |    说明                                                              |
| ------ | ----------------------------------------------------------------- |
| .      | 匹配*除换行符以外的任意单个字符*            |
| \w     | 匹配*字母/数字/下划线*                   |
| \s     | 匹配*任意的空白符*                      |
| \d     | 匹配*数字*                |
| \b     | 匹配一个**单词边界**，也就是单词和空格之间的位置，不匹配任何字符  |
| ^      | 匹配**整个字符串的开始位置**，不匹配任何字符。多行模式下匹配每一行开头 |
| $      | 匹配**整个字符串的结束位置**，不匹配任何字符     |

### 注意
注意其中匹配的模式：
- 匹配单个字符
- 匹配字符串。其为 “无边界” 匹配，如果表达是中都使用特定字符，则整个表达式只能精确匹配单个条件。可以使用其他 “宽范围” 的元字符来代替特定单个字符。

**^pattern 或者 pattern& 都是需要匹配整个pattern，才是匹配成功的**。所以 ^pattern$ 意味着待匹配字符串就是 pattern 模式，不能有多余字符，才是匹配成功。**因此 \^pattern\$ 是精确匹配。** 



## example

匹配有 abc 开头的字符串：

```
\babc 或者 ^abc
```

匹配8位数字的QQ号码：

```
^\d\d\d\d\d\d\d\d$
```

匹配1开头11位数字的手机号码：

```
^1\d\d\d\d\d\d\d\d\d\d$
```



## 重复限定符

**可以匹配单个字符或表达式多次**

正则表达式中有一些重复限定符，把**重复部分用合适的限定符替代**。部分常用重复限定符如下：

| 语法  | 说明                                 |
| ----- | ------------------------------------ |
| *     | 重复零次或更多次，贪婪模式，尽可能多 |
| +     | 重复一次或更多次，贪婪模式，尽可能多 |
| ?     | 重复零次或一次，贪婪模式，尽可能多   |
| {n}   | 重复n次，贪婪模式，尽可能多          |
| {n,}  | 重复n次或更多次，贪婪模式，尽可能多  |
| {n,m} | 重复n到m次，贪婪模式，尽可能多       |

有了重复限定符，就可以简化前面的 regex：

1. 匹配1开头的11数字：```^1\d{10}```
2. 匹配以a开头，0个或多个b结尾的字符串：```^ab*$```



## 分组

从上面的例子（2）中看到，\* 限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 **ab 同时被 * 限定**那怎么办呢？

> 正则表达式中用**小括号()来做分组，会保存结果到内存(通常和捕获概念一起使用，称为捕获组)**，也就是**括号中的内容作为一个整体**。

因此当我们要匹配多个ab时，可以这样：

匹配字符串中包含0到多个ab开头： ```^(ab)*$```



## 转义

正则表达式用 小括号 来做分组，那么：

> 如果要匹配的字符串中本身就包含小括号，那应该怎么办？

针对这种情况，**正则提供了转义**的方式，也就是要把这些 元字符、限定符 或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是 \ 即可。

 如：要匹配**以 (ab) 开头**： ```^(\(ab\))*```



## 条件或

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在**正则中是如何表示“或”的呢**？

> **正则用符号 | 来表示或**，也叫做**分支条件**，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

```
^(130|131|132|155|156|185|186|145|176)\d{8}$
```



## 区间

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？ 实际是有的

> 正则提供一个元字符中括号 [] 来表示区间条件。  限定0到9 可以写成[0-9] 限定A-Z 写成[A-Z] 限定某些数字 [165]

那上面的正则我们还改成这样：

```
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

# 正则进阶

## 1. 零宽断言

解释：

> **断言**：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说**正则中可以指明在指定内容的前后，会出现满足指定规则的内容**，意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1. 
>
> **零宽**：**就是没有宽度**。**在正则中，断言只是匹配位置，不占字符**，也就是说，**匹配结果里是不会返回断言字符本身的**。

意思是讲明白了，那他有什么用呢？ 我们来举个栗子：

假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构

```
1"<span class="read-count">阅读数：641</span>"
```

其中只有‘641’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？

下面先讲一下**几种类型的断言**：

### 正向先行断言

**正/负向、先/后行** 解释：
> **正向**：找到 **匹配 pattern** 的内容，*Is 逻辑，等号 "="*
>
> **负向**：找到 **不匹配 pattern** 的内容，*Not 逻辑，感叹号  "!"*
>
> **先行**：在 *pattern* 的内容**前面**查找 *expression* 的匹配，*expression 在 pattern 前面*。
>
> **后行**：在 *pattern* 的内容**后面**查找 *expression* 的匹配，*expression 在 pattern 后面*，pattern **加 “<”**。

语法说明：
> **正向先行断言 (正前瞻)**：   
>
> 语法：**expression(?=pattern)** 
>
> 作用：**返回 pattern 前面内容中 expression 匹配的内容，不返回本身**。
>
> 含义：**断定 pattern 前面存在 expression 匹配的内容，并返回该内容（不包含 pattern 匹配的内容）**

**expression 和 pattern 含义是一致的，都可以是正则表达式**

回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到  ‘</span>’  前面的数字内容

按照上所说的 正向先行断言 可以匹配表达式前面的内容，那意思就是:  **(?=</span>) 就可以匹配到前面的内容了**。

 匹配什么内容呢？见下例：

```java
 String reg=".+(?=</span>)";
 String test = "<span class=\\"read-count\\">阅读数：641</span>";
 Pattern pattern = Pattern.compile(reg);
 Matcher mc =  pattern.matcher(test);
 while(mc.find()){
   System.out.println("匹配结果：")
   System.out.println(mc.group());
 }

//匹配结果：
//<span class="read-count">阅读数：641
```

可是我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：

```java
String reg="\\\\d+(?=</span>)";
String test = "<span class=\\"read-count\\">阅读数：641</span>";
Pattern pattern = Pattern.compile(reg);
Matcher mc=    pattern.matcher(test);
while(mc.find()){
  System.out.println(mc.group());
}
//匹配结果：
//641
```



### 正向后行断言

语法说明：

> **正向后行断言 (正后顾)**:  
>
> **语法：(?<=pattern)expression**
>
> 作用：**返回 pattern 后面内容中 expression 匹配的内容，不返回本身**
>
> 含义：**断定 pattern 后面存在 expression 匹配的内容，并返回该内容（不包含pattern 匹配的内容）**

有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。 上面的栗子，我们也可以用**后行断言**来处理.

```java
 //(?<=<span class="read-count">阅读数：)\\d+
 String reg="(?<=<span class=\\"read-count\\">阅读数：)\\d+";
 
 String test = "<span class=\\"read-count\\">阅读数：641</span>";
 Pattern pattern = Pattern.compile(reg);
 Matcher mc=    pattern.matcher(test);
         while(mc.find()){
             System.out.println(mc.group());
         }
//匹配结果：
//641
```



### 负向先行断言

> **负向先行断言（负前瞻）**  
>
> 语法：**expression(?!pattern)** 
>
> 作用：**返回 pattern 所匹配内容的前面内容中不匹配 expression 的内容，不返回本身**。
>
> 含义：**断定匹配 pattern 的内容前面存在不匹配 expression 的内容，并返回该内容（不包含pattern 匹配的内容）**

有正向也有负向，负向在这里其实就是非的意思。 

举个栗子：比如有一句 “我爱祖国，我是祖国的花朵” 。现在要**找到不是 '的花朵' 前面的祖国** 用正则就可以这样写：

```
祖国(?!的花朵)
```



### 负向后行断言

语法说明：

> 负向后行断言（负后顾）  
>
> 语法：**(?<!pattern)expression** 
>
> 作用：**返回 pattern 所匹配内容的后面内容中不匹配 expression 的内容，不返回本身**
>
> 含义：**断定匹配 pattern 的内容后面存在不匹配 expression 的内容，并返回该内容（不包含pattern 匹配的内容）**



### 总结

从上可以看出，其实 ==零宽断言 就是 先用 pattern 限定搜索的范围（pattern 定位 + 搜索方向），然后在限定范围中搜索 expression 匹配内容==。

**后行断言要加上 “<” 符号(看开口方向，==向后开口==，所以是后行断言)；负向需加上！**



## 2. 捕获和非捕获

**单纯说到捕获，意思是匹配表达式**。但捕获通常和分组联系在一起，也就是“**捕获组**”

> 捕获组：
>
> 匹配子表达式的内容，把**匹配结果保存到内存中以数字编号或显示命名的组里**，以深度优先进行编号，之后**可以通过序号或名称获取匹配结果**。

而根据命名方式的不同，又可以分为两种组：



### 数字编号捕获组

> 数字编号捕获组：
>
> **语法：(exp)**
>
> 解释：**从表达式左侧开始**，**每一个匹配一对括号中表达式的内容为一个捕获组，但是匹配是整个表达式整体一起匹配。在获得的捕获组中，第 0 组为整个表达式，不计入分组个数，第一组开始为分组。**
>
> 比如固定电话的：020-85653333 的正则表达式为：(0\d{2})-(\d{8})
>
> 按照左括号的顺序，这个表达式有如下分组：

| 序号 | 编号 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (0\d{2})     |     020      |
|  2   |  2   |     (\d{8})      |   85653333   |

**注意：** 其中 **第 0 分组为整个分组表达式，不计入分组个数，结果也是原始结果**



用Java来验证一下：

```java
String test = "020-85653333";
String reg="(0\\d{2})-(\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：

```
分组的个数有：2
第0个分组为：020-85653333
第1个分组为：020
第2个分组为：85653333
```

可见，分组个数是2，第0个为整个表达式本身。



### 命名编号捕获组

> 命名编号捕获组：
> 语法：**(\?\<name\>exp)**；
> 解释： **分组的命名由表达式中的 name 指定(用于获取捕获组)**。
> 比如区号也可以这样写: **(?\<quhao>\0\d{2})-(?\<haoma>\d{8})** 按 照从左到右括号的顺序，这个表达式有如下分组：
	
| 序号 | 名称  |       分组       |     结果     |
| :--: | :---: | :--------------: | :----------: |
|  0   |   0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   | quhao |     (0\d{2})     |     020      |
|  2   | haoma |     (\d{8})      |   85653333   |

用代码来验证一下：

```java
String test = "020-85653333";
String reg="(?<quhao>0\\\\d{2})-(?<haoma>\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    System.out.println(mc.group("quhao"));
    System.out.println(mc.group("haoma"));
}
```

输出结果：

```
分组的个数有：2
分组名称为:quhao,匹配内容为：020
分组名称为:haoma,匹配内容为：85653333
```



### 非捕获组
> 语法：**(?:exp)**
> 解释：**和捕获组刚好相反，它用来标识那些不需要捕获(直接忽略，后面无法获取)的分组**。**可以根据需要去保存你的分组。**

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

```
(?:\\0\\d{2})-(\\d{8})
```

| 序号 | 名称 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (\d{8})      |   85653333   |

验证一下：
```java
String test = "020-85653333";
String reg="(?:0\\\\d{2})-(\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：
```
分组的个数有：1
第0个分组为：020-85653333
第1个分组为：85653333
```



## 3. 反向引用

从上所述的捕获，可知：

捕获会返回一个捕获组，这个分组是**保存在内存中**。不仅可以**在正则表达式外部通过程序进行引用**，也可以**在正则表达式内部进行引用，这种引用方式就是反向引用**。

根据捕获组的命名规则，反向引用可分为：

> **数字编号组反向引用**：\k或\number 
>
> **命名编号组反向引用**：\k或者\\'name'

**捕获组通常是和反向引用一起使用**。捕获组是匹配表达式的内容按序号或者命名保存在内存中的。

注意两个字眼：“内容” 和 “使用”。这里所说的**“内容”，是匹配结果**，而不是表达式本身。 这里所说的“使用”，主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧： 比如要**查找一串字母 "aabbbbgbddesddfiid" 里成对的字母** 

如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的， 现在我们先用**程序思维理一下思路**：

> 1）匹配到一个字母
>
> 2）匹配第下一个字母，检查是否和上一个字母是否一样 
>
> 3）如果一样，则匹配成功，否则失败

匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？ 

**可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件**。

 首先匹配一个字母：\w 我们**需要做成分组才能捕获，因此写成这样：(\w)**

然后以这个捕获组作为条件，可得：**(\w)\1** 

**\1 是数字编号组反向引用。表示引用前面第一个捕获组的内容**。 还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名。在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的** 。

因此要引用第一个捕获组，根据反向引用的捕获组命名规则，就需要 **\k<1>或者\1** 当然，通常都是是后者。 测试：

```java
String test = "aabbbbgbddesddfiid";
Pattern pattern = Pattern.compile("(\\w)\\1");
Matcher mc= pattern.matcher(test);
while(mc.find()){
    System.out.println(mc.group());
}
```

输出结果：

```
aa
bb
bb
dd
dd
ii
```

嗯，这就是我们想要的了。 在举个替换的例子，假如想要把字符串中abc换成a

```
String test = "abcbbabcbcgbddesddfiid";
String reg="(a)(b)c";
System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```
abbabcgbddesddfiid
```



### 4. 贪婪和非贪婪

#### 1.贪婪

我们都知道，贪婪就是不满足，尽可能多的要。 在正则中，贪婪也是差不多的意思:

> **贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。**
>
> 特性：**一次性读入整个字符串从左到右进行匹配，每当不匹配就在接口中舍弃最右边的字符。继续向后匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯）**，直到匹配成功或者把整个字符串舍弃完为止，因此**它是一种最大化的数据返回，能多不会少**。

**重复限定符就是贪婪量词**，比如表达式：

**\d{3,6}**

用来匹配3到6位数字，在这种情况下，**它是一种贪婪模式的匹配**，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。 如

```java
String reg="\\d{3,6}";        
String test="61762828 176 2991 871";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 44 871
贪婪模式：\\d{3,6}
匹配结果：617628
匹配结果：176
匹配结果：2991
匹配结果：871
```

由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。

 一个量词就如此贪婪了， 那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

> **多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰**。
>
> **如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先级从高到低，先最大数量匹配左边的剩余再分配下一个量词匹配。**
>
> 但是注意，**上述行为有一个前提：整个表达式能得到匹配**

```java
String reg="(\\d{1,2})(\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2})(\\d{3,4})
匹配结果：617628
匹配结果：2991
匹配结果：87321
```

> “617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628 
>
> "2991" 是前面的\d{1,2}匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)
>
> "87321"是前面的\d{1,2}匹配出了87，后面的匹配出了321



#### 2. 懒惰（非贪婪）

> 懒惰匹配：**当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。**
>
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

**懒惰量词是在贪婪量词后面加个“？”**

| 语法   | 说明                        |
| ------ | --------------------------- |
| *?     | 重复零次或更多次,但尽可能少 |
| +?     | 重复一次或更多次,但尽可能少 |
| ??     | 重复零次或一次,但尽可能少   |
| {n}?   | 重复n次,但尽可能少          |
| {n,}?  | 重复n次或更多次,但尽可能少  |
| {n,m}? | 重复n到m次,但尽可能少       |



```java
String reg="(\\d{1,2}?)(\\\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2}?)(\\d{3,4})
匹配结果：61762
匹配结果：2991
匹配结果：87321
```

解答：

> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762
>
> "2991" 是左边的懒惰匹配出2，右边的贪婪匹配出991
>
> "87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321



## 5. 反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些**常用的反义元字符**：

| 元字符 | 说明                                         |
| ------ | -------------------------------------------- |
| \W     | 匹配 任意不是字母或数字或下划线或汉字 的字符 |
| \S     | 匹配 任意不是空白符 的字符                   |
| \D     | 匹配 任意不是数字 的字符                     |
| \B     | 匹配 不是**单词**的开始或结束 的位置         |
| [^x]   | 匹配 除了 x 以外的任意字符                   |

