# 结构
基于栈的特点：
- Hotspot 是**基于栈**的，而不是基于寄存器的；
 - **可移植性更好、指令更短**、实现起来简单；
- 不能随机访问栈中的元素，完成相同功能所需要的指令数更多，需要频繁出入栈。

基于寄存器的特点
- 速度快，有利于程序运行速度的优化；
- 操作数需要显式指定，指令也比较长。

# Java字节码
Java字节码中**栈用于操作**，需要进行的操作都会放入**操作数栈(oprand stack)**中；**局部变量用于存储**，操作最后的结果一般都存储在变量中。
参见[[JVM内存结构]]

Java 字节码由操作码和操作数组成。
-   **操作码（Opcode）**：一个字节长度（0-255，意味着指令集的操作码总数不可能超过 256 条），代表着某种特定的操作含义。
-  **操作数（Operands）**：零个或者多个，紧跟在操作码之后，代表此操作需要的参数。

由于 Java 虚拟机是基于栈结构，所以大多数指令都**只有一个操作码**。

## 指令理解
**加载到栈（入栈）-- load** 和 **从栈中存储到变量（出栈）-- store** 是最常见的操作。
1. `aload_0`将局部变量表中下标为 0 （**实际上是 this**）的数据压入操作数栈中，只有操作码没有操作数；
2.  `invokespecial #1` **调用成员方法或者构造方法**，并传递常量池中下标为 1 的常量，由操作码和操作数组成的。

参见
[[#字节码指令]]
[[字节码示例]]


# 字节码指令
## 1 加载与存储指令

加载（load）和存储（store）相关的指令是使用最频繁的指令，用于将数据从栈帧的局部变量表和操作数栈之间来回传递。

### 1.1 将局部变量表中的变量压入操作数栈中

-   xload_n（x 为 i、l、f、d、a，n 默认为 0 到 3），表示将第 n 个局部变量压入操作数栈中。
-   xload #p （x 为 i、l、f、d、a），通过指定参数 p 的形式，将局部变量压入操作数栈中，当使用这个指令时，表示局部变量的数量可能超过了 4 个

x 为操作码助记符，表明是哪一种数据类型：
![[操作码助记符.png]]

#### 注意
1. 大部分的指令都不支持 byte、short 和 char，甚至没有任何指令支持 boolean 类型。
2. 编译器会将 byte 和 short 类型的数据带符号扩展（Sign-Extend）为 int 类型
3. boolean 和 char 零位扩展（Zero-Extend）为 int 类型。

#### 示例
```java
private void load(int age, String name, long birthday, boolean sex) {  
 System.out.println(age + name + birthday + sex);  
}
```

通过 jclasslib 看一下 `load()` 方法（4 个参数）的字节码指令。


