## 字节码
- 了解 JVM 底层实际处理的原理；
- 了解 JVM 特性；

### 工具
1. Jdk：javac 编译和 javap反编译；
2. jclasslib：字节码阅读工具。

### example
1. jdk版本：

```
$ java -version
java version "1.8.0_77"
Java(TM) SE Runtime Environment (build 1.8.0_77-b03)
Java HotSpot(TM) 64-Bit Server VM (build 25.77-b03, mixed mode)
```

2. 源码

```java
public class StringTest{
	public static void main(String[] args) {
        String a = "hello";
        String c = a+2;
        String d = a+2;
        System.out.println(c==d);
    }
}
```

3. 字节码

```
 0 ldc #2 <hello>  //从常量池加载“hello”，并入栈（操作数栈）
 2 astore_1        //出栈，保存（a表示应用类型）到局部变量1中
 3 new #3 <java/lang/StringBuilder> // 
 6 dup
 7 invokespecial #4 <java/lang/StringBuilder.<init> : ()V>
10 aload_1
11 invokevirtual #5 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
14 iconst_2
15 invokevirtual #6 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
18 invokevirtual #7 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
21 astore_2
22 new #3 <java/lang/StringBuilder>
25 dup
26 invokespecial #4 <java/lang/StringBuilder.<init> : ()V>
29 aload_1
30 invokevirtual #5 <java/lang/StringBuilder.append :(Ljava/lang/String;)Ljava/lang/StringBuilder;>
33 iconst_2
34 invokevirtual #6 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
37 invokevirtual #7 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
40 astore_3
41 getstatic #8 <java/lang/System.out : Ljava/io/PrintStream;>
44 aload_2
45 aload_3
46 if_acmpne 53 (+7)
49 iconst_1
50 goto 54 (+4)
53 iconst_0
54 invokevirtual #9 <java/io/PrintStream.println : (Z)V>
57 return
```

可以看到，String的“+”操作实际执行的是：`new StringBuilder().append("hello").append("2").toString()`. 查看 StringBuilder 的源码
所以c和d是两个不同的对象，"c\=\=d"是false