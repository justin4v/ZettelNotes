# 实现的方式
主流的操作系统都提供了线程实现，Jav语言则是提供了在不同硬件和操作系统平台下对线程操作的统一处理。
每个已经调用过 start() 方法且还未结束的`java.lang.Thread`类的实例就代表一个线程。  
其实Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为 Native（参见[[JVM内存结构]]） 。
在Java中，Native方法往往就意味着**没有使用或无法使用平台无关的手段来实现（通常最高效率的手段就是平台相关的手段）**

线程的实现一般有三种方式：
-   **内核线程实现**（1:1）；
-   **用户线程实现**（1:N）；
-   用户线程加轻量级进程的**混合实现**（N:M）；

## 内核线程模型
内核线程模型即完全依赖操作系统内核提供的**内核线程（Kernel-Level Thread ，KLT）** 来实现多线程。
在此模型下，线程的切换调度由系统内核完成，系统内核负责将多个线程执行的任务映射到各个CPU中去执行。
用户进程使用系统内核提供的接口——**轻量级进程（Light Weight Process，LWP**）来使用系统内核线程。
在此种线程模型下，由于一个用户线程对应一个LWP，因此某个LWP在调用过程中阻塞了不会影响整个进程的执行。

但这种线程模型也有如下缺点：
-   各种线程的操作都需要在用户态和内核态之间频繁切换，消耗较大
-   每个LWP都需要一个内核线程来支持执行用户代码，会消耗更多的内核内存空间，因此系统内核提供的KLT的数量是有限制的。


![[内核线程模型.png]]


## 用户线程模型
用户线程模型完全建立在用户空间的线程库上，不依赖于系统内核，用户线程的创建、同步、切换和销毁等操作完全在用户态执行，不需要切换到内核态。


## 

# 不同虚拟机的实现方式
Java线程在早期的 **Classic 虚拟机**上（JDK1.2以前），是基于一种被称为 **“绿色线程”（Green Threads）** 的用户线程实现的。
从JDK1.3起，主流平台上的主流商用Java虚拟机的线程模型普遍都被替换为 基于操作系统原生线程模型实现，即采用**内核线程1:1**的线程模型。