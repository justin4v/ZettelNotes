# 内存布局
![[对象的内存布局.png]]

主要有：
-   对象头(Header)；
-   实例数据(Instance Data)；
-   对齐补充(Padding)。


## 对象头
-  **Mark Word 运行时元数据**，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；
-   类型指针，指向它的**类元数据 InstanceKlass** 的指针，JVM通过该指针能确定对象所属类。 另外,如果对象是一个数组，对象头中还要包含数组长度 (因为从数组的元数据无法确定数组的大小)。

## 实例数据
是程序定义的各种字段的内容，如变量和方法，父类也会会记录下来。

## 对齐填充
*无特别含义，仅起占位符作用*。
HotSpot 要求对象的大小必须是 8 字节的整数倍，由于*对象起始地址必须是8字节的整数倍*，但实例数据部分的长度是任意的，需要确保对象的总长度为 8 的整数倍。

## 实例结构图示

![[实例的结构.png]]


## 对象访问
栈上的 reference 数据存放的是一个地址，那么根据地址类型的不同,对象有不同的访问方式

### 句柄访问方式 
Java堆中需要有一块叫做"句柄池"的内存,存放所有对象的地址和所有对象所属类的类信息。
**reference 中存放对象在句柄池中地址**。
访问对象时：
1. 首先通过 reference找 到该对象的句柄；
2. 根据句柄中对象的地址再访问对象。
![[句柄访问对象.png]]


### 直接指针访问
**reference直接存放对象地址**，通过引用能够*直接访问对象*。
但对象所在的内存空间中需要**额外存储对象所属的类信息的地址**。
![[直接指针访问对象.png]]

### 两种方式的比较
1. 句柄是稳定的句柄地址，对象移动时也只改变句柄中的实例数据指针，reference 本身不变；
2. 直接指针只需一次寻址操作，节省指针定位的开销。

`HotSpot采用直接指针访问方式`，因为对象的访问十分频繁，直接寻址指针节省更多时间。







