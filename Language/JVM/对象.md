# 内存布局
![[对象的内存布局.png]]

主要有：
-   对象头(Header)；
-   实例数据(Instance Data)；
-   对齐补充(Padding)。


## 对象头
-   存储对象在运行过程中自身所需要的一些数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；
-   类型指针，即对象指向它的类元数据的指针,JVM通过该指针能确定这个对象是哪个类的实例. 另外,如果对象是一个数组,那么对象头中还要包含数组长度(因为从数组的元数据无法确定数组的大小).

## 实例数据
实例数据部分就是程序定义的各种字段的内容,包含父/子类的都会记录下来

## 对齐填充
并非必然存在,无特别含义,仅起占位符作用
HotSpot要求对象的大小必须是8字节的整数倍 由于对象起始地址必须是8字节的整数倍,但实例数据部分的长度是任意的,因此需要对齐补充字段确保整个对象的总长度为8的整数倍

## 实例结构图示

![[实例的结构.png]]


## 对象访问
栈上的reference数据存放的是一个地址,那么根据地址类型的不同,对象有不同的访问方式

### 句柄访问方式 
Java堆中需要有一块叫做"句柄池"的内存,存放所有对象的地址和所有对象所属类的类信息
reference中存放的是对象在句柄池中的地址. 访问对象时,首先需要通过reference找到该对象的句柄,然后根据句柄中对象的地址再访问对象
![[句柄访问对象.png]]


### 直接指针访问
reference直接存放对象地址,从而不需要句柄池,通过引用能够直接访问对象 但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址
![[直接指针访问对象.png]]

### 两种方式的比较
使用句柄最大好处是reference中存储的是稳定的句柄地址,在对象被移动时也只改变句柄中的实例数据指针,而reference本身不需要修改 `而HotSpot采用直接指针访问方式`,因为它只需一次寻址操作,节省了一次指针定位的时间开销,对象的访问又十分频繁,从而性能比句柄访问方式快一倍







