
# Conception
1. Class 文件是**8 位字节为单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符；
3. 存储 8 位字节以上数据时，按照**高位在前**的方式分割成若干个 8 位字节进行存储。
4. 
# Demo
```java
public class JavaCodeComplierDemo{
	private int numberA = 1;
	public int sum(){
		int numberB = 2;
		int sum = numberA + numberB;
		return sum;
	}
}

```

用 **javac** 命令编译后就会得到 .class 文件内容如下：
![[demo的class文件内容.png]]

# Structure
Class 文件格式采用类似于 **C 语言结构体**的伪结构来存储数据，只有两种数据类型：**无符号数和表**。
-   无符号数是基本的数据类型。*u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节、8个字节的无符号数*。无符号数可以来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值；
-   **表是多个无符号数或者其他表作为数据项构成的复合数据类型**。所有表都习惯性的以“\_info”结尾；

整体结构图如下：

![[java class 文件整体结构图.png]]

## 魔数（Magic Number）
每个字节码文件的头 4 个字节称为 **魔数（Magic Number）**，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。

魔数的固定值为: **0xCAFEBABE**，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。

> 有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。

## 版本号（Version）
版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。

## 常量池（Constant Pool）
紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 **final** 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。
常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：
![[常量池结构.png]]


### 常量池计数器（constant_pool_count）
由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，
图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33，排除下标 0，也就是说这个类文件里有 32 个常量。

![[class文件前十个字节举例.png]]


### 常量池数据区
 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info 每种类型的结构都是固定的，如图 7 所示:

![[constant_info类型.png]]

以 CONSTANT_Utf8_info 以它为例，它的结构如表 1 所示:

表 1 首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示:

![[CONSTANT_Utf8_info 结构.png]]

其它类型的 cp_info 结构和 CONSTANT_Utf8_info 结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。

通过: **javap -verbose JavaCodeCompilerDemo** 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个常量池 cp_info 结构的类型和值都很明确地呈现出来，如图 9 所示:

![[demo完整常量池.png]]


## 访问标志（access_flag）
常量池结束之后的两个字节，描述了该 Class 是类还是接口，以及是否被 **Public**、**Abstract**、**Final** 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。

需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 按位或 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 **0x0001 | 0x0010 = 0x0011**。

表 2

## 当前类名（this_class）
访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。

## 父类名称（super_class）
当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。

## 接口信息（interfaces）
父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。

**（8）字段表（field_table）** 字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 局部变量。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 **field_info**。字段表结构如图 10 所示: