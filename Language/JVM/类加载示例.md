# example
## source code

```java
public class ClassInitialTest {  
    public static int k = 0;  
    public static ClassInitialTest t1 = new ClassInitialTest("t1");  
    public static ClassInitialTest t2 = new ClassInitialTest("t2");  
    public static int i = print("i");  
    public static int n = 99;  
    private int a = 0;  
    public int j = print("j");  
    {  
        print("构造块");  
    }  
    static {  
        print("静态块");  
    }  
  
    public ClassInitialTest(String str) {  
        System.out.println((++k) + ":" + str + "   i=" + i + "    n=" + n);  
        ++i;  
        ++n;  
    }  
  
    public static int print(String str) {  
        System.out.println((++k) + ":" + str + "   i=" + i + "    n=" + n);  
        ++n;  
        return ++i;  
    }  
  
    public static void main(String args[]) {  
        ClassInitialTest t = new ClassInitialTest("init");  
    }  
}
```

## output
代码输出结果：
```java
1:j   i=0    n=0
2:构造块   i=1    n=1
3:t1   i=2    n=2
4:j   i=3    n=3
5:构造块   i=4    n=4
6:t2   i=5    n=5
7:i   i=6    n=6
8:静态块   i=7    n=99
9:j   i=8    n=100
10:构造块   i=9    n=101
11:init   i=10    n=102
```

## 解释
1. 在 main 中调用 new，属于**主动调用**，JVM 将对 *ClassInitialTest* 进行初始化，Loading->Linking->Initialization（参考：[[JVM类加载机制]]）；
2. 在 Linking 的 Preparation 阶段，对 static 变量进行**默认初始化**，赋予变量类型的默认值；
3. 在 Initialization 阶段，首先**按照顺序**收集初始化语句（static、非static变量、静态构造块、非静态构造块）到 `clinit()`;
4. 对 static - k 赋值初始化后（无打印输出），接着对 static - t1 进行赋值初始化，此时在 Heap 中新建类 ClassInitialTest 的对象，并对对象初始化；
5. 新建对象并初始化，首先要检查类有没有加载完成（Loading->Linking->Initialization），因为此前类已经进行了默认初始化，故直接进入*赋值初始化*。如果再次对static-t1进行赋值初始化，将会进入到*infinite loop 无限循环*，所以此时会*跳过 static 的赋值初始化*，*直接使用 static 的默认值*（*设置默认初始化阶段的原因之一*），进入到非 static 变量的赋值初始化阶段；
6. 所以首先对 non-static-a 初始化为0（无输出）、接着对 non-static-j 初始化，输出：`1:j   i=0    n=0`、接着对构造块初始化，输出：`2:构造块   i=1    n=1`、最后调用构造函数初始化，输出：`3:t1   i=2    n=2`，到此完成了对 static-t1 的初始化。
7. 类似的，对 static-t2 的初始化会输出 4、5、6 三行，接着对 static-i 初始化，输出 7 行