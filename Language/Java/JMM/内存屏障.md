#Todo #JVM #Memory-Barriers

# 原子操作
JMM 规定了变量在主内存和工作内存中如何传输，也提供了八个原子指令来具体实现
![[JMM定义的原子操作.png]]

对于上面八个原子操作的使用，JMM制定了一些规则：

1.  read/load、store/write必须成对出现
2.  不允许线程丢弃最近的assign操作，即工作内存中变量修改之后必须同步到主内存
3.  不允许线程无原因地(没有assign操作）将变量工作内存同步到主内存
4.  变量只能在主内存中诞生，并且必须在工作内存中初始化才能使用。即use、store之前必须经过load和assign
5.  一个变量在同一时刻只能被一个线程lock。但一个线程可以lock多次。几次lock，只有对应次数的unlock变量才能解锁
6.  一个变量被lock后，**会清空所有工作内存中此变量的值**。再次使用需要重新load、assign来初始化
7.  一个变量未被lock，则不允许对它执行unlock，也不允许unlock其他线程lock的变量
8.  一个变量unlock前，必须先把此变量同步到主内存中(store、write)

## 如何理解这八条规则和八条指令？

lock/unlock指令让一个变量被一个线程独享，其他六个指令都是变量在工作内存中的赋值和传输操作。JMM的出现是为了让一个线程对变量修改时，其他线程停止修改，并能获取最新值，从而保证数据的一致性。

而lock可以锁定变量，让变量只能被一个线程修改，且其他线程工作内存中的此变量的值会失效，必须通过指令来获取最新的值。

## JMM 规范
1.  原子性：lock和unlock提供了大范围的原子性，其他操作都具有原子性
2.  可见性：当一个线程修改了变量的值，其他线程能立即得知修改
3.  有序性：在本线程内操作都是有序的，相对于多个线程是无序的


# volatile 内存语义
volatile我们都知道是java的关键字用来保证数据可见性，防止指令重排的效果。包括JUC里AQS Lock的底层实现也是基于volatitle来实现。

volatile写的内存语义

> 当写一个volatile变量的时候，JMM会把该线程对应的本地内存变量值刷新到主内存

volatile读的内存语义

> 当读一个volatile变量的时候，JMM会把线程本次内存置为无效。线程接下来将从主内存中读取共享变量（也就是重新从主内存获取值，更新运行内存中的本地变量）

上面两个语义，保证了volatile变量写入对线程的可见性

## volatile 内存屏障

![[volatile 插入的默认屏障.png]]

```java
class X {
    
int a, b;
    
volatile int v, u;
    
void f() {     
int i, j;

    i = a;
// load a  普通load
    j = b;
// load b  普通load
    i = v;
// load v  volatile load
        
// LoadLoad
    j = u;
// load u  volatile load
        
// LoadStore
    a = i;
// store a 普通store  
    b = j;
// store b 普通store
        
// StoreStore
    v = i;
// store v volatile store
        
// StoreStore
    u = j;
// store u volatile store
        
// StoreLoad
    i = u;
// load u  volatile load
        
// 两个屏障 LoadLoad 和 LoadStore
    j = b;
// load b  普通load
    a = i;
// store a 普通store
    }
}
```


# Happen-Before 先行原则

为了不让所有的操作有序都借助synchronized、volatile来完成，所有就有了以下无需借助同步器的天然先行发生关系，即不用锁就能保证执行顺序。

1.  程序顺序规则：程序中操作A在B前，线程中A操作也必须在B之前执行
2.  监视器加锁规则：在监视器锁上的解锁操作必须在加锁之前执行
3.  volatile变量规则：对volatile变量的写入必须在读取之前执行
4.  线程启动规则：Thread.start()调用必须在该线程执行任何操作之前
5.  线程结束规则：线程中任何操作都先行发生于对此线程的终止检测
6.  中断规则：对线程interrupt()的调用先于被中断线程检测到中断事件的发生
7.  终结器规则：对象构造方法执行先于它的finalize()方法
8.  传递性：如果操作A先于B，操作B先于C，那操作A必先于C



# 参考
1. [内存屏障 · JVM (gitbooks.io)](https://luoyoubao.gitbooks.io/jvm/content/javanei-cun-mo-xing/nei-cun-ping-zhang.html)
2. [JMM中的重排序及内存屏障](https://www.cnblogs.com/wuqinglong/p/9947786.html)