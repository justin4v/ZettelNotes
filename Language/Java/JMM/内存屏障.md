#Todo #JVM #Memory-Barriers

# 原子操作
JMM 规定了变量在主内存和工作内存中如何传输，也提供了八个原子指令来具体实现
![[JMM定义的原子操作.png]]


# volatile 内存语义
volatile我们都知道是java的关键字用来保证数据可见性，防止指令重排的效果。包括JUC里AQS Lock的底层实现也是基于volatitle来实现。

volatile写的内存语义

> 当写一个volatile变量的时候，JMM会把该线程对应的本地内存变量值刷新到主内存

volatile读的内存语义

> 当读一个volatile变量的时候，JMM会把线程本次内存置为无效。线程接下来将从主内存中读取共享变量（也就是重新从主内存获取值，更新运行内存中的本地变量）

上面两个语义，保证了volatile变量写入对线程的可见性

## volatile 内存屏障

![[volatile 插入的默认屏障.png]]

```java
class X {
    
int a, b;
    
volatile int v, u;
    
void f() {     
int i, j;

    i = a;
// load a  普通load
    j = b;
// load b  普通load
    i = v;
// load v  volatile load
        
// LoadLoad
    j = u;
// load u  volatile load
        
// LoadStore
    a = i;
// store a 普通store  
    b = j;
// store b 普通store
        
// StoreStore
    v = i;
// store v volatile store
        
// StoreStore
    u = j;
// store u volatile store
        
// StoreLoad
    i = u;
// load u  volatile load
        
// 两个屏障 LoadLoad 和 LoadStore
    j = b;
// load b  普通load
    a = i;
// store a 普通store
    }
}
```


# 参考
1. [内存屏障 · JVM (gitbooks.io)](https://luoyoubao.gitbooks.io/jvm/content/javanei-cun-mo-xing/nei-cun-ping-zhang.html)
2. [JMM中的重排序及内存屏障](https://www.cnblogs.com/wuqinglong/p/9947786.html)