#JMM #Memory-Barriers 

##  不能让CPU闲着

考虑这么一个场景，`CPU 0` 和`CPU 1` 同时拥有某个缓存行，两个缓存行都处于`Shared`状态，`CPU 0`想对自己的缓存行执行write操作，必须先发送`Invalidate`消息让`CPU 1`中的缓存行失效

![[CPU等待stall示意.gif]]

由于`CPU 0`必须等到`CPU 1`反馈了`Invalidate Acknowledge`之后才能确保自己可以操作缓存行，所以从发出`Invalidate`直到收到`Invalidate Acknowledge`的这段时间，`CPU 0`一直处于闲置状态。

CPU是何等宝贵的资源，让它闲着是不可能的，绝对不可能的！

硬件工程师为了解决这个问题，引入了`Store Buffers`。

###  引入Store Buffers


# 内存屏障
为什么要特意加上`smp`呢？因为即便现代处理器会乱序执行，但在单个CPU上，指令能通过指令队列顺序获取指令并执行，结果利用队列顺序返回寄存器，这使得程序执行时所有的内存访问操作看起来像是按程序代码编写的顺序执行的，因此没必要使用内存屏障（前提是不考虑编译器的优化的情况）。

内存屏障听起来很高大上，但是对于软件开发者而言其实非常简单，总结一句话就是：

**在内存屏障语句之后的所有针对Cache的写操作开始之前，必须先把Store Buffer中的数据全部刷新到Cache中。**

如果你看明白了我上面说的`Store Buffer`，这句话是不是贼好懂呢？换个角度再翻译一下，就是一定要保证**存到Store Buffer中的数据有序地刷新到Cache中**，这样就可以避免发生指令重排序了。

如何保证有序呢？

最简单的方式就是让CPU傻等，`CPU 0` 在执行第5步之前必须等着`CPU 1`给出反馈，直到清空自己的`Store Buffer`，然后才能继续向下执行。

啥？又让CPU闲着？一切让CPU闲置的方法都是馊主意！

还有一个办法就是让数据在`Store Buffer`中排队，谁先进入就必须先刷新谁，后边的必须等着！

**这样一来，本来可以直接写入Cache的操作（比如待操作的数据已经存在于自己的Cache中了）也必须先存到Store Buffer，然后依序进行刷新**。


# 参考
1. [说透缓存一致性与内存屏障](https://www.cnblogs.com/chanmufeng/p/16523365.html)