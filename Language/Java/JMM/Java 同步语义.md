*CPU和编译器* 为代码执行增加了很多不确定性（见[[代码重排与乱序执行]]）， 在没有通过显式的同步机制调整的情况下，在多线程环境中， 一个程序里的每一个具体行为将在时间顺序上交错混杂。
这种互相交织的代码行为的实际执行顺序称为*执行轨迹（Execution Trace)*，一个程序可以有多个，甚至无穷个执行轨迹。  

在Java语言中，下面的一些行为具有同步语义，称之为同步活动（Synchronization Actions)，他们提供了对**执行轨迹加以约束的手段**。

# 加锁与解锁
在JAVA中，每一个同步方法或同步块都与一个具体的同步对象关联(在同步块上是指定的锁对象，同步方法上则与this对象或class实例关联)，在进入同步方法或同步块后，对同步对象的 Monitor 有一个锁定动作; 相应地在退出当前同步块时有解锁动作。

另外，在锁对象上的 wait 操作，是一次释放锁和一次重新获取锁的行为的组合：在进入时释放当前的锁，在以未被中断的方式返回的情况下重新获取到锁。

加锁操作由一个设置锁对象上的加锁状态的CAS操作与一个紧接着的内存屏障动作共同组成，这个内存屏障将确保加锁前后的数据访问活动不会出现跨屏障的重排，同时还将使缓存失效以确保后续本线程内的内存读都会得到主存中的最新的状态。

如果当前的锁对象被其他线程持有，CAS操作未能成功设置锁状态，加锁操作还会将当前线程置于这个锁的等待集上，等待当前锁的所有者在后续释放锁时被唤醒起来再继续尝试。

解锁动作的顺序则刚好相反，会先设置内存屏障，再通过 CAS 清除当前锁的持有状态。这个内存屏障同样也有确保不会有跨同步块边界的重排的作用，同时还会确保缓存的数据都刷新到主存。完成这些动作之后解锁动作将从该锁对象的等待集中选择一个唤醒继续操作。

## 改造示例
现在我们尝试用加锁的方式来代码进行一下改造。
```java
class SynchronizeWithLockDemo{
	int a=0;
	boolean b=true;
	Object lock = new Object();
	
	// 在线程1中执行
	void writer(){
	synchronized(lock){  //加锁(1)
			a=10; 
			b=false; 
			lock.notify();
		};  //所有写都将被外部可见 (2)
	}
	
	// 在线程2中执行
	void reader(){
	synchronized(lock){   //加锁，所有的外部操作都可见  (3)
			while(b)  lock.wait(); // 如果b还没有设置，等待 (4) 
			assert(a==10); 
		};
	}   // (5)
}
```

之前([[代码重排与乱序执行#影响]])无法确保对a, b的写入在线程2中被观察到的顺序一致；
现在，由于lock/unlock动作中分别带有清空缓存与强制刷新缓存到主存的逻辑；
所以，在语句2结束后，一定会观察到 b == true && a == 10 的结果， 无论这两个写是以何种顺序发生。


此刻线程2再执行我们将毫无争议地知道我们的断言将会成功。而如果线程2中语句3~5先被执行，我们会在语句4时释放出对于锁对象的占用，允许线程1中代码先行完成后再由语句4的点上继续，此时b已经被设置，我们将成功得到预期中的断言结果。

前面我们演示Cpu与内存重排的时候的代码片断，我们曾经称它们实际是有问题的。其原因在于对应的代码片断中不存在任何的lock/unlock的操作，从而无法确保在线程2当中，在线程1中对标志变量b进行的修改可以及时地被检测到（甚至可能会由于编译器的优化，在线程2中对b进行了初次的读取后，完全不再尝试从主内存中获取新的内容而永远不再被检测到）而造成我们的代码失效。

  
上例当中我们通过加锁与解锁带来缓存清理和内存强制刷新语义解决了这个问题，Java中还提供了另一种方式，将字段申明成为易变(volatile)的 来解决这个问题。

# 易变字段 (volatile field)
