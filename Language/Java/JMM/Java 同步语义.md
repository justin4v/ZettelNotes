*CPU和编译器* 为代码执行增加了很多不确定性（见[[代码重排与乱序执行]]）， 在没有通过显式的同步机制调整的情况下，在多线程环境中， 一个程序里的每一个具体行为将在时间顺序上交错混杂。
这种互相交织的代码行为的实际执行顺序称为*执行轨迹（Execution Trace)*，一个程序可以有多个，甚至无穷个执行轨迹。  

在Java语言中，下面的一些行为具有同步语义，称之为同步活动（Synchronization Actions)，他们提供了对**执行轨迹加以约束的手段**。

# 加锁与解锁
在JAVA中，每一个同步方法或同步块都与一个具体的同步对象关联(在同步块上是指定的锁对象，同步方法上则与this对象或class实例关联)，在进入同步方法或同步块后，对同步对象的 Monitor 有一个锁定动作; 相应地在退出当前同步块时有解锁动作。

另外，在锁对象上的 wait 操作，是一次释放锁和一次重新获取锁的行为的组合：在进入时释放当前的锁，在以未被中断的方式返回的情况下重新获取到锁。

加锁操作由一个设置锁对象上的加锁状态的CAS操作与一个紧接着的内存屏障动作共同组成，这个内存屏障将确保加锁前后的数据访问活动不会出现跨屏障的重排，同时还将使缓存失效以确保后续本线程内的内存读都会得到主存中的最新的状态。

如果当前的锁对象被其他线程持有，CAS操作未能成功设置锁状态，加锁操作还会将当前线程置于这个锁的等待集上，等待当前锁的所有者在后续释放锁时被唤醒起来再继续尝试。

解锁动作的顺序则刚好相反，会先设置内存屏障，再通过 CAS 清除当前锁的持有状态。这个内存屏障同样也有确保不会有跨同步块边界的重排的作用，同时还会确保缓存的数据都刷新到主存。完成这些动作之后解锁动作将从该锁对象的等待集中选择一个唤醒继续操作。

## 改造示例
现在我们尝试用加锁的方式来代码进行一下改造。
```java
class SynchronizeWithLockDemo{
	int a=0;
	boolean b=true;
	Object lock = new Object();
	
	// 在线程1中执行
	void writer(){
	synchronized(lock){  //加锁(1)
			a=10; 
			b=false; 
			lock.notify();
		};  //所有写都将被外部可见 (2)
	}
	
	// 在线程2中执行
	void reader(){
	synchronized(lock){   //加锁，所有的外部操作都可见  (3)
			while(b)  lock.wait(); // 如果b还没有设置，等待 (4) 
			assert(a==10); 
		};
	}   // (5)
}
```

之前([[代码重排与乱序执行#影响]])无法确保对a, b的写入在线程2中被观察到的顺序一致；
现在，由于lock/unlock动作中分别带有清空缓存与强制刷新缓存到主存的逻辑；
所以，在语句2结束后，一定会观察到 b == true && a == 10 的结果， 无论这两个写是以何种顺序发生。


此刻线程2再执行我们将毫无争议地知道我们的断言将会成功。而如果线程2中语句3~5先被执行，我们会在语句4时释放出对于锁对象的占用，允许线程1中代码先行完成后再由语句4的点上继续，此时b已经被设置，我们将成功得到预期中的断言结果。

前面我们演示Cpu与内存重排的时候的代码片断，我们曾经称它们实际是有问题的。其原因在于对应的代码片断中不存在任何的lock/unlock的操作，从而无法确保在线程2当中，在线程1中对标志变量b进行的修改可以及时地被检测到（甚至可能会由于编译器的优化，在线程2中对b进行了初次的读取后，完全不再尝试从主内存中获取新的内容而永远不再被检测到）而造成我们的代码失效。

  
上例当中我们通过加锁与解锁带来缓存清理和内存强制刷新语义解决了这个问题，Java中还提供了另一种方式，将字段申明成为易变(volatile)的 来解决这个问题。

# 易变字段 (volatile field)
当一个字段申明中加上了volatile关键字后，我们称这个字段是易变字段。易变字段有下面的语义要求：一方面会要求易变字段不得被缓存，另一方面还要求禁止一切涉及到易变字段的重排（即，不仅仅易变字段的访问间不得重排， 易变字段与普通之段的访问间也不得重排）。

  

由于易变字段的每一次读写都是通过内存直接进行，且不允许与其他的内存操作重排，易变字段的访问也就有了某种同步的意味：读易变字段清空了对该字段的缓存，写易变字段完成后强制写回了主存；没有跨越易变字段访问前后的指令与内存访问重排。

## 改造示例
我们可以把易变字段的访问理解为一种仅包含对该易变字段的访问的简化的同步块。 在这样的保障之下，我们看看对清单2中代码的另一种改造方式：

```java
class VolatileDemo{
	int a=0;
	volatile boolean b=true; // 易变字段
	
	// 在线程1中执行
	void writer(){
		a=10;  // 写入a (1)
		b=false; // 写入b (2)
	}
	
	// 在线程2中执行
	void reader(){
		while(b) continue; // 从变量b加载  (3) 
		assert(a==10); // 从变量a加载  (4)
}
```

在这个清单中，语句2,3形成了事实上的同步关系， 语句3无论首次执行是发生在语句2之前或之后，都只会在语句2执行完成之后才能完成；而依据易变字段与普通字段的访问不得重排的原则，我们知道语句1先于语句2发生，语句3先于语句4发生， 而2， 3之间有同步关系，这样我们就可以轻易推导出来，1将会先于4发生。  


 这样我们就可以确信，无论线程1,2以何种顺序先后启动执行，我们的这段程序中的各个行为都有明确的先后顺序，尽管语句1,4中执行的是相互冲突的行为，由于他们之间有着明确的先后顺序，我们的程序也将得到明确的执行顺序和结果。
 
 
 # 同步活动（Synchronization Actions)，同步顺序(Synchronization Order)， ”与同步“(Synchronize-with)关系
 除开前面我们已经提到的加锁、解锁， 易变字段的访问之外， 在JMM当中还定义了下面的一些同步活动：

> - 线程的首活动（First Action )与尾活动（Last/Final Action)：它们并不是对应于一条具体的语句，而是对线程的开始与结束中必须进行的一组操作的合成而来的一个概念。
> 
> - 启动线程活动与检测线程结束活动
> 
>-  一个程序的每一次具体的执行中，所有的同步活动都会形成一个明确的执行先后顺序， 即一个同步活动不会与其他的同步活动同时发生（或先，或后，但不允许同时发生，即使是在多核的机器上也是如此），我们称这个顺序为这次执行上的同步顺序(Synchronization Order)。
> 
> 
> 同时在一个程序的所有的同步活动的集合上，还存在着一种“与同步”（synchronize-with）的关系(后续简写为SW关系)，它们的定义相当明确：
> - 在一个monitor m上的解锁动作与在同步顺序上的同一个monitor上的后续加锁动作同步
> - 在一个易变字段上的写操作与在同步顺序上同一个字段的后续读操作同步
> - 启动线程活动与被它启动的线程的首活动同步
> - 线程的尾活动与检测该线程结束的活动同步
> - 一个线程t1 Interrupt 另一个线程t2的活动与检测t2线程被中断的活动同步

在SW关系中，我们称同步的源点的活动为释放动作, 终点的活动为获取动作。由这些带有SW关系的活动，再结合上程序顺序，我们可以得到线程间的基本逻辑顺序要求。


# Happens-Before 和 Happens-Before Order
在前面分析清单4中代码时， 我们使用了一种称为“先于...发生”（Happens-before）的关系(简称为HB关系)来进行讨论。非正式地，一个活动先于另一个活动发生，就是指这个活动的执行的结果将被另一个活动可见。

  

但由于两个活动可能是完全互相独立的，JMM并不要求两个有HB关系的活动的实际执行顺序一定一致；同时在与这两个活动间不存在明确的HB关系的其他活动看来，这两个活动的执行顺序可能会看起来被重排过。

![[HB关系和HB顺序示意.png]]

图2中 绿色箭头表示HB关系。 变量A与B的赋值有HB关系， 但由于它们并不相关，实际执行顺序在JMM中并不要求一定会有A的赋值发生于B之前， 但对于C的赋值就必须要有发生在A, B的赋值之后的保障， 因为它与A, B的赋值有依赖关系（我们先排除掉编译将C的赋值转换为C=3的情况）。   

  

但在另一组与A, B的赋值间没有HB关系的操作来看， 我们是否会允许看到r1=2, 但r2= 0的情况呢？可能我们会认为， r1的赋值在r2之前，如果我们看到了B=2, 那么A一定应该已经被赋值为1， 从而不允许这种情况发生。

  

但实际上，由于r1, r2的赋值操作是无关的，我们会允许它们被重排， 同样A, B的赋值也可能会重排，无论哪一种重排，都可能产生r1=2, r2=0的情况， 这个也是目前的JMM所允许的。

  

在同步顺序的基础上，我们再辅助以下面的一次基本逻辑和规则定义的HB关系，我们将会得到程序在一次执行过程中的所有活动间的一个偏序集：
> - 线程内的每一个活动都发生在依代码顺序排在其后其他活动之前
> - 一个对象的构造函数结束发生在该对象的析构函数开始之前；
> - 如果活动a与活动b同步，则a先于b发生；
> - 一个线程的首活动发生在线程内的其他活动之前， 线程内的其他活动都发生在线程的尾活动之前；
> - HB关系可以传递 （记a先于b发生为 hb(a, b)， 有hb(a,b)且hb(b,c) 则， hb(a,c))

这个偏序集称为HB顺序。我们之所以称这是一个偏序集合，是因为在HB顺序的排序准则中，会允许存在着两个活动间没有明确的顺序指定的情况， 如前面图2中的 A,B,C的赋值与r1, r2的赋值之间就没有明确的HB顺序。

  
在有了HB关系定义之后，我们还有另一个HB一致的概念： 如果对某一变量的读取操作（r）读到了某个对该变量的写操作（w）的结果，那么w既不能在HB关系中排在r之后 (hb(r, w))， 也不能有另一个对该变量的写操作(w')，在HB关系上介于r与w之间（hb(w, w') 且 hb(w', r)。

  

 但是对于与之没有直接HB关系的写操作，是否允许看到，未作定义。JMM要求JVM在运行时提供HB一致的保证， 不得产生违背上述原则的行为。在不违背HB一致要求的前提下，JVM可以使用任意的方式来进行程序的优化。
 
 
 
 




 