- **代码实际执行的顺序称为执行轨迹（Execution Trace)**，一个程序可以有多个，甚至无穷个执行轨迹。  
- *CPU和编译器* 为代码执行增加了很多不确定性（见[[代码重排与乱序执行]]）。 在没有通过显式的同步机制调整的情况下，在多线程环境中， 程序里的每一个具体行为将在时间顺序上交错混杂（**执行轨迹互相交织**）。
- Java语言中的一些行为具有**同步语义**，称为**同步活动（Synchronization Actions)**，提供了对**执行轨迹加以约束的手段**。

# 加锁与解锁
1. JAVA中，每一个*同步方法或同步块*都与一个具体的同步对象关联(同步块关联锁对象，同步方法与this对象或class实例关联)；
2. 进入同步方法或同步块后，JVM对同步对象的 Monitor 有一个锁定动作; 退出同步块时有解锁动作。
3. 锁对象的 wait 操作，是一次释放锁和一次重新获取锁的组合：
	1. 进入 wait() 时释放当前的锁；
	2. 在以未被中断的方式返回时，表明已经重新获取到锁。

## 加锁
- 加锁操作由一个**CAS 操作**与一个**紧接着的内存屏障动作**共同组成；
- CAS 操作：设置锁对象的锁状态；
- 内存屏障将：
	1. 确保加锁前后的数据访问活动**不会出现跨屏障的重排**；
	2. 同时**使缓存失效**以确保后续本线程内的*内存读*都会**得到主存中的最新的状态**。
- 如果当前的锁对象*被其他线程持有*：
	1. CAS 操作未能成功设置锁状态，加锁操作会*将当前线程置于这个锁的等待集上*；
	2. 等待当前锁的所有者释放锁，并被唤醒时再继续尝试。

## 解锁
解锁动作的顺序则刚好相反：
1. **先设置内存屏障**；
2. **再通过 CAS 清除当前锁的持有状态**。
3. 内存屏障同样也有确保：
	1. **不会有跨同步块边界的重排**；
	2. 同时确保**缓存的数据都刷新到主存**。
4. 完成这些动作之后解锁动作将**从等待集中选择一个唤醒**继续操作。

## 改造示例
现在我们尝试用加锁的方式来代码进行一下改造。
```java
class SynchronizeWithLockDemo{
	int a=0;
	boolean b=true;
	Object lock = new Object();
	
	// 在线程1中执行
	void writer(){
	synchronized(lock){  //加锁(1)
			a=10; 
			b=false; 
			lock.notify();
		};  //所有写都将被外部可见 (2)
	}
	
	// 在线程2中执行
	void reader(){
	synchronized(lock){   //加锁，所有的外部操作都可见  (3)
			while(b)  lock.wait(); // 如果b还没有设置，等待 (4) 
			assert(a==10); 
		};
	}   // (5)
}
```

- 之前([[代码重排与乱序执行#影响]])*无法确保 a, b 的写入顺序和在线程 2 中观察到的代码顺序一致*；
- 现在，由于 lock/unlock 动作中分别带有**清空缓存与强制刷新缓存到主存**的逻辑；
- 所以，在语句 2 结束后，一定会观察到 b == true && a == 10 的结果， 无论这两个写是以何种顺序发生。线程2再执行将毫无争议地知道断言将会成功。
- 如果线程2中语句3~5先被执行，在语句4时，进入 wait() 释放出对于锁对象的占用，允许线程1中代码先行完成后，再唤醒线程2，此时b已经被设置，也将得到预期中的断言结果。

[[代码重排与乱序执行#影响]]中的代码实际是有问题的：
1. 其中不存在任何的 lock/unlock 的操作，无法确保在线程2当中，线程1里对标志变量b的修改可以及时地被检测到；
2. 甚至可能会由于编译器的优化，在线程2中对b进行了初次的读取后，完全不再尝试从主内存中获取新的内容而永远不再被检测到。
  
上例当中我们通过加锁与解锁带来缓存清理和内存强制刷新语义解决了这个问题，Java中还提供了另一种方式，将字段申明成为易变(volatile)的 来解决这个问题。

# 易变字段 (volatile field)
**当字段申明中加上了 volatile 关键字后，称这个字段是易变字段**。

易变字段有下面的**语义要求**：
1. **易变字段不得被缓存**；
2. **禁止一切涉及到易变字段的重排**，不仅仅易变字段的访问间不得重排， 易变字段与普通之段的访问间也不得重排。

## 特点
1. 易变字段的每一次读写都是通过内存直接进行；
2. 且不允许与其他的内存操作重排。
3. 易变字段的访问也就有了同步的意味：读写易变字段都是直接操作主存；没有跨越易变字段访问前后的指令与内存访问重排。

## 改造示例
可以把易变字段的访问理解为一种*仅包含对该易变字段访问的简化同步块。*

在这样的保障之下，我们看看对代码的另一种改造方式：

```java
class VolatileDemo{
	int a=0;
	volatile boolean b=true; // 易变字段
	
	// 在线程1中执行
	void writer(){
		a=10;  // 写入a (1)
		b=false; // 写入b (2)
	}
	
	// 在线程2中执行
	void reader(){
		while(b) continue; // 从变量b加载  (3) 
		assert(a==10); // 从变量a加载  (4)
}
```

在上述代码中：
- 语句2,3形成了*事实上的同步关系*， 语句3无论首次执行是发生在语句2之前或之后，都只会在语句2执行完成之后才能完成；
- 而依据*易变字段与普通字段的访问不得重排*的原则，我们知道语句1先于语句2发生，语句3先于语句4发生。 而2， 3之间有同步关系，这样就可以推导出来，*1将会先于4发生*。  
- 这样无论线程1,2以何种顺序先后启动执行，这段程序中的各个行为都有明确的先后顺序。*尽管语句1,4是相互冲突的行为*，但由于有着明确的先后顺序，程序也将得到明确的执行顺序和结果。
 
 
 # 同步活动,同步顺序, ”与同步“(Synchronize-with)
 除开已经提到的[[#加锁与解锁]]、[[#易变字段 volatile field]]的访问之外， 在JMM中还定义了下面的一些同步活动：

> - *线程的首活动（First Action )与尾活动（Last/Final Action)*：它们并不是对应于一条具体的语句，而是对线程的开始与结束中必须进行的一组操作合成而来的一个概念。
> 
> - *启动线程活动与检测线程结束活动*
> 
>-  一个程序的每一次具体的执行中，**所有的同步活动都会形成一个明确的执行先后顺序， 即一个同步活动不会与其他的同步活动同时发生**（或先，或后，但不允许同时发生，即使是在多核的机器上也是如此），称这个顺序为这次执行上的**同步顺序(Synchronization Order)**。
> 
> 同时在一个程序的所有的同步活动的集合上，还存在着一种 **“与同步”(synchronize-with) 的关系** (后续简写为SW关系)，定义如下：
> - 在一个 monitor m 上的解锁动作与在同步顺序上的同一个 monitor 上的后续加锁动作同步
> - 在一个易变字段上的写操作与在同步顺序上同一个字段的后续读操作同步
> - 启动线程活动与被它启动的线程的首活动同步
> - 线程的尾活动与检测该线程结束的活动同步
> - 一个线程 t1 Interrupt 另一个线程 t2 的活动与检测 t2 线程被中断的活动同步

在SW关系中：
1. 同步活动的起点（writing a volatile variable, unlocking a monitor, starting a thread）有*释放语义（release semantics）*：write instruction is guaranteed to flush and write to RAM。
	1. release 前面的写结果操作对后面读可见；
	2. release 前面的操作不能重排序（reorder）到后面。
2. 同步活动的终点（reading a volatile variable, locking a monitor）有*获取语义（acquire semantics）*： read instruction is guaranteed to see any writes cached by any processors。
	1. acquire 后面的读操作能读到前面的写结果；
	2. acquire 后面的操作不能重排序到前面。

由这些带有SW关系的活动，再结合上程序顺序，可以得到线程间的基本逻辑顺序要求。

# Happens-Before 和 Happens-Before Order
还有一种称为“先于...发生”（Happens-before，HB）的关系。
- 非正式地，一个活动先于另一个活动发生，是指这个活动的**执行的结果对另一个活动可见**。
- JMM 并*不要求两个有 HB 关系的活动的实际执行顺序一定与 HB 顺序一致*，因为两个活动可能是完全互相独立的，此时是允许重排的；
- *在与这两个活动间不存在明确的 HB 关系的其他活动看来，这两个活动的执行顺序可能看起来被重排过*。

![[HB关系和HB顺序示意.png]]

1. 上图中绿色箭头表示HB关系。假设所有变量全部初始化为 0 ； 
2. 变量A与B的赋值有HB关系， 但*由于并不相关，实际执行顺序在 JMM 中并不要求A 的赋值一定发生于B之前（允许编译器重排*）；
3. 但 C 的赋值就必须要保证发生在 A, B 的赋值之后， 因为它*与 A, B 的赋值有依赖关系*（排除掉编译将C的赋值转换为C=3的情况）。   

对于下面一条线的 r1 和 r2 而言：
1. 与 A, B的赋值间没有HB关系；
2. 是否会允许看到 r1=2（读取到被赋值后的 B）, 但 r2= 0（读取到A的 初始值） 的情况呢？可能有人会认为， r1 的赋值在 r2 之前，如果看到了B=2, 那么A一定应该已经被赋值为1， 从而不允许这种情况发生。
3. 但实际上，由于 r1, r2 的赋值操作是无关的，JMM 允许它们被重排， 同样A, B 的赋值也可能会重排。无论哪一种重排，都可能产生 r1=2, r2=0的情况， 这个也是目前的 JMM 所允许的。

## Happens-before 顺序
在同步顺序的基础上，再辅助以下面的一些基本逻辑和规则定义的 HB 关系，将会得到程序在一次执行过程中的所有活动间的一个*偏序集*：
> - **Each action** in a thread *happens before*  every **subsequent action** in that thread.  
> - An **unlock on a monitor** *happens before* every **subsequent lock** on that monitor. 
> - A **write to a volatile** field *happens before* every **subsequent read** of that volatile. 
> - A **call to start()** on a thread *happens before* any **actions in the started thread**. 
> - **All actions** in a thread *happen before* any **other thread successfully returns from a join()** on that thread. 
> - If an action a *happens before* an action b, and b happens before an action c, then a happens before c.
这个偏序集称为**HB顺序（Happens-before ordering）**。
- 之所以称这是一个偏序集合，是因为在HB顺序的排序准则中，会允许存在着*两个活动间没有明确的顺序指定*的情况， 如前面图中的 A,B,C的赋值与r1, r2的赋值之间就没有明确的HB顺序。

## Happens-before 一致
*某一变量的读取操作（r）可以读取到对该变量的写操作（w）的结果*，只要:
1. *r 不在 HB 关系中排在 w 之前*；
2. *没有另一个对该变量的写操作(w')，在HB关系上介于 r 与 w 之间*（hb(w, w') 且 hb(w', r))。
3. 但是对于与之没有直接HB关系的写操作，是否允许看到，未作定义。
An execution is *happens-before consistent* if each read sees a write that it is allowed to see by the happens-before ordering.
一个 action 中，*如果每一个读取操作都能看到HB顺序允许其看到的写操作结果*，则该action是 Happens-before 一致的。

> **JMM 要求 JVM 在运行时提供 HB 一致的保证**， 不得产生违背上述原则的行为。
> 在不违背HB一致要求的前提下，JVM 可以使用任意的方式来进行程序的优化。
 
 # 示例
 用一个例子把前面的概念放到一起：
 ```java
class VolatileDemo{
	int a=0;
	int c=0;
	int d=0;
	int e=0;
	volatile boolean b=false; // 易变字段
	
	// 在线程1中执行
	void writer(){
		a=10;  // 写入a (1)
		c=a;
		b=true; // 写入b (2)
	}
	
	// 在线程2中执行
	void reader(){
		d=1;
		e=d;
		while(!b) continue; // 从变量b加载  (3) 
	}
	
	// main
	void static main(String args[]){
		t1.start();
		t2.start();
		t1.join();
		t2.join();
	}
}
```


上例中代码的各个线程内的不同 action 将会产生如下图的**HB关系、同步关系和同步顺序**。
在下图中：
- 红色的箭头为 SW 关系；
- 绿色箭头为 HB 关系。
- 蓝色的结点为同步活动；
- 绿色的是普通的内存操作。

![[同步顺序，sw关系，hb关系示意图.png|640x663]]

## 分析

第一步中，可以看到这三个线程各自的*HB顺序*，其实就是对应线程代码的程序顺序。  
  
第二步中：
- 将所有的同步活动放在了同一水平线上，从左至右的顺序表明了某一种执行轨迹下的所有同步活动的排序，这就是一个*同步顺序*。
- 可以简单地把程序中所有同*步活动理解为必须串行化执行的活动*。两个同步活动间即使没有HB关系存在，*在一次具体的执行中也一定有某一种明确的执行先后顺序*。
- 如 t1 的首操作和启动 t2 的操作间没有明确的 HB关系，但在一个同步顺序中却有明确的 SO顺序排序。

对于*一对存在着SW关系的同步活动结点*，有两条规则：
1. *释放操作一定在前， 获取操作一定在后*；
2. 在同一个线程内的同步活动必须依程序顺序进行排序。

在满足两条规则的前提下，同步活动结点间的顺序在不同的执行轨迹中可以不同。

最后把代码中的非同步活动也引入进来，依据各线程内的HB顺序排进来，就得到了最终的完整的HB顺序图。

 