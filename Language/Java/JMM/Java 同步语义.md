CPU和编译器为代码执行增加了很多不确定性， 在没有通过显式的同步机制调整的情况下，在多线程环境中， 一个程序里的每一个具体行为将在时间顺序上交错混杂。
这种互相交织的代码行为的实际执行顺序称为*执行轨迹（Execution Trace)*，一个程序可以有多个，甚至无穷个执行轨迹。  

在Java语言中，下面的一些行为具有同步语义，称之为同步活动（Synchronization Actions)，他们提供了对**执行轨迹加以约束的手段**。

# 加锁与解锁
在JAVA中，每一个同步方法或同步块都与一个具体的同步对象关联(在同步块上是指定的锁对象，同步方法上则与this对象或class实例关联)，在进入同步方法或同步块后，对同步对象的Monitor有一个锁定动作; 相应地在退出当前同步块时有解锁动作。另外，在锁对象上的wait操作，是一次释放锁和一次重新获取锁的行为的组合：在进入时释放当前的锁，在以未被中断的方式返回的情况下重新获取到锁。

加锁操作由一个设置锁对象上的加锁状态的CAS操作与一个紧接着的内存屏障动作共同组成，这个内存屏障将确保加锁前后的数据访问活动不会出现跨屏障的重排，同时还将使缓存失效以确保后续本线程内的内存读都会得到主存中的最新的状态。如果当前的锁对象被其他线程持有，CAS操作未能成功设置锁状态，加锁操作还会将当前线程置于这个锁的等待集上，等待当前锁的所有者在后续释放锁时被唤醒起来再继续尝试。

解锁动作的顺序则刚好相反，会先设置内存屏障 再通过CAS 清除当前锁的持有状态。这个内存屏障同样也有确保不会有跨同步块边界的重排的作用，同时还会确保缓存的数据都刷新到主存。完成这些动作之后解锁动作将从该锁对象的等待集中选择一个唤醒继续操作。

现在我们尝试用加锁的方式来对清单1中的代码进行一下改造。
```java
class SynchronizeWithLockDemo{
	int a=0;
	boolean b=true;
	Object lock = new Object();
	
	// 在线程1中执行
	void writer(){
	synchronized(lock){  //加锁(1)
			a=10; 
			b=false; 
			lock.notify();
		};  //所有写都将被外部可见 (2)
	}
	
	// 在线程2中执行
	void reader(){
	synchronized(lock){   //加锁，所有的
			while(b)  lock.wait(); //  
			assert(a==10); 
		};
	}
}
```