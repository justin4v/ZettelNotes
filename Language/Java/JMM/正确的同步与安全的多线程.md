尽管 JMM 实现起来相当复杂，而且底层的重新排序问题也常常会令人感到难以理解，不过， 得益于 JMM 对于对于线程与内存模型的交互行为的明确定义，只要我们的程序做到了正确同步，在正确支持了JMM的虚拟机实现上运行，就将是线程安全的。那么什么是正确同步呢？

# 数据竞争(Data Race)和正确同步(Correctly Synchronized)
## Data Race
1. 对于同一变量的两个并行的访问中，如果*至少有一个是写入操作*，称为 **Access Conflict** (![[JMM 相关概念#访问冲突]])。
2. 冲突访问的两个操作之间，如果没有明确的 HB 顺序，在 JMM 定义下的虚拟机中执行时就可能有*任意的顺序，甚至是同时进行*，带来不确定的结果，这就是**数据竞争--Data Race**(![[JMM 相关概念#数据竞争]])。

## Correctly Synchronized
在 JMM中对**正确同步**的定义: 
- 一个程序如果在它**所有的串行一致的执行当中都不存在数据竞争**就是正确同步
- “**A program is correctly synchronized if and only if all sequentially consistent executions are free of data races**”
![[JMM 相关概念#串行一致 Sequential Consistency]]

如果程序没有正确同步，可能出现*三种问题*: 
> 1. **visibility**（[JMM 相关概念#可见性 Visibility]]）
> 2. **ordering**（[[JMM 相关概念#有序性 Ordering]]）
> 3. **atomicity**（[[JMM 相关概念#原子性 Atomicity]]）

### 含义
**正确同步的代码不一定需要包含同步行为**：
只要程序**没有包含冲突的数据访问**就一定是正确同步的。如：
1. 在*线程间不共享数据*的程序；
2. 数据*仅被初始化一次，后续都只包含读操作*的程序。

此外：
1. 如果在线程间共享数据，并且读写会交错进行的情况下， 就需要分析确定是否有数据竞争。给数据访问*添加上合适的同步行为*，把*代码块划分得更小*将会有助于我们化简分析的过程。
2. 通常而言，当程序的**正确执行依赖于一个线程当中独立语句的执行结果，在另一个线程中被观察到的顺序时**，就需要考虑*使用同步行为为程序的执行顺序定下基本的规则以实现正确同步*。

### 示例
例如在 ![[代码重排与乱序执行#^5bb34a]]  中:
1. 字段 a 和 b 在两个线程中各有读写，所以 a,b 是*访问冲突*的。
2. 又因为*没有任何的同步行为来建立合理的 HB 关系*，程序的任何执行轨迹都可能有 a 和 b 上的数据竞争。
3. 因而这个程序*没有被正确同步*。

而后面的的两个基于*加锁解锁*：
![[Java 同步语义#^3ae328]]
和易变字段：
![[Java 同步语义#^8731d6]]

改造版本当中:
1. 通过引入的同步关系而明确了 a,b *在不同线程中的读写操作的HB顺序*；
2. *消除了数据竞争*，从而是*正确同步*的。


# 同时进行的读取和写入访问

- 一些开发人员可能会认为*只需要在写入时进行同步*，因为同步会将新值刷新到主内存中，稍后的读取就可以找到它。
- 但用缓存管理的视角来看待同步时就会发现，这种做法仅保证了写线程将数据及时存入主存，*并不保证读线程不会使用缓存中已经过时的内容*。

为实现正确的同步，*一定需要在读和写场景下均加入同步操作*。
同样的结论也可以基于HB关系分析出来：
1. 如果仅在写时有同步行为，将**并不能在对一个变量的写与后续的读之间建立起来 SW 关系**；
2. 从而导致*读写之间仍然没有明确的 HB 关系*，就会*存在数据竞争而不能正确同步*。


# 操作的原子性问题

- **JMM 保证访问所有 Java 基本类型和引用本身（不是被引用的对象），除了 double 和 long**，都是原子的。
- 虽然单次写入普通的long或double值不是原子性的，但*对 volatile 的 long 和 double 值的访问总是原子*的（因为同步行为的排它性确保了不会在一个易变变量操作中被插入其他的读写）。

## 谬误
由于有了这个保障，有时程序员们会判断：
1. 由于所有的读写都发生在基本类型变量上，操作都是原子性的。
2. 而自身业务对于读写顺序不同带来差异并不敏感。从而认为无需要再引入同步行为。

但正如前面在加锁解锁的代码分析中提到的那样，*很可能语句一直使用过时的缓存*，导致后续程序没有正确同步。
出现这个问题的原因是忽略了：
1. *同步器对于程序执行顺序的保证作用*；
2. *cpu 和编译优化对于指令重排的影响程度*。

# 因果率（Causality）要求

因果率是 JMM 的规范定义当中最为晦涩和难于理解的部分（好在它不是为普通程序员们设计）。
1. JMM 总体上是一种**基于HB一致性的内存模型**；
2. 但是在某些情况下，仅有HB一致性的保障，可能会带来一些称为**无源结果**的问题（**Out-Of-Thin-Air,凭空产生**），其产生原因主要**源自于现代计算机系统可能出现的由预测执行带来的“自我证实”问题**。

## 示例
如下面的这个JLS（Java Language Specification）中列出的例子：

```java
// 初始化 r1=r2=x=y=0
// Thread 1
r1=x;
if(r1!=0) y=1; //(1)

// Thread 2
r2=y;
if(r2!=0) x=1; //(2)

// 是否允许 r1=r2=1?
// 答案是：不允许
```

1. 如果以*串行一致*的方式来执行这份代码，*语句1, 2都决不会发生，不会有数据冲突*，从而它明显是正确同步的;
2. 这是一个*没有任何的同步语义，仍然正确同步*的例子。

### 预测执行
然而：
- 在一种可能会**预测执行**的方式（事实上目前应该没有会有这种做法的架构，但JLS做了预防性处理以确保之后也不会有类似的可能发生）下，*可能尝试提前 y =1, x = 1 的数据写入*；
- 当执行到条件判断（1和2 中的 if 判断）时，*再依据条件来判断是否要废弃对应的写入*。

在这种情况下，就可能会有下面演示的执行顺序：
![[预测执行的实例.png]]

由于代码是正确同步的，允许的行为必须是顺序一致的行为。很明显这里的结果是需要被禁止的，。
然而，上图中演示的执行顺序仍然是HB一致的：
1. 每一个线程内的两次写操作本身是无关的而允许重排的；
2. 而r1=x的行为与thread2中的x = 1行为间也没有明确的HB关系，读到x=1的写入也不违背HB一致的要求 。

从而将可能发生。

## 自我证实
如果上述的重排得以发生，将导致原本不可能达成的r1 >０和r2 > 0的条件成真，导致在*指令流水中预先执行的行为不会被取消*。

换句话讲， *因为猜测稍后可能会把x 设置成1， y设置成1，而导致认为有必要把 x 设置成1， y设置成1*。这是一条“**自我证实**”的假定，很明显是不应该被许可的。

  
- 一个好消息是  *JMM 的规范要求 JVM 保证不会有不顺序一致的行为*。
- 这需要JVM的实现者们除了在保证执行顺序HB一致之外，额外进行一些判定，以确定是否允许按某个未被HB关系所禁止的内存操作顺序进行提交。
- 一个非正式的规则是：**不允许重排后的操作顺序带来了额外的数据冲突条件**。上例中的重排，使得一个原本没有数据冲突的场景产生了发生在x 和y上的数据竞争，所以这个结果是无法接受的，对于JMM而言是非法的 。


# Final 字段语义与安全构造
JMM 的另一个重要部分是关于Final字段的语义保障的。当前对Final 字段的保障如下：
- 当一个对象的构造函数完成后，一个对象被认为已经被完全初始化。
- 在对象完全初始化后，仅能通过对象的引用来访问该对象的线程将可以保证正确地看到对象的 final 字段的初始化后的值。
- 注意：
	- 如果*对象的引用在对象完全初始化之前被泄漏到其他线程*中，
	- 或*一个线程被允许以反射等常规方式访问对象*时，JLS并不保证读取 final 字段时一定会读到预期中的初始化后的值， *可能会看到字段的默认初始值*。

  

另一个需要注意的问题是，如果在构造函数中包含着对于普通字段的初始化，即使该对象已经完全初始化，仅通过引用访问该对象的线程中也不必一定可以看到这些普通字段被初始化的值 （虽然实际情况中并不一定会有这类状况，但由于在对象构造函数结束时没有内存屏障的存在，JMM并不保证其他线程一定看到构造函数中向各普通字段写入的值）。

  

为了对象的安全构造和使用， 我们需要注意确保在构造函数未完成之前，不得以任意方式将当前构造的对象引用发布到其他线程可见的环境中，如下面的几个例子将极不可取。