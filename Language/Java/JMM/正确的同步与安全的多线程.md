尽管JMM实现起来相当复杂，而且底层的重新排序问题也常常会令人感到难以理解，不过， 得益于 JMM 对于对于线程与内存模型的交互行为的明确定义，只要我们的程序做到了正确同步，在正确支持了JMM的虚拟机实现上运行，就将是线程安全的。那么什么是正确同步呢？

# 数据竞争(Data Race)和正确同步(Correctly Synchronized)
## Data Race
1. 对于同一变量的两个并行的访问中，如果*至少有一个是写入操作*，称为 **Access Conflict** (![[JMM 相关概念#访问冲突]])。
2. 冲突访问的两个操作之间，如果没有明确的 HB 顺序，在 JMM 定义下的虚拟机中执行时就可能有*任意的顺序，甚至是同时进行*，带来不确定的结果，这就是**数据竞争--Data Race**(![[JMM 相关概念#数据竞争]])。

## Correctly Synchronized
在 JMM中对**正确同步**的定义: 
“**A program is correctly synchronized if and only if all sequentially consistent executions are free of data races**”，一个程序如果在它**所有的串行一致的执行当中都不存在数据竞争**就是正确同步。

If a program is not correctly synchronized, then three types of problems can appear: **visibility, ordering and atomicity.**

### 含义
**正确同步的代码不一定需要包含同步行为**：
只要程序**没有包含冲突的数据访问**就一定是正确同步的。如：
1. 在*线程间不共享数据*的程序；
2. 数据*仅被初始化一次，后续都只包含读操作*的程序。

此外：
1. 如果在线程间共享数据，并且读写会交错进行的情况下， 就需要分析确定是否有数据竞争。给数据访问*添加上合适的同步行为*，把*代码块划分得更小*将会有助于我们化简分析的过程。
2. 通常而言，当程序的**正确执行依赖于一个线程当中独立语句的执行结果，在另一个线程中被观察到的顺序时**，就需要考虑*使用同步行为为程序的执行顺序定下基本的规则以实现正确同步*。

### 示例
例如在 ![[代码重排与乱序执行#^5bb34a]]  中:
1. 字段 a 和 b 在两个线程中各有读写，所以 a,b 是*访问冲突*的。
2. 又因为*没有任何的同步行为来建立合理的 HB 关系*，程序的任何执行轨迹都可能有 a 和 b 上的数据竞争。
3. 因而这个程序*没有被正确同步*。

而后面的的两个基于*加锁解锁*：
![[Java 同步语义#^3ae328]]
和易变字段：
![[Java 同步语义#^8731d6]]

改造版本当中:
1. 通过引入的同步关系而明确了 a,b *在不同线程中的读写操作的HB顺序*；
2. *消除了数据竞争*，从而是*正确同步*的。


## 同时进行的读取和写入访问

- 一些开发人员可能会认为*只需要在写入时进行同步*，因为同步会将新值刷新到主内存中，稍后的读取就可以找到它。
- 但用缓存管理的视角来看待同步时就会发现，这种做法仅保证了写线程将数据及时存入主存，*并不保证读线程不会使用缓存中已经过时的内容*。

为实现正确的同步，*一定需要在读和写场景下均加入同步操作*。
同样的结论也可以基于HB关系分析出来：
1. 如果仅在写时有同步行为，将**并不能在对一个变量的写与后续的读之间建立起来 SW 关系**；
2. 从而导致*读写之间仍然没有明确的 HB 关系*，就会*存在数据竞争而不能正确同步*。