尽管JMM实现起来相当复杂，而且底层的重新排序问题也常常会令人感到难以理解，不过， 得益于 JMM 对于对于线程与内存模型的交互行为的明确定义，只要我们的程序做到了正确同步，在正确支持了JMM的虚拟机实现上运行，就将是线程安全的。那么什么是正确同步呢？

# 数据竞争(Data Race)和正确同步(Correctly Synchronized)
## Data Race
1. 对于同一变量的两个并行的访问中，如果*至少有一个是写入操作*，称为 **Access Conflict** (![[JMM 相关概念#访问冲突]])。
2. 冲突访问的两个操作之间，如果没有明确的 HB 顺序，在 JMM 定义下的虚拟机中执行时就可能有*任意的顺序，甚至是同时进行*，带来不确定的结果，这就是**数据竞争--Data Race**(![[JMM 相关概念#数据竞争]])。

## Correctly Synchronized
在 JMM中对**正确同步**的定义: 
- 一个程序如果在它**所有的串行一致的执行当中都不存在数据竞争**就是正确同步
- “**A program is correctly synchronized if and only if all sequentially consistent executions are free of data races**”
![[JMM 相关概念#串行一致 Sequential Consistency]]

如果程序没有正确同步，可能出现*三种问题*: 
> 1. **visibility**（[JMM 相关概念#可见性 Visibility]]）
> 2. **ordering**（[[JMM 相关概念#有序性 Ordering]]）
> 3. **atomicity**（[[JMM 相关概念#原子性 Atomicity]]）

### 含义
**正确同步的代码不一定需要包含同步行为**：
只要程序**没有包含冲突的数据访问**就一定是正确同步的。如：
1. 在*线程间不共享数据*的程序；
2. 数据*仅被初始化一次，后续都只包含读操作*的程序。

此外：
1. 如果在线程间共享数据，并且读写会交错进行的情况下， 就需要分析确定是否有数据竞争。给数据访问*添加上合适的同步行为*，把*代码块划分得更小*将会有助于我们化简分析的过程。
2. 通常而言，当程序的**正确执行依赖于一个线程当中独立语句的执行结果，在另一个线程中被观察到的顺序时**，就需要考虑*使用同步行为为程序的执行顺序定下基本的规则以实现正确同步*。

### 示例
例如在 ![[代码重排与乱序执行#^5bb34a]]  中:
1. 字段 a 和 b 在两个线程中各有读写，所以 a,b 是*访问冲突*的。
2. 又因为*没有任何的同步行为来建立合理的 HB 关系*，程序的任何执行轨迹都可能有 a 和 b 上的数据竞争。
3. 因而这个程序*没有被正确同步*。

而后面的的两个基于*加锁解锁*：
![[Java 同步语义#^3ae328]]
和易变字段：
![[Java 同步语义#^8731d6]]

改造版本当中:
1. 通过引入的同步关系而明确了 a,b *在不同线程中的读写操作的HB顺序*；
2. *消除了数据竞争*，从而是*正确同步*的。


## 同时进行的读取和写入访问

- 一些开发人员可能会认为*只需要在写入时进行同步*，因为同步会将新值刷新到主内存中，稍后的读取就可以找到它。
- 但用缓存管理的视角来看待同步时就会发现，这种做法仅保证了写线程将数据及时存入主存，*并不保证读线程不会使用缓存中已经过时的内容*。

为实现正确的同步，*一定需要在读和写场景下均加入同步操作*。
同样的结论也可以基于HB关系分析出来：
1. 如果仅在写时有同步行为，将**并不能在对一个变量的写与后续的读之间建立起来 SW 关系**；
2. 从而导致*读写之间仍然没有明确的 HB 关系*，就会*存在数据竞争而不能正确同步*。


## 操作的原子性问题

- **JMM 保证访问所有 Java 基本类型和引用本身（不是被引用的对象），除了 double 和 long**，都是原子的。
- 虽然单次写入普通的long或double值不是原子性的，但*对 volatile 的 long 和 double 值的访问总是原子*的（因为同步行为的排它性确保了不会在一个易变变量操作中被插入其他的读写）。

### 谬误
由于有了这个保障，有时程序员们会判断：
1. 由于所有的读写都发生在基本类型变量上，操作都是原子性的。
2. 而自身业务对于读写顺序不同带来差异并不敏感。从而认为无需要再引入同步行为。

但正如前面在加锁解锁的代码分析中提到的那样，很可能语句永远使用一个过时的缓存，导致后续程序。在这里他们忽略了同步器对于程序执行顺序的保证作用，也忽略了cpu和编译优化对于指令转换重排的影响程度。