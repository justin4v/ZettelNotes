尽管JMM实现起来相当复杂，而且底层的重新排序问题也常常会令人感到难以理解，不过， 得益于 JMM 对于对于线程与内存模型的交互行为的明确定义，只要我们的程序做到了正确同步，在正确支持了JMM的虚拟机实现上运行，就将是线程安全的。那么什么是正确同步呢？

# 数据竞争(Data Race)和正确同步(Correctly Synchronized)
## Data Race
1. 对于同一变量的两个并行的访问中，如果*至少有一个是写入操作*，称为 **Access Conflict** ([[相关概念#冲突访问]])。
2. 冲突访问的两个操作之间，如果没有明确的 HB 顺序，在 JMM 定义下的虚拟机中执行时就可能有*任意的顺序，甚至是同时进行*，带来不确定的结果，这就是**数据竞争--Data Race**([[相关概念#Data Race]])。

## Correctly Synchronized
在 JMM中对**正确同步**的定义: 
“**A program is correctly synchronized if and only if all sequentially consistent executions are free of data races**”，一个程序如果在它**所有的串行一致的执行当中都不存在数据竞争**就是正确同步。

If a program is not correctly synchronized, then three types of problems can appear: **visibility, ordering and atomicity.**

### 含义
**正确同步的代码不一定需要包含同步行为**：
只要程序**没有包含冲突的数据访问**就一定是正确同步的。如：
1. 在*线程间不共享数据*的程序；
2. 数据*仅被初始化一次，后续都只包含读操作*的程序。


如果在线程间共享数据，并且读写会交错进行的情况下， 就需要分析确定是否有数据竞争。

给数据的访问添加上合适的同步行为把代码块划分得更小将会有助于我们化简分析的过程。

通常而言，当程序的正确执行依赖于在一个线程当中互相独立的语句的执行结果在另一个线程中被观察到的顺序时，我们就需要考虑使用同步行为来为程序的执行顺序定下基本的规则以实现正确同步。

例如我们在代码1中，字段a和b在两个线程中各有读写，所以a,b的访问操作是冲突的。又因为没有任何的同步行为来建立合理的HB关系，程序的任何执行轨迹都可能有a和b上的数据竞争。因而这个程序是没有被正确同步的。

而在后面的的两个分别基于加锁解锁和易变字段的改造版本当中，都通过引入的同步关系而明确了a,b变量在不同线程中的读写操作的HB顺序，消除了数据竞争，从而是正确同步的。


**4.2同时进行的读取和写入访问**

一些开发人员可能会认为他们只需要在写入时进行同步，因为同步会将新值刷新到主内存中，稍后的读取就可以一定找到它。但当我们用缓存管理的视角来看待同步时就会发现，这种做法仅保证了写线程将数据及时存入主存，并不保证读线程不会使用缓存中已经过时的内容。

  

为实现正确的同步，一定需要在读和写场景下均加入同步操作。 同样的结论也 可以基于HB关系分析出来：如果仅在写时有同步行为，将并不能在对一个变量的写数据与后续的对应读取之间建立起来SW关系，从而导致读写之间仍然没有明确的HB关系，就一定会存在数据竞争而不能正确同步。