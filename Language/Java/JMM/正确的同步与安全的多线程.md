#Thread-safe 
尽管 JMM 实现起来相当复杂，而且底层的重新排序问题也常常会令人感到难以理解。
不过， 得益于 *JMM 对于线程与内存模型的交互行为的明确定义*，只要*程序做到了正确同步，在正确支持了JMM的虚拟机实现上运行，就是线程安全的*。

那么什么是正确同步呢？

# 数据竞争(Data Race)和正确同步(Correctly Synchronized)
## Data Race
1. 对于同一变量的两个并行的访问中，如果*至少有一个是写入操作*，称为 **Access Conflict** (![[JMM 相关概念#访问冲突]])。
2. 冲突访问的两个操作之间，如果没有明确的 HB 顺序，在 JMM 定义下的虚拟机中执行时就可能有*任意的顺序，甚至是同时进行*，带来不确定的结果，这就是**数据竞争--Data Race**(![[JMM 相关概念#数据竞争]])。

## Correctly Synchronized
在 JMM中对**正确同步**的定义: 
- 一个程序如果在它**所有的串行一致的执行当中都不存在数据竞争**就是正确同步
- “**A program is correctly synchronized if and only if all sequentially consistent executions are free of data races**”
![[JMM 相关概念#串行一致 Sequential Consistency]]

如果程序没有正确同步，可能出现*三种问题*: 
> 1. **visibility**（[[JMM 相关概念#可见性 Visibility|可见性]]）
> 2. **ordering**（[[JMM 相关概念#有序性 Ordering|有序性]]）
> 3. **atomicity**（[[JMM 相关概念#原子性 Atomicity|原子性]]）

### 含义
**正确同步的代码不一定需要包含同步行为**：
只要程序**没有包含冲突的数据访问**就一定是正确同步的。如：
1. 在*线程间不共享数据*的程序；
2. 数据*仅被初始化一次，后续都只包含读操作*的程序。

此外：
1. 如果在线程间共享数据，并且读写会交错进行的情况下， 就需要分析确定是否有数据竞争。给数据访问*添加上合适的同步行为*，把*代码块划分得更小*将会有助于我们化简分析的过程。
2. 通常而言，当程序的**正确执行依赖于一个线程当中独立语句的执行结果，在另一个线程中被观察到的顺序时**，就需要考虑*使用同步行为为程序的执行顺序定下基本的规则以实现正确同步*。

### 示例
例如在 ![[代码重排与乱序执行#^405e58]]  中:
1. 字段 a 和 b 在两个线程中各有读写，所以 a,b 是*访问冲突*的。
2. 又因为*没有任何的同步行为来建立合理的 HB 关系*，程序的任何执行轨迹都可能有 a 和 b 上的数据竞争。
3. 因而这个程序*没有被正确同步*。

而后面的的两个基于*加锁解锁*：
![[Java 同步语义#^3ae328]]
和易变字段：
![[Java 同步语义#^8731d6]]

改造版本当中:
1. 通过引入的同步关系而明确了 a,b *在不同线程中的读写操作的HB顺序*；
2. *消除了数据竞争*，从而是*正确同步*的。


# 同时进行的读取和写入访问

- 一些开发人员可能会认为*只需要在写入时进行同步*，因为同步会将新值刷新到主内存中，稍后的读取就可以找到它。
- 但用缓存管理的视角来看待同步时就会发现，这种做法仅保证了写线程将数据及时存入主存，*并不保证读线程不会使用缓存中已经过时的内容*。

为实现正确的同步，*一定需要在读和写场景下均加入同步操作*。
同样的结论也可以基于HB关系分析出来：
1. 如果仅在写时有同步行为，将**并不能在对一个变量的写与后续的读之间建立起来 SW 关系**；
2. 从而导致*读写之间仍然没有明确的 HB 关系*，就会*存在数据竞争而不能正确同步*。


# 操作的原子性问题

- **JMM 保证访问所有 Java 基本类型和引用本身（不是被引用的对象），除了 double 和 long**，都是原子的。
- 虽然单次写入普通的long或double值不是原子性的，但*对 volatile 的 long 和 double 值的访问总是原子*的（因为同步行为的排它性确保了不会在一个易变变量操作中被插入其他的读写）。

## 谬误
由于有了这个保障，有时程序员们会判断：
1. 由于所有的读写都发生在基本类型变量上，操作都是原子性的。
2. 而自身业务对于读写顺序不同带来差异并不敏感。从而认为无需要再引入同步行为。

但正如前面在加锁解锁的代码分析中提到的那样，*很可能语句一直使用过时的缓存*，导致后续程序没有正确同步。
出现这个问题的原因是忽略了：
1. *同步器对于程序执行顺序的保证作用*；
2. *cpu 和编译优化对于指令重排的影响程度*。

# 因果率（Causality）要求

因果率是 JMM 的规范定义当中最为晦涩和难于理解的部分（好在它不是为普通程序员们设计）。
1. JMM 总体上是一种**基于HB一致性的内存模型**；
2. 但是在某些情况下，仅有HB一致性的保障，可能会带来一些称为**无源结果**的问题（**Out-Of-Thin-Air,凭空产生**），其产生原因主要**源自于现代计算机系统可能出现的由预测执行带来的“自我证实”问题**。

## 示例
如下面的这个JLS（Java Language Specification）中列出的例子：

```java
// 初始化 r1=r2=x=y=0
// Thread 1
r1=x;
if(r1!=0) y=1; //(1)

// Thread 2
r2=y;
if(r2!=0) x=1; //(2)

// 是否允许 r1=r2=1?
// 答案是：不允许
```

1. 如果以*串行一致*的方式来执行这份代码，*语句1, 2都决不会发生，不会有数据冲突*，从而它明显是正确同步的;
2. 这是一个*没有任何的同步语义，仍然正确同步*的例子。

### 预测执行
然而：
- 在一种可能会**预测执行**的方式（事实上目前应该没有会有这种做法的架构，但JLS做了预防性处理以确保之后也不会有类似的可能发生）下，*可能尝试提前 y =1, x = 1 的数据写入*；
- 当执行到条件判断（1和2 中的 if 判断）时，*再依据条件来判断是否要废弃对应的写入*。

在这种情况下，就可能会有下面演示的执行顺序：
![[预测执行的实例.png]]

由于代码是正确同步的，允许的行为必须是顺序一致的行为。很明显这里的结果是需要被禁止的，。
然而，上图中演示的执行顺序仍然是HB一致的：
1. 每一个线程内的两次写操作本身是无关的而允许重排的；
2. 而r1=x的行为与thread2中的x = 1行为间也没有明确的HB关系，读到x=1的写入也不违背HB一致的要求 。

从而将可能发生。

## 自我证实
如果上述的重排得以发生，将导致原本不可能达成的r1 >０和r2 > 0的条件成真，导致在*指令流水中预先执行的行为不会被取消*。

换句话讲， *因为猜测稍后可能会把x 设置成1， y设置成1，而导致认为有必要把 x 设置成1， y设置成1*。这是一条“**自我证实**”的假定，很明显是不应该被许可的。

  
- 一个好消息是  *JMM 的规范要求 JVM 保证不会有不顺序一致的行为*。
- 这需要JVM的实现者们除了在保证执行顺序HB一致之外，额外进行一些判定，以确定是否允许按某个未被HB关系所禁止的内存操作顺序进行提交。
- 一个非正式的规则是：**不允许重排后的操作顺序带来了额外的数据冲突条件**。上例中的重排，使得一个原本没有数据冲突的场景产生了发生在x 和y上的数据竞争，所以这个结果是无法接受的，对于JMM而言是非法的 。


# Final 字段语义与安全构造
JMM 的另一个重要部分是关于 Final 字段的语义保障。当前对Final 字段的保障如下：
- 当一个对象的**构造函数完成后，对象被认为已经完全初始化**。
- 在对象完全初始化后，*能通过对象的引用来访问该对象的线程*将可以保证**正确地看到对象的 final 字段的初始化后的值**。


## 注意
- 如果*对象的引用在对象完全初始化之前被泄漏到其他线程*中；
- 或*一个线程被允许以反射等常规方式访问对象*时，JLS并不保证读取 final 字段时一定会读到预期中的初始化后的值， *可能会看到字段的默认初始值*。
- 此外，如果在构造函数中包含着*普通字段的初始化*，即使对象已经完全初始化，仅通过引用访问该对象的线程中也*不一定可以看到普通字段初始化后的值*。 
- 虽然实际情况中一般不会看不到，但由于在对象构造函数结束时*没有内存屏障*，*JMM 并不保证其他线程一定看到构造函数中向各普通字段写入的值*。
- 为了对象的安全构造和使用， 需要注意确保在**构造函数完成之前，不得以任何方式将当前构造的对象引用发布到其他线程可见的环境中**。

对于*预期会在构造函数中进行初始化的成员*：
1. 将其**声明成为Final字段**；
2. 在后续的使用中不假定对应字段已经完成了初始化，**用同步的方式对其访问进行保护**。

## 错误示例
如下面的几个例子将极不可取。
```java
class UnsafeConstruct{
	static UnsafeConstruct instance;
	final int someFinal;
	
	UnsafeConstruct(){
		someFinal=1;
		// instance = this;  // 错误1, 对象引用设置到 static field上，初始化完成前被赋值到 static field
		// registerAsHandler(this); // 错误2，发布到注册表/回调函数中
		// new WorkerThread(this).start(); // 错误3，作为其他线程启动参数
	}
	
	static initInstance(){
		instance=new UnsafeConstruct();
		registerAsHander(instance);
	}
}
```



# 线程安全的其他思路
## JMM
1. JMM 本质上是一种**基于共享内存和加锁的线程间协作交互模型**；
2. JMM 是*对传统的经典计算机体系架构的一个模拟*； 
3. JMM 作为第一个在语言层面被定义且广泛接受的内存模型， 在已经过去的年代里面取得了相当的成功。

## 其他范式
- 伴随着越来越多的并行计算需求，多核， SIMD指令体系等的更多应用，在并行程序开发中越来越要求能*更多地发掘和利用程序内在的并行性*。 

- 但在基于共享内存与加锁的体系下，线程间共享的数据越多，对于正确同步的要求会引入更多的同步行为，*限制编译器与CPU发掘程序的内在并行性的可能*，不利于提高程序的并发性能。
- 因而现在大家更多地把并行程序设计的思路转向*用不同的并行程序设计的范式*以求用不同的思路来解决线程安全问题：
	1. 一种方式是利用*基于函数式的程序设计*，从而*利用代码的重入性保证不会在不同线程间共享内容*；
	2. 另一种方式是秉承以”*sharing with communication*"的思想，从而*减少在共享信息过程中对于锁的依赖*，如基于*Actor Model* 的设计，*将处理过程与待对理对象进行绑定*，避免同时大量的不同处理过程需要同时处理同一对象的场景，从而实现无锁的高效处理。

# 总结
1. JMM *描述了什么样的执行轨迹是被许可的*， 核心是**确保正确同步的线程都能得到预期中的执行结果**。  
2. 正确同步的程序**要确保在串行一致的代码执行中不发生数据竞争**。
	1. 如果有某些数据操作是冲突的，需要*通过同步机制为冲突的数据操作间建立起来恰当的HB关系*，以避免数据竞争。
	2. 使用同步机制时需要注意必须*同时为读与写操作都加上同步机制*才可以保障行为的正确性。
3. 使*用 final 字段来定义不可变的对象是另一种实现线程安全的重要手段*，但必须要正确初始化后 final 语义才能得到保障。
	1. 如果 final 字段所在*对象没有初始化完就暴露给了其他线程*；
	2. 或是*通过非常规手段（如反射）访问该对象*时，final 语义将得不到保障。
	3. 另外，从*构造函数返回之后， 对于非 final 字段的初始化未必已经完成*。



# 参考
1. Wikipedia上的 [Out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution) 页，从此处出发有更多可用链接可供全面了解计算机领域中的乱序执行问题。
2. [内存屏障](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf)
3. [Threads and Locks (oracle.com)](https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html) , 这是目前的JMM官方描述的最新版本（虽然和JDK1.8中并无可见差异）
4. [SR133（Java内存模型）](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf) 最终版本文档，与JLS进行一些交叉对比，可为某些不易理解的部分提供另外的理解思路。
5. William Pugh(Bill Pugh)， JSR133 Spec Leader 的 [Java Memory Modal FAQ](http://www.cs.umd.edu/~pugh/java/memoryModel/)  页面, 如果需要了解现在的JMM为什么是这样，这是最值得推荐的一个入口 
6. Doug Lea 的JSR 133 Cookbook，从实现者实角度对于JSR133的理解
7. Aleksey Shipilёv 的 [JMM Presentation](https://shipilev.net/blog/2014/jmm-pragmatics/)
8. [JEP 188](http://openjdk.java.net/jeps/188), 对于JSR133的改进信息入口，主要价值在于给出了改进的动因和到有具体的mail list链接。
9. [并发之痛](https://my.oschina.net/tjt/blog/906204 )，一篇较有深度关于并发的综述性文章，虽然语言并非java, 但仍有借鉴价值
10. [Actor Model](https://en.wikipedia.org/wiki/Actor_model)
11. [Actor in Akka](https://doc.akka.io/docs/akka/2.5/index-actors.html)