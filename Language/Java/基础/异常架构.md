#Exception #Error #Java基础 #Todo 


# 简介
- 异常是程序运行时，发生的**不被期望的事件**，它*阻止了程序按照开发人员预期正常执行*。
- 异常发生时，如何处理？
	1. 任程序自生自灭，*立刻退出终止*；
	2. 还是*输出错误*给用户；
	3. 用函数返回值*标记执行状态*，以便继续向下执行。

## Java 的解决办法
- Java 提供了*异常处理机制*用于处理异常。
- 异常处理机制能让程序在异常发生时，按照代码的*预先设定的异常处理逻辑，针对性地处理异常*；
- 让程序*尽最大可能恢复正常并继续执行*，且保持代码的清晰。
- Java中的异常：
	1. 语句执行时引发的；
	2. 程序员通过throw 语句手动抛出的；
	3. 程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE 就会试图寻找异常处理程序来处理异常。
# Java 异常架构
- Java 标准*内建了一些通用异常*，以 **Throwable 为顶层父类**。
- *Throwable* 又派生出 *Error* 和 *Exception* 。

## Error 错误
- Error 及其子类；
- 代表了 **JVM 本身的错误**，错误不能被程序员通过代码处理；
- Error 很少出现，程序员应该关注 Exception 为父类的分支下的各种异常类。

## Exception 异常
- Exception 及其子类；
- 代表*程序运行时*发生的各种不期望发生的事件。
- 可以被 Java 异常处理机制使用，是异常处理的核心。

![[Java异常架构示意.png]]


根据Javac对异常的处理要求，将异常类分为2类。

## unchecked exception
- **非检查异常（unckecked exception）**，*不需要做显示检查*：*Error 和 RuntimeException 及其子类*。
- 一般是*代码编写*的造成的问题，可以避免；
- javac 在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。
- 可以编写代码处理（try...catch...finally），也可以不处理。

### 处理策略
- **应该修正代码**，而不是通过异常处理器处理 。
- unchecked exception 异常多半是代码的问题。
- 如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。

## checked exception
- **检查异常（checked exception）**，需要显示检查：直接继承 Exception 为 checked Exception，除了 *Error* 和 *RuntimeException* 的其它异常。
- **javac 强制要求为检查异常做处理工作**（使用try...catch...finally或者throws）。
- 在方法中要么用 try-catch 语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。
- 一般是由程序的*运行环境导致的*。
- 因为程序可能被运行在各种未知的环境下，而无法干预用户如何使用程序，于是程序员应该为这样的异常时刻准备着。
- 如*SQLException , IOException,ClassNotFoundException* 等。


# 异常处理
## 异常控制流
- java 中，异常处理*将执行控制流从异常发生的位置转移到能够处理这种异常的位置*。
- 当一个语句发生异常时，这条语句的后面的语句不会再执行，失去了焦点。
- 执行流跳转到最近的匹配的异常处理 catch 代码块去执行，**异常被处理完后，执行流会在“处理了这个异常的catch代码块”后面接着执行**。

### 恢复式异常处理模式
- 当异常被处理后，*控制流会恢复到异常抛出点接着执行*；
- 策略叫做：**resumption model of exception handling**（**恢复式异常处理模式** ）

### 终结式异常处理模式
- Java则是让执行流*恢复到处理了异常的catch块后接着执行*；
- 策略叫做：**termination model of exception handling**（**终结式异常处理模式**）
## try...catch...finally
```java
try{
     //try块中放可能发生异常的代码。     
     //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。     
     //如果发生异常，则尝试去匹配catch块。

}catch(SQLException SQLexception){
    //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。
    //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。
    //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。
    //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。    
    //如果try中没有发生异常，则所有的catch块将被忽略。
}catch(Exception exception){
    //...
}finally{
       //finally块通常是可选的。   
       //无论异常是否发生，异常是否匹配被处理，finally都会执行。
       //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。
       //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 
}
```
- 每一个 catch 块用于处理一个异常。
- 异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。
- 支持父类匹配，如果同一个 try 块下的多个 catch异 常类型有父子关系，应该*将子类异常放在父类异常前面*，保证每个catch块都有存在的意义。


# 参考
1. [Java中的异常和处理详解](https://www.cnblogs.com/lulipro/p/7504267.html)