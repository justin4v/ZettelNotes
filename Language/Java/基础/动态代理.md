#Proxy 
# 需求
现有类：
```java
// 接口
interface IHelloWorld{
    String sayHello(String str);
}
// 实现
class HelloWorldImp implements IHello{
    @Override
    public String sayHello(String str) {
        return "HelloImp: " + str;
    }
}
```

- *动态（运行时）的为 HelloWorldImp Class 增减功能*（如增加日志输出）；
- 但Java 规范*不允许运行时修改 .class 文件*（python，ruby等动态语言可以）。

## 解决
运行时**生成新的类**：
1. *实现接口（JDK 动态代理）*；
2. *继承类（CGLib 动态代理）*；


# 静态代理
- 新增一个 `IHello` 的实现类，增加日志输出功能；

```java
// 静态代理方式
class StaticProxiedHello implements IHelloWorld{
    ...
    private IHelloWorld hello = new HelloWorldImpl();
    @Override
    public String sayHello(String str) {
		//增加日志输出
        logger.startLog();
        return hello.sayHello(str);
		logger.endLog();
    }
}
```

# 动态代理
## JDK 动态代理
- 在原有类（*HelloWorldImp*）之外，实现同样的接口重新生成类。

1. 首先实现一个 InvocationHandler，方法调用会转发到 handler 的 invoke() 方法。
```java
// Java Proxy
class LoggerHandler implements InvocationHandler{
    ...
    private IHelloWorld hello;
    public LoggerHandler(IHelloWorld hello) {
        this.hello = hello;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if("sayHello".equals(method.getName())) {
            logger.info("You said: " + Arrays.toString(args));
        }
        return method.invoke(hello, args);
    }
}
```

2. 使用时，通过 JDK 动态代理获取 Hello 的代理对象。
```java
Hello hello = (Hello)Proxy.newProxyInstance(
    new HelloWorldImpl().getClass().getClassLoader(),  // 1. 被代理类加载器
    new Class<?>[] {IHelloWorld.class}, // 2. 代理类需要实现的接口，可以有多个
    new LogInvocationHandler(new HelloWorldImpl()));// 3. 方法调用的实际处理者
System.out.println(hello.sayHello("I love you!"));
```

### 原码
生成的代理类示意：
```java
//Proxy0 是动态生成的类，继承自Proxy，实现了IProvider接口
public final class $Proxy0 extends Proxy implements IProvider {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String getData(String var1) throws  {
        try {
            //m3就是 HelloWorld 接口的 sayHello 方法 
            //super.h 是父类java.lang.reflect.Proxy的属性 InvocationHandler
            return (String)super.h.invoke(this, m3, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
            //m3就是 HelloWorld 接口的 sayHello 方法
            m3 = Class.forName("demo.HelloWorld").getMethod("sayHello", new Class[]{Class.forName("java.lang.String")});
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

### 关系示意
![[JDK动态代理示意.png]]

- `$HelloWorld100` 是生成的代理类;
- `LoggerHandler` 对方法进行拦截，与代理类解耦，可被复用。

### 特点
- **只能代理接口**


## CGLib 动态代理
### 原理
- *继承原有类（HelloWorldImp）*
- 利用 ASM 操作字节码生成新类；

### 使用
```java
//创建一个增强器，运行时生成类
Enhancer eh = new Enhancer();
//设置要继承的目标类
eh.setSuperClass(HelloWorld.class);
//设置Interceptor
eh.setCallback(new LogInterceptor());
//生成代理类
HelloWorld hw = (HelloWorld) eh.create();
//调用代理类
hw.sayHello();
```

![[CGLib动态代理示例.png]]

- `HelloWorldProxy` 是生成的动态代理类；
- 代理方法（*调用原方法和增强处理逻辑*）封装在 `LogInterceptor` 中，这样和代理类解耦，`LogInterceptor` 可以被多个代理类复用；


# 参考
1. [[Proxy|代理模式]]