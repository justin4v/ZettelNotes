#Proxy 
# 需求
现有类：
```java
// 接口
interface IHelloWorld{
    String sayHello(String str);
}
// 实现
class HelloWorldImp implements IHello{
    @Override
    public String sayHello(String str) {
        return "HelloImp: " + str;
    }
}
```

- *动态（运行时）的为 HelloImp Class 增减功能*（如增加日志输出）；
- 但Java 规范*不允许运行时修改 .class 文件*（python，ruby等动态语言可以）。

## 解决
运行时**生成新的类**：
1. *实现接口（JDK 动态代理）*；
2. *继承类（CGLib 动态代理）*；


# 静态代理
- 新增一个 `IHello` 的实现类，增加日志输出功能；

```java
// 静态代理方式
class StaticProxiedHello implements IHelloWorld{
    ...
    private IHelloWorld hello = new HelloWorldImpl();
    @Override
    public String sayHello(String str) {
		//增加日志输出
        logger.startLog();
        return hello.sayHello(str);
		logger.endLog();
    }
}
```

# 动态代理
## JDK 动态代理
依据接口重新生成类。

1. 首先实现一个 InvocationHandler，方法调用会转发到 handler 的 invoke() 方法。
```java
// Java Proxy
class LoggerHandler implements InvocationHandler{
    ...
    private IHelloWorld hello;
    public LoggerHandler(IHelloWorld hello) {
        this.hello = hello;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if("sayHello".equals(method.getName())) {
            logger.info("You said: " + Arrays.toString(args));
        }
        return method.invoke(hello, args);
    }
}
```

2. 使用时，通过 JDK 动态代理获取 Hello 的代理对象。
```java
Hello hello = (Hello)Proxy.newProxyInstance(
    new HelloWorldImpl().getClass().getClassLoader(),  // 1. 被代理类加载器
    new Class<?>[] {IHelloWorld.class}, // 2. 代理类需要实现的接口，可以有多个
    new LogInvocationHandler(new HelloWorldImpl()));// 3. 方法调用的实际处理者
System.out.println(hello.sayHello("I love you!"));
```

### 关系示意
![[JDK动态代理示意.png]]

- `$HelloWorld100` 是生成的代理类;
- `LoggerHandler` 充当中间层，对方法进行拦截

### 特点
- **只能代理接口**


# CGLib 动态代理




# 参考
1. [[Proxy|代理模式]]