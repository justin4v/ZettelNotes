#Proxy 
# 需求
现有类：
```java
// 接口
interface IHello{
    String sayHello(String str);
}
// 实现
class HelloImp implements IHello{
    @Override
    public String sayHello(String str) {
        return "HelloImp: " + str;
    }
}
```

- *动态（运行时）的为 HelloImp Class 增减功能*（如增加日志输出）；
- 但Java 规范*不允许运行时修改 .class 文件*（python，ruby等动态语言可以）。

## 解决
运行时**生成新的类**：
1. *实现接口（JDK 动态代理）*；
2. *继承类（CGLib 动态代理）*；


# 静态代理
- 新增一个 `IHello` 的实现类，增加日志输出功能；

```java
// 静态代理方式
class StaticProxiedHello implements IHello{
    ...
    private Hello hello = new HelloImp();
    @Override
    public String sayHello(String str) {
		//增加日志输出
        logger.info("You said: " + str);
        return hello.sayHello(str);
    }
}
```

# 动态代理
## JDK 动态代理
依据接口重新生成类。

1. 首先实现一个 InvocationHandler，方法调用会被转发到该类的invoke()方法。
```java
// Java Proxy
class LogInvocationHandler implements InvocationHandler{
    ...
    private Hello hello;
    public LogInvocationHandler(Hello hello) {
        this.hello = hello;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if("sayHello".equals(method.getName())) {
            logger.info("You said: " + Arrays.toString(args));
        }
        return method.invoke(hello, args);
    }
}
// 2. 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。
Hello hello = (Hello)Proxy.newProxyInstance(
    getClass().getClassLoader(),  // 1. 被代理类加载器
    new Class<?>[] {Hello.class}, // 2. 代理类需要实现的接口，可以有多个
    new LogInvocationHandler(new HelloImp()));// 3. 方法调用的实际处理者
System.out.println(hello.sayHello("I love you!"));
```


# 参考
1. [[Proxy|代理模式]]