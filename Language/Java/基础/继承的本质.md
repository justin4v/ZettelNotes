# 继承
Java 中 使用 `extends` 关键字表明一个类继承于另外的类。
如：
```java
class father{
	....
}

class son extends father{
	...
}
```

类 son 就继承了类 father。

# 继承的本质
继承的本质是：子类对象中保存了一份父类对象，但是子类对象只对部分父类对象的属性有访问权限。
继承中需要讨论的是能不能访问的问题，而不是存不存在的问题。

1. extends 父类之后，子类已经有用了父类的一切，但是却并不是都能访问；
2. 可以访问的部分，还有 this 和 super 进行了区分；
3. 如果子类自己重写，this 和 super 访问同一个属性会有不同的结果；
4. 


，这也可以捎带解释了“构造函数不能被继承”这个说法，毕竟任何类，任何子类，都必须有自己的构造函数，哪怕自己不写，系统也会帮你写一个默认的无参构造函数的，所以你的this只能指向自己本类的构造函数，你用this是访问不到父类的构造函数的。
而至于private的域或方法，是属于无权访问的部分，即this和super都不能访问，并不代表在子类中不存在，当new一个子类时调用子类构造函数，子类构造函数又调用父类构造函数，开辟了一段内存空间，在这份空间中，其父类的private成员肯定是真实存在的，他的存在是因为new了一个子类，所以才创建的它，所以应当理解为这个成员属于新建的子类的，是因它而生的，只是访问不到而已，但可以通过setter或者getter方法得到，这也证明了private对象的存在；
有人用可以通过getter得到来证明子类是继承到了private成员的，用getter方法返回的是子类继承来的private成员，对他们来说好像子类成员的private成员和父类的被继承private成员不是一个一样。其实就是同一个，也就是说在继承关系中，new子类时内存里只可能有一份父类private的成员，因为子类无法重写父类private成员。
继承的时候是否创建了父类的对象呢，创建子类是要调用父类构造函数的，调用构造函数是要分配空间的，父类对象是创建了的，并且无论是在子类中新定义的域和方法，还是父类中定义的域和方法，在内存中能够真实分配空间都是因为实例化了一个新的子类，只不过是由父类定义的那部分成员所对应的内存，多了一个super访问的途径，以及特殊的访问权限。
另外Thinking in java中是这样说的：

```
When you create an object of the derived class, it contains within it a subobject of the 
base class. This subobject is the same as if you had created an object of the base class by 
itself. It’s just that from the outside, the subobject of the base class is wrapped within 
the derived-class object.
```
 
 也就是说通过子类构造器调用父类构造器和直接用父类创建一个父类对象时一样的，只是这个父类对象被包含在了子类对象中，且这部分代码是通过super来访问的，this能否访问以及能否用super访问，则取决于访问权限和成员是否被覆盖或重写，那样的话this就不会指向父类对象创建的成员了。
 