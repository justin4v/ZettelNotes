# 工具
借助JOL工具可以看到对象头在加锁状态下的信息。

1. 首先需要使用依赖
```xml
<dependency>
     <groupId>org.openjdk.jol</groupId>
     <artifactId>jol-core</artifactId>
     <version>0.10</version>
</dependency>
```

2. 创建 Person.java
```java
public class Person {

}
```

3. 然后创建 Demo 类

```java
public class MarkTest {

    public static void main(String[] args) {
        Person person = new Person();
        //打印JVM的详细信息
        System.out.println("---JVM的详细信息---");
        System.out.println(VM.current().details());
        //打印对应的对象头信息
        System.out.println("---对象头信息---");
   	         System.out.println(ClassLayout.parseInstance(person).toPrintable());
    }
}
```

运行的结果如下
![[JOL查看对象头.png]]

## 解释
- 默认情况下是开启压缩指针，这里的Klass 只有4个字节；
- 通过 JVM 运行参数`-XX:-UseCompressedOops`来关闭压缩指针。
- 可以看到整个对象是16个字节，其中对象头（object header）12B（12 Byte)，还有4B是对齐的字节（因为在64位虚拟机上对象的大小必须是**8的倍数**）；
- 由于对象里面没有任何字段，故而对象的实例数据为 0B；
- 现在的锁状态是01，表示无锁状态。
- 因为是**小端存储**，所以实际值是倒过来的。
- 前25bit没有使用所以都是0，后面31bit存的hashcode；
- **第一个字节中8位存储的分别就是分代年龄、偏向锁信息、对象状态**；


# 偏向锁

通过*代码模拟触发偏向锁*，然后查看对象头的信息。
代码如下

```java
public class MarkTest {

    private static final Person person = new Person();

    public static void main(String[] args) {
        //打印对应的对象头信息
        System.out.println("---before lock---");
        System.out.println(ClassLayout.parseInstance(person).toPrintable());
		// 触发偏向锁
        sync();

        System.out.println("---after lock---");
        System.out.println(ClassLayout.parseInstance(person).toPrintable());
    }

    private static void sync() {
        synchronized (person) {
            System.out.println("---thread id---"+Thread.currentThread().getId());
            System.out.println("---获取到锁---");
            System.out.println(ClassLayout.parseInstance(person).toPrintable());
        }
    }
}
```

结果如下

![[触发偏向锁.png]]

上面这个程序只有一个线程去调用sync方法，应该是偏向锁，但是你会发现输出的结果（第一个字节）依然是00000001和无锁的时候一模一样，其实这是**因为虚拟机在启动的时候对于偏向锁有延迟**，即偏向锁功能要在JVM启动几秒后才会激活，所以要关闭偏向锁的延迟，在JVM启动参数添加 `-XX:BiasedLockingStartupDelay=0`



再运行结果如下

![偏向锁](https://lushunjian.gitee.io/2021/04/25/java-de-dui-xiang-tou-markword/9.png)

**偏向锁**

这时候大家会有疑问了，为什么在没有加锁之前是偏向锁，准确的说，应该是叫**可偏向的状态**，因为它后面没有存线程的ID，当lock ing的时候，后面存储的就是线程的ID（50276357）。这里我打印了当前线程的id，发现和对象头中存储的id不一样，实际上对象头中存储的是os的线程id，而不是`Thread.currentThread.getId()`得到的线程id，它是JVM分配的id，不是os的线程id。