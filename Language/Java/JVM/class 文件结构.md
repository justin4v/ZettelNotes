
# 概念
1. Class 文件是**8 位字节为单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符；
3. 存储 8 位字节以上数据时，按照**高位在前**的方式分割成若干个 8 位字节进行存储。

# Demo
```java
public class JavaCodeComplierDemo{
	private int numberA = 1;
	public int sum(){
		int numberB = 2;
		int sum = numberA + numberB;
		return sum;
	}
}

```

用 **javac** 命令编译后就会得到 .class 文件内容如下：
![[demo的class文件内容.png]]

# Structure
Class 文件格式采用类似于 **C 语言结构体**的伪结构来存储数据，只有两种数据类型：**无符号数和表**。
-   无符号数是基本的数据类型。*u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节、8个字节的无符号数*。无符号数可以来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值；
-   **表是多个无符号数或者其他表作为数据项构成的复合数据类型**。所有表都习惯性的以“\_info”结尾；

整体结构图如下：

![[java class 文件整体结构图.png]]

## 魔数（Magic Number）
每个字节码文件的头 4 个字节称为 **魔数（Magic Number）**，它的唯一作用是确定这个文件**是否能被虚拟机接受**。

很多文件存储标准中都**使用魔数来进行身份识别**，譬如图片格式，如 gif 或者 jpg 等在文件中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。

魔数的固定值为: **0xCAFEBABE**，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。

> 有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。

## 版本号（Version）
版本号为魔数之后的 4 个字节，**前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）**。

demo 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52，在 [[Java 和 Major 版本对照表]] 中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。


## 常量池（Constant Pool）
紧接着主版本号之后的字节是常量池入口。

常量池中存储两种类型常量: **字面量和符号引用（参考 [[JVM类加载机制#Resolution]]）**。
- 字面量为代码中声明为 **final** 的常量值；
- 符号引用如**类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符**。

常量池整体上分为两部分: **常量池计数器和常量池数据区**，如图所示：
![[常量池结构.png]]


### 常量池计数器（constant_pool_count）
由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，
demo 的字节码的前十个字节如下图所示，将十六进制的 17 转为十进制的值为 33，排除下标 0，也就是说这个类文件里有 32 个常量。

![[class文件前十个字节举例.png]]


### 常量池数据区
 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。
 在字节码中共有 14 种类型的 cp_info 每种类型的结构都是固定的，如下图所示:

![[constant_info类型.png]]

整体结构上都是：**先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据**。

以 CONSTANT_Utf8_info 为例：
1. 首先第一个字节 tag，它的取值对应上图中的 Tag 值。由上图知类型 CONSTANT_Utf8_info的 tag 值为 01（十六进制）；
2. 接下来两个字节标识该字符串的长度 length
3. 接着 length 个字节为这个字符串具体的值。

从 demo 字节码中摘取一个 cp_info 结构，如下图解释：

![[CONSTANT_Utf8_info 结构.png]]

得到该常量： utf8 字符串，长度为 7 字节，数据为: numberA

#### 示例
使用 **javap -verbose JavaCodeCompilerDemo** 命令查看 JVM 反编译后的完整常量池:

![[demo完整常量池.png]]

#### 解释
- 最左边一列为常量编号（引用）；
- 等号右边一列为常量类型
- 再右边一列为常量值；
- 最右边一列是注释，表示最后常量的值。

例如:
第一个常量是一个方法定义，指向了第4和第19个常量。
以此类推查看第4 (指向 #22: `java/lang/Object`) 和第19（`"<init>":()V`）个常量。
最后可以拼接成第一个常量右侧的注释内容:
```java
java/lang/Object."<init>":()V
```

### 字节码中变量类型

| 标识字符   | 含义                                       |
| :-------: | :-------------------------------------: |
| B        | 基本类型byte                               |
| C        | 基本类型char                               |
| D        | 基本类型double                             |
| F        | 基本类型float                              |
| I        | 基本类型int                                |
| J        | 基本类型long                               |
| S        | 基本类型short                              |
| Z        | 基本类型boolean                            |
| V        | 特殊类型void                               |
| L        | 对象类型，以分号结尾，如`Ljava/lang/String;` |

参考：
[[字节码字段描述符]]

#### 注意
1. **数组类型**：每一位使用一个*前置的"["字符来表示*。如定义一个java.lang.String[][]类型的维数组，将被记录为"[[Ljava/lang/String;"
2. **方法描述符描述方法**：按照*先参数后返回值的顺序描述*，*参数要按照严格的顺序放在一组小括号内*。如方法 `int getIndex(String name,char[] tgc,int start,int end,char target)` 的描述符为 `“(Ljava/lang/String[CIIC)I”`。其中，`Ljava/lang/String`表示 `String name`、`[C`表示 `char[] tgc`、`II`表示 `int start,int end`、最后一个 `C`表示 `char target`、括号后面的 `I` 表示返回值类型为 `int`。

## 访问标志（access_flag）
常量池结束之后的两个字节，描述了该 Class 是类还是接口，以及是否被 **Public**、**Abstract**、**Final** 等修饰符修饰。

JVM 规范规定了如下 9 种访问标志（参考：[[字节码访问标志]]）

| 标志名称    | 标志值 | 含义                                          |
| -------------------------- | ------ | ------------------------------ |
| ACC_PUBLIC   | 0x0001 | Public ；可从外部访问   |
| ACC_FINAL   | 0x0010 | final；不允许继承 |
| ACC_SUPER  | 0x0020 | 调用invokespecial 时特别处理父类的方法 |
| ACC_INTERFACE   | 0x0200 | 接口   |
| ACC_ABSTRACT | 0x0400 | abstract类型。接口或者抽象类的该标志值为真，其他类型为假  |
| ACC_SYNTHETIC  | 0x1000 | 非用户代码产生，不存在于源代码|
| ACC_ANNOTATION             | 0x2000 | 注解类型 |
| ACC_ENUM              | 0x4000 | 枚举类型  |
|ACC_MODULE | 0x8000 | 模块，不是类或接口|

### 注意
JVM 并没有穷举所有的访问标志，而是使用**按位或** 操作来**组合出不同类型**
如：
修饰符为 public final，访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 **0x0001 | 0x0010 = 0x0011**。


## 当前类名（this_class）
访问标志后的两个字节，描述的是**当前类的全限定名**。

*这两个字节保存的值为常量池中的索引值*，根据索引值就能在常量池中找到这个类的全限定名。

## 父类名称（super_class）
当前类名的后两个字节，描述**父类的全限定名**。

*这两个字节保存的值也是在常量池中的索引值*，根据索引值就能在常量池中找到这个类的父类的全限定名。

## 接口信息（interfaces）
父类名称后的两个字节，描述这个类的**接口计数器，即: 当前类或父类实现的接口数量。**

紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。

## 字段表（field_table）
字段表用于描述类和接口中声明的变量，包含**类级别的变量以及实例变量**，但是**不包含方法内部声明的局部变量**。

字段表也分为两部分：
1. 两个字节，描述字段个数；
2. 每个字段的详细信息 **field_info**。

字段表结构如下所示:
![[field_table结构.png]]

以 demo 的字节码字段表为例。
- 字段的访问标志查表，002 对应为 Private；
- 索引下标 `#5` 在常量池得到字段名为: numberA
- 索引下标 `#6` 在常量池得到描述符为: I（代表 int 类型）。

综上，可得到demo 中声明的一个变量为: private int numberA 。
![[numberA在字段表中值.png]]


## 方法表（method_table）
字段表结束后为方法表，方法表也是由两部分组成：
1. 两个字节描述方法的个数；
2. 每个方法的详细信息，包括：方法的访问标志、方法名、方法的描述符以及方法的属性:

![[method_table结构.png]]

- 方法的**权限修饰符、方法名和方法的描述符**都可以通过索引值在常量池中查询得到；
- **方法属性**也是通过 **javap -verbose** 输出，主要包含三个部分:
	1.  **Code 区**: 源代码对应的 JVM 指令操作码，字节码增强的时候重点操作的就是这个部分，主要属性有：
		1.   **stack:** 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度；
		2.   **locals:** 局部变量所需的存储空间，单位为 Slot ，**Slot(4 byte) 虚拟机为局部变量分配内存时所使用的最小单位**。方法参数(包括实例方法中的隐藏参数this)、显示异常处理器的参数(try catch中的catch块所定义的异常)、方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。
		3.   **args_size:** 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this；
		4.    **attribute_info:** 方法体内容，0,1...等为字节码"行号"。
    
	2.  **LineNumberTable**: 行号表，描述*源码行号与字节码行号*(字节码偏移量)之间的对应关系，**主要用于 Debug**。
    
	2.  **LocalVariableTable**: 本地变量表，描述*帧栈中局部变量与源码中变量*之间的关系，**主要用于 Debug**。包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。

![[方法属性.png]]

## 附加属性表（additional_attribute_table）
字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。