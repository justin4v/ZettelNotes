# 内存布局
![[对象的内存布局1.png]]

![[对象的内存布局.png]]

主要有：
-  *对象头(Header)*；
-   *实例数据(Instance Data)*；
-   *对齐补充(Padding)*。

## 作用
1. 对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；
2. Klass Word是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；
3. 数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；
4. 对象体是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；
5. 对齐字是为了减少堆内存的碎片空间。

对象的创建过程参见：
[[JVM ClassLoader#创建实例对象]]


## 对象头
-  **Mark Word 运行时元数据**，HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；
-   **类型指针**，指向**类元数据 InstanceKlass** 的指针，JVM 通过该指针确定对象所属类。 另外，如果对象是一个数组，对象头中还要包含数组长度 (因为从数组的元数据无法确定数组的大小)。

## 实例数据
是程序定义的各种字段的内容，如变量和方法，*继承的父类数据也会记录下来*。

## 对齐填充
*无特别含义，仅起占位符作用*。
HotSpot 要求对象的大小必须是 8 字节的整数倍，由于*对象起始地址必须是8字节的整数倍*，但实例数据部分的长度是任意的，需要确保对象的总长度为 8 的整数倍。

## 实例结构图示

![[实例的结构.png]]


## 对象访问
栈上的 reference 数据存放的是一个地址，那么根据地址类型的不同,对象有不同的访问方式

### 句柄访问方式 
Java堆中需要有一块叫做"句柄池"的内存,存放所有对象的地址和所有对象所属类的类信息。
**reference 中存放对象在句柄池中地址**。
访问对象时：
1. 首先通过 reference找 到该对象的句柄；
2. 根据句柄中对象的地址再访问对象。


![[句柄访问对象.png]]


### 直接指针访问
**reference直接存放对象地址**，通过引用能够*直接访问对象*。
但对象所在的内存空间中需要**额外存储对象所属的类信息的地址**。


![[直接指针访问对象.png]]

### 两种方式的比较
1. 句柄是稳定的句柄地址，对象移动时也只改变句柄中的实例数据指针，reference 本身不变；
2. 直接指针只需一次寻址操作，节省指针定位的开销。

`HotSpot 采用直接指针访问方式`，因为对象的访问十分频繁，直接寻址指针节省更多时间。







