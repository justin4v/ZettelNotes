#JVM #GC 
# 两个假说
1. 当前商业虚拟机的垃圾收集器，大多数都遵循了 **分代收集（Generational Collection）** [1] 理论进行设计。
2. 分代收集实质是一套*符合大多数程序运行实际情况的经验法则*，它建立在两个分代假说之上：
	1. *弱分代假说（Weak Generational Hypothesis）*：**绝大多数对象都是朝生夕灭**。
	2. *强分代假说（Strong Generational Hypothesis）*：**熬过（Survive）越多次垃圾收集过程的对象就越难以消亡**。

## 影响
这两个分代假说共同奠定了多款常用的垃圾收集器的*一致的设计原则*：
- **收集器应该将 Java 堆( Heap )划分出不同的区域**；
- 然后**将回收对象依据其[[对象结构#age|年龄]]（即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储**。

此外：
1. 如果一个区域中*大多数都是朝生夕灭的对象*，难以熬过（Survive）垃圾收集过程。
	那么把它们集中，每次回收时**只关注如何保存少量存活对象而不是标记大量将要被回收的对象**，就能以较低代价回收到大量的空间；
2. 如果*大多数都是难以消亡的对象*，那把它们集中；
	虚拟机便**能以较低的频率来回收这个区域**，可以同时兼顾垃圾收集的时间开销和内存的空间利用率。
	
因此，根据这两个假说及其衍生的 GC 设计原则：
1. *Java Heap 应该分区*。
	分区之后，垃圾收集器才可以**每次只回收其中某一个或者某些部分的区域**：才有了 *Minor GC、Major GC、Full GC* 这样的回收类型的划分；
2. *不同区域对象有针对性的回收策略*。
	针对不同的区域**安排与其中存储对象存亡特征相匹配的垃圾收集算法**：才发展出了 *标记-复制算法、标记-清除算法、标记-整理算法* 等针对性的垃圾收集算法。
	
这一切的出现都始于分代收集理论。

# 缺陷与补充
分代收集至少存在一个明显的困难：
- 对象不是孤立的，对象之间会存在跨代引用。

说明如下：
1. 假如要现在进行一次*只局限于新生代区域内的收集（Minor GC）*，但*新生代中的对象是完全有可能被老年代所引用*。
2. 为了找出该区域中的存活对象，根据对象存活与否的[[GC 算法#可达性分析（Reachability Analysis）|可达性分析]] 不得不在固定的GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。