#JVM #GC 
# 两个假说
1. 当前商业虚拟机的垃圾收集器，大多数都遵循了 **分代收集（Generational Collection）** 理论进行设计。
2. 分代收集实质是一套*符合大多数程序运行实际情况的经验法则*，它建立在两个分代假说之上：
	1. *弱分代假说（Weak Generational Hypothesis）*：**绝大多数对象都是朝生夕灭**。
	2. *强分代假说（Strong Generational Hypothesis）*：**熬过（Survive）越多次垃圾收集过程的对象就越难以消亡**。

值得注意的是，分代收集理论也有其缺陷，最新出现（或在实验中）的几款垃圾收集器都展现出了面*向全区域收集*设计的思想，或者可以支持全区域不分代的收集的工作模式。

## 影响
这两个分代假说共同奠定了多款常用的垃圾收集器的*一致的设计原则*：
- **收集器应该将 Java 堆( Heap )划分出[[JVM内存结构#Heap|不同的区域]]**；
- 然后**将回收对象依据其[[对象结构#age|年龄]]（即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储**。

此外：
1. 如果一个区域中*大多数都是朝生夕灭的对象*，难以熬过（Survive）垃圾收集过程。
	那么把它们集中，每次回收时**只关注如何保存少量存活对象而不是标记大量将要被回收的对象**，就能以较低代价回收到大量的空间；
2. 如果*大多数都是难以消亡的对象*，那把它们集中；
	虚拟机便**能以较低的频率来回收这个区域**，可以同时兼顾垃圾收集的时间开销和内存的空间利用率。
	
因此，根据这两个假说及其衍生的 GC 设计原则：
1. *Java Heap 应该分区*。
	分区之后，垃圾收集器才可以**每次只回收其中某一个或者某些部分的区域**：才有了 *Minor GC、Major GC、Full GC* 这样的回收类型的划分；
2. *不同区域对象有针对性的回收策略*。
	针对不同的区域**安排与其中存储对象存亡特征相匹配的垃圾收集算法**：才发展出了 *标记-复制算法、标记-清除算法、标记-整理算法* 等针对性的垃圾收集算法。
	
这一切的出现都始于分代收集理论。

# 缺陷与补充
分代收集至少存在一个明显的困难：
- **对象不是孤立的，对象之间会存在跨代引用**。

说明如下：
1. 假如要现在进行一次*只局限于新生代区域内的收集（Minor GC）*，但*新生代中的对象是完全有可能被老年代所引用*。
	1. 通常*单独发生收集行为的只是新生代*，实际上除了 *CMS 收集器*，其他都不存在只针对老年代的收集。
2. 为了找出该区域中的存活对象，根据对象存活与否的[[GC 算法#可达性分析（Reachability Analysis）|可达性分析]] 不得不在固定的GC Roots 之外，再*额外遍历整个老年代中所有对象来确保可达性分析结果的正确性*。
3. 遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。

为了解决这个问题，就需要对分代收集理论添加第三条经验法则：
**跨代引用假说（Intergenerational Reference Hypothesis）**：*跨代引用相对于同代引用来说仅占极少数*。

第三个假说其实是根据前两条假说逻辑推理得出的隐含推论：
- **存在互相引用关系的两个对象，应该倾向于同时生存或者同时消亡**。
- 如果某个新生代对象存在跨代引用老年代，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

## 影响

依据这条假说：
1. 不应再为了少量的跨代引用去扫描整个老年代；
2. 不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用；
3. 只需在新生代上建立一个全局的数据结构（称为 *记忆集，Remembered Set*）：
	1. Remembered Set *把老年代划分成若干小块*；
	2. 标识出老年代的哪一块内存会存在跨代引用。
	3. 当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。

- 虽然 Remembered Set 方法*需要在对象改变引用关系（如给自己的某个属性赋值）时维护记录数据的正确性*；
- 会增加一些*运行时开销*，但比起扫描整个老年代来说仍然是划算的。