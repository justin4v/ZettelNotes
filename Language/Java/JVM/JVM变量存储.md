#JVM #Memory-structure #Todo 

# 简介
1. 寄存器：最快的存储区, 由编译器根据需求进行分配,程序中无法控制.  
2. 栈 stack：方法执行时创建方法栈帧：
	1. 存放*基本类型变量数据和对象的引用*；
	2. 对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）  
3. 堆 *Heap*：所有 *new 对象*。  
4. 静态域（*Method Area*）：存放*静态成员（static）*  
5. 常量池（*Method Area*）：存放*字符串常量和基本类型常量（public static final）*。  
6. 非RAM存储：硬盘等永久存储空间

# 运行时常量池
- 运行时常量池（Runtime Constant Pool）是方法区的一部分；

## 常量池
- 编译阶段确定；
- jvm 规范对 class 文件结构有严格的规范，必须符合规范的class文件才能被jvm装载；
- 字节码文件中包含：
	- 类的版本信息、字段、方法以及接口；
	- 还包含*常量池表（Constant Pool Table）*，包含*字面量*和对类型、域和方法的*符号引用*。
### 为什么需要常量池？
-  Java 中 class 文件需要数据支持，如果数据*很大则不能直接存到字节码里*；
- 数据存在常量池，class 文件中*包含常量池的引用*。动态链接时候用到运行时常量池。

## 特点
- 加载类和结构到虚拟机后，创建对应的运行时常量池；
- 常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用；
- **常量池表将在类加载后存放到方法区的运行时常量池中**；
- JVM 为*每个已加载的类型（类或接口）维护一个常量池*。
- 运行时常量池中包含各种不同的常量：
	- 编译时已经明确的*数值字面量*；
	- 也包括*运行期解析*得到的方法或字段引用。不再是常量池中的符号地址了，换为真实地址；
    - 运行时常量池，相对于 *Class 文件常量池*的另一个重要特征是：**动态性**：Java 语言并不要求常量一定只有编译期间才能产生，*运行期间也可将新的常量放入池*中，如String 类的 `intern()` 方法。
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。

# 参考
1. [JVM 变量存储位置](https://www.cnblogs.com/sw008/p/11054352.html)
2. [彻底弄懂java中的常量池](https://cloud.tencent.com/developer/article/1450501)
3. [姆级教程，2万字详解JVM](https://cloud.tencent.com/developer/article/1894039)
