#JVM #Java基础 
# 分配流程
![[对象分配流程.png]]                                                       

# 分配规则
-   **对象优先分配在Eden区**。如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
-   **大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
-   **长期存活的对象进入老年代**。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
-   **动态判断对象的年龄**。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
-  **空间分配担保**。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

参考：
[[JVM内存结构]]

# 内存分配方式
## 指针碰撞
**指针碰撞（Bump The Pointer）**：
1. 假设Java堆中内存是绝对规整的；
	1. 所有被使用过的内存都被放在一边；
	2. 空闲的内存被放在另一边；
	3. 中间放着一个指针作为分界点的指示器。
2. 分配内存就是把指针向空闲空间方向挪动一段与对象大小相等的距离。

## 空闲列表
**空闲列表（Free List）**：
1. 如果Java堆中的内存并不是规整的：已被使用的内存和空闲的内存相互交错在一起。
2. 虚拟机就必须维护一个列表，记录上哪些内存块是可用的。
3. 分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

## 分配方式选择
- 选择哪种分配方式由 *Java 堆是否规整*决定；
- 而 Java 堆是否规整又由所采用的 *[[GC 算法#GC 算法|垃圾收集器]]是否带有空间压缩整理（Compact）的能力* 决定。
- [[GC 算法#^1b5410|Serial]]、[[GC 算法#^838a71|ParNew]] 等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；
- 而当使用 CMS 这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。


# 内存分配的线程安全问题
- 对象创建在虚拟机中是非常频繁的行为，*即使仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的*。
	可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
解决这个问题有两种可选方案：
1. 一种是**对分配内存空间的动作进行同步处理**——实际上虚拟机是采用**[[CAS]] + 失败重试**的方式保证更新操作的原子性；
2. 另外一种是**把内存分配的动作按照线程划分在不同的空间之中进行**：
	1. 每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲（Thread Local AllocationBuffer，TLAB）**；
	2. 哪个线程要分配内存，就在哪个线程的本地缓冲区中分配；
	3. 只有本地缓冲区用完了，**分配新的缓存区时才需要同步锁定**。
	4. 虚拟机是否使用 TLAB，可以通过-XX：+/-UseTLAB参数来设定。

