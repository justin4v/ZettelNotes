# Threadsafe
## 简要定义
当多个线程访问某个类时，类始终*表现出正确的行为*，称这个类是线程安全的。

## 详细定义
A class  is _threadsafe_ if it *behaves correctly when used from multiple threads, regardless of how those threads are executed, and without demanding additional coordination from the calling code*.

1. “Behaves correctly” ： *satisfying its specification and preserving its response invariant*；
2. “Regardless of how threads are executed” ： threads might be on multiple processors or timesliced on the same processor；
3. “without additional coordination” ： *can’t put preconditions* on its caller related to timing, like “you can’t call `get()` while `set()` is in progress.”

### 示例
`Iterator`遍历可变集合时就不是线程安全的。
[`Iterator`](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/Iterator.html) 规范说`Iterator` 是An iterator over a collection...。
那么它正确的行为是 *（无论单线程还是多线程）能正确的遍历集合并得到预期的结果*。但是当用`Iterator`遍历一个可变集合时不能同时修改这个可变集合（除非用`Iterator`自己的`remove`方法）。这是对调用者的预设条件，且是时间相关的，当违反这个条件时，`Iterator`不保证有正确的行为。

当多个线程访问某个类时，不管运行时环境采用*何种调度方式或线程将如何交替执行*，且在主调代码中*不需要任何额外的同步或协同*，这个类都能*表现出正确的行为*，则称这个类是线程安全的。

## 正确性
线程安全的核心是*正确性（Correctness）* ：*类的行为和规范完全一致（conforms to its specification（ postconditions and invariants））*，能**保证不变性条件和后验条件**。
A good specification defines *invariants（不变性条件）* constraining an object’s state and *postconditions（后验条件）* describing the effects of its operations.

# 原子性
原子操作：多个操作要么全部成功，要么全部失败。


## 竞态条件
**Race condition** ： the correctness of the program (the satisfaction of postconditions and invariants) *depends on the relative timing of events in concurrent computations A and B*.

计算的正确性取决于 *A 和 B 交替执行顺序*。称 A 和 B 存在竞争。

### 竞态条件类型
最常见的竞态条件类型：**先检查后执行，Check-Then-Act**，**通过一个可能失效的观测结果决定下一步的动作。**

#### 解释
1. *先观察某个条件为真*（如文件 F 不存在）；
2. 然后*根据观察结果采取相应的动作*（如创建文件 F）。
3. 但是实际上，多线程环境中，*在观察到结果和采取动作之间的空隙，观察结果可能无效*（如其他线程执行同样的策略 Check-Then-Act 创建了文件 F）。
4. 从而出现了不准确的结果（如未预期的异常，数据被覆盖，文件被破坏等）。
  

### 示例：延迟初始化
```java
@NotThreadSafe
public class LazyInitRace {
	private ExpensiveObject instance = null;
	public ExpensiveObject getInstance() {
		if (instance == null){
			instance = new ExpensiveObject();
		}
		return instance;
	}
}
```

在 `if (instance == null)` 就是一个典型的`Check-Then-Act`类型的竞态条件。

### 读取-修改-写入
没有同步的读取-修改-写入（ **read-modify-write**） 在多线程中会出现偏差（*存在竞态条件*），如Thread A 和 Thread B同时读取到相同的值，然后修改、写入相同的值，那么最终的结果会小于预期值。
 
 ```java
 @NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
	private long count = 0;
	public long getCount() { return count; }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		++count; //非原子操作
		encodeIntoResponse(resp, factors);
	}
}
```

## 复合操作
Check-Then-Act 和 read-modify-write 都是非原子的，是一种复合操作。

# 安全性

-   **可见性** - 线程修改了某个共享变量，其状态能够立即被其他线程知晓。通常被解释为将线程本地状态反映到主内存上，`volatile` 就是负责保证可见性的。
-   **原子性** - 多个操作要么全部成功要么全部失败。一般通过同步机制（加锁：`sychronized`、`Lock`）实现。
-   **有序性** - 是保证线程内串行语义，避免指令重排等。

