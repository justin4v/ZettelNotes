#Thread-safe #Thread #Todo 


#  不是"线程的安全"
- 
- **“线程安全”** *不是指线程的安全*，而是指**内存数据的安全**。
- 目前主流操作系统都是多任务的，即多个进程同时运行。进程的内存空间中*有 Heap 堆（内存）*，Heap 进程中**线程共享**。
- 假设线程 A 处理数据（Heap 中）到一半阻塞，调度器调度线程 B 执行。当 A 再次执行时，发现 Heap 中*原有数据已被修改，不是预期数据*。线程 A 看来，数据不是安全的。 
- 比如小区看作一个进程，小区里的道路/绿化属于公共区域。你拿1万块钱往地上一扔，回家睡觉。睡醒后你打算去把它捡回来，发现钱已经不见了。  公共区域人来人往，你放的东西在*没有看管措施时，一定是不安全的*。
  
所以**线程安全**指：
> *堆(Heap)* 内存中的数据可以被任何线程访问，在没有限制的情况下**存在被意外修改的风险**，==**不符合预期**==。  

- 堆内存空间在*没有保护机制的情况下，对多线程来说是不安全的*，放进去的数据，可能被别的线程“破坏”。

# 保证线程安全

解决线程安全问题的过程其实是一个取舍的过程，不同的解决方案有不同的侧重点

## 方案1：私有化
- 现实中很多人都会把1万块钱藏着掖着，不让无关的人知道。因为这钱是你的私有物品。  
- 在程序中，操作系统会为每个线程分配**独属的内存空间，称为栈内存（Stack）**，其它线程无权访问。 常见的*私有数据*是局部变量。
- 线程私有的数据其他线程无法访问，*不会有被意外修改的风险*，不存在线程安全问题。


## 方案2：Copy，共享
- 上面的解决方案是**基于“位置”的**。因为你放东西的 *“位置”只有你自己知道（或能到达）* ，所以东西是安全的，安全是由“位置”来保障。
- 现实往往会有一个变量需要多个方法都能够使用的情况，就不能设置为线程私有。怎么保证在公共区域的东西安全呢？一个答案是：*人人有份*。
- 每个线程都拷贝一份公共区域堆内存中的数据，每个线程只处理自己的一份拷贝而不影响别的线程，就安全了。
- 实际上就是让**数据"私有化"**，本质上还是[[#方案1：私有化]]。
- Java 中的实现是 *ThreadLocal* 类。

- 线程类（Thread）有一个成员变量，类似于 Map 类型的，专门用于存储 ThreadLocal 类型的数据。
- 从逻辑从属关系来讲，这些 ThreadLocal 数据是属于 Thread 类的成员变量级别的。
- 从所在 “位置” 的角度来讲，这些 ThreadLocal 数据是分配在公共区域的堆内存中的。


## 方案3：只读
- *只能读取，不能修改*，常量或只读变量，对于多线程是安全的，因为无法更改。

```java
class StudentAssistant {

    final double passScore = 60;
}
```


## 方案4：先入为主

- 如在中午高峰期去饭店吃饭，发现只剩一个空桌子，当先去点餐吧，回来后，发现桌子已经被别人占用。
- 桌子属于公共区域的物品，任何人都可以坐，谁先抢到谁坐，然后排斥。

解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，“不好意思，这个座位，我，已经占了”。

回到程序里，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。

假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了。

这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。

第一个线程之所以敢大胆的去睡觉，就是因为它手里拿着锁呢，其它线程是不可能操作数据的。当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。

## 方案5：相信世界充满爱，即使被伤害

再回到一开始的例子，假如你往地上仍 1 万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。

可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。

比如我把数据放到公共区域的堆内存中，但是始终都只会有 1 个线程，也就是单线程模型，那这数据肯定是安全的。

再者说，2 个线程操作同一个数据和 200 个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有 1 个线程，那不安全概率就是 0，也就是安全的。

CAS。既然锁可以解决问题，那就用锁得了，为啥又冒出了个 CAS 呢？

那是因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。

针对这种 “地广人稀” 的情况，专门提出了一种方法，叫 CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用 CAS。

假如一个线程操作数据，干了一半活，累了，想要去休息。（貌似今天的线程体质都不太好）。于是它记录下当前数据的状态（就是数据的值），回家睡觉了。

醒来后打算继续接着干活，但是又担心数据可能被修改了，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其它，然后又改回来了，这就是 ABA 问题了），那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。

所以 CAS 这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，你的数据一定会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。

这里再解释下 ABA 问题，假如你睡觉前数据是 5，醒来后数据还是 5，并不能肯定数据没有被修改过。可能数据先被修改成 8 然后又改回到 5，只是你不知道罢了。对于这个问题，其实也很好解决，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加 1。

这样你睡觉前数据是 5 版本号是 0，醒来后数据是 5 版本号是 0，表明数据没有被修改。如果数据是 5 版本号是 2，表明数据被改动了 2 次，先改为其它，然后又改回到 5。

我再次相信聪明的你已经发现了，这里的 CAS 其实就是乐观锁，上一种方案里的获取锁和释放锁其实就是悲观锁。乐观锁持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，从头再来。悲观锁持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。

# 参考
1. [如果你这样回答“什么是线程安全”，面试官都会对你刮目相看](https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html#!comments)