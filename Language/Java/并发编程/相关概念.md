# 并发和并行
- **并发**是指*在一个时间段内处理多个任务*，但多个任务不一定要在同一时刻执行；
- **并行**是指*在同一个时刻处理多个任务*。

# 竞态条件和临界区
1. 竞态条件（race condition）：当两个线程（进程）*竞争程序中同一资源*时，如果*对资源的访问顺序影响运行结果*，就称程序存在竞态条件。
2. 临界区（critical sections）：导致竞态条件发生的*代码区*称作临界区。

参考：
- [[线程安全问题#竞态条件]]

# 并发的优点
1. **提升资源利用率**；
2. **程序响应更快**。

## DES
在处理需要耗时较长的任务时，CPU通常需要等待。可以切换到不同线程执行其他任务，使得 CPU 始终处于工作状态，可以*提升 CPU 利用率*。

如果服务器在监听的时候，请求才能被接收，当服务器忙于处理一个耗时很长的请求，则无法响应其他客户端。
如果监听线程把请求传递给*工作者线程(worker thread)*，然后返回去监听新请求，则能*响应新请求更快*。


# 并发的问题
[[程序性能的限制与解决]]中引入了几种提高性能的策略，同时也带来了并发中的几种问题：
- [[线程安全问题]] *Safety hazards*
- [[活跃性问题]] *Liveness hazards*
- [[性能问题]] *Performance hazards*


# 重入
重入（*Reentrancy*）是指**一个线程可以再次获取已经获取到的锁**。

## 实现策略
Reentrancy：
1. 为每个锁关联一个获取计数器和所有者记录；
2. 计数器为0时，认为锁没有被线程持有；
3. 当线程 A 成功获取锁后，计数器加1，JVM 记录持有者线程 ID；
4. 当线程 B 尝试获取锁时，由于和持有者记录不匹配，线程 B 等待或进入阻塞；
5. 当线程 A 再次获取时，计数器加1；
6. 线程 A 退出同步代码块时，计数器递减，当计数器为0时，锁被释放。

 ## 示例
 
 ```java
 //father
public class Widget {  
    public synchronized void doSomething(){ 
		// 断点2
        System.out.println("super do something...");  
    }  
}
  
//son
public class SubWidget extends Widget {  
  
    @Override  
 public synchronized void doSomething(){  
 		// 断点1
        System.out.println("sub do something...");  
        super.doSomething();  
    }  
}

// main
public class InnerReentryTest {  
    public static void main(String[] args) {  
        SubWidget subWidget=new SubWidget();  
        subWidget.doSomething();  
    }  
}
```


### Thread Dump
IDEA debug 后
1. 在断点1处查看 Thread Dump ( *debug 界面照相机图标*)：
```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at com.example.demo.concurrency.synchronize.inner.SubWidget.doSomething(SubWidget.java:14)
	  - locked <0x1f2> (a com.example.demo.concurrency.synchronize.inner.SubWidget)
	  at com.example.demo.concurrency.synchronize.inner.InnerReentryTest.main(InnerReentryTest.java:13)
```

看到锁住的是 SubWidget 对象。

2. 在断点2处查看 Thread Dump

```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at com.example.demo.concurrency.synchronize.inner.Widget.doSomething(Widget.java:12)
	  - locked <0x1f2> (a com.example.demo.concurrency.synchronize.inner.SubWidget)
	  at com.example.demo.concurrency.synchronize.inner.SubWidget.doSomething(SubWidget.java:15)
	  at com.example.demo.concurrency.synchronize.inner.InnerReentryTest.main(InnerReentryTest.java:13)
```

可以看到：
-  当前调用的方法是 Widget.doSomething ；
-  前面锁住的对象还是 SubWidget ；
-  说明内置锁 Intrinsic Lock 是可重入的，*获取两次子类的锁*；
-  说明子类对象中保留了一份父类对象。


# 内置锁
Java提供内置的锁机制支持原子性：**同步代码块（Synchronized Block）**。
Java对象自带一个*内置锁（Intrinsic Lock）* 也称作*监视器锁（Monitor Lock）*，加锁和解锁是 JVM 控制的。线程进入同步代码块之前需要获得锁，离开后自动释放锁。

## 实现策略
1. 每个对象都有一个对象头；
2. 对象头中有 markworld 字段。

参考：
[[对象结构]]