# 概念
**轻量级**是**相对于使用操作系统互斥量（Mutex Lock）实现的传统锁**而言的。

1. 轻量级锁并*不是用来代替重量级锁*，它的本意是在没有多线程竞争的前提下，减少使用传统的重量级锁产生的性能消耗。
2. 轻量级锁*适应的场景是线程交替执行同步块*的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

# 轻量级锁的加锁过程
![[轻量级锁的加锁和膨胀流程.png]]

1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（biased_lock|lock 为 0|01），虚拟机首先将在*当前线程的栈帧（stack frame）*中*新建锁记录（Lock Record）*，用于*存储锁对象目前的 Mark Word的拷贝*，称之为 Displaced Mark Word。

2. 拷贝成功后，虚拟机用 CAS 尝试更新对象的 Mark Word ：
	1. 更新 Mark Word 的前 62 位为指向 Lock Record 的指针； ![[对象结构#ptr_to_lock_record]]
	2. 将 Lock record 里的 owner 指针指向对象的mark word。
	如果更新成功，则执行步骤3，否则执行步骤4。

3. 如果更新成功，线程就拥有了该对象的锁，将对象 Mark Word 的锁标志位设置为“00”，表示对象处于轻量级锁定状态
4. 如果更新失败，虚拟机首先会检查对象 Mark Word 是否指向当前线程的栈帧：
	1. 如果是，说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行。
	2. 否则说明多个线程竞争锁，轻量级锁膨胀为重量级锁：锁标志的状态值变为“10”、Mark Word 中存储指向重量级锁（互斥量）的指针、后面等待锁的线程进入阻塞状态。 
	3. 当前线程释放锁并唤醒等待线程，线程之间重新争夺锁。
  
  
  # 轻量级锁的解锁过程

1. 通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的 Mark Word。
2. 如果更新成功，整个同步过程就完成了。
3. 如果更新失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。