# 背景
- 加锁机制是实现线程安全的一种机制；
- 加锁机制主要用于保证多个操作的原子性。


# 内置锁
Java提供内置的锁机制支持原子性：**同步代码块（Synchronized Block）**。
Java对象自带一个*内置锁（Intrinsic Lock）* 也称作*监视器锁（Monitor Lock）*，加锁和解锁是 JVM 控制的。线程进入同步代码块之前需要获得锁，离开后自动释放锁。

# 重入
重入（*Reentrancy*）是指**一个线程可以再次获取已经获取到的锁**。

## 实现策略
Reentrancy：
1. 为每个锁关联一个获取计数器和所有者记录；
2. 计数器为0时，认为锁没有被线程持有；
3. 当线程 A 成功获取锁后，计数器加1，JVM 记录持有者线程 ID；
4. 当线程 B 尝试获取锁时，由于和持有者记录不匹配，线程 B 等待或进入阻塞；
5. 当线程 A 再次获取时，计数器加1；
6. 线程 A 退出同步代码块时，计数器递减，当计数器为0时，锁被释放。

 ## 示例
 
 ```java
 //father
public class Widget {  
    public synchronized void doSomething(){ 
		// 断点2
        System.out.println("super do something...");  
    }  
}
  
//son
public class SubWidget extends Widget {  
  
    @Override  
 public synchronized void doSomething(){  
 		// 断点1
        System.out.println("sub do something...");  
        super.doSomething();  
    }  
}

// main
public class InnerReentryTest {  
    public static void main(String[] args) {  
        SubWidget subWidget=new SubWidget();  
        subWidget.doSomething();  
    }  
}
```


### Thread Dump
IDEA debug 后
1. 在断点1处查看 Thread Dump：
```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at com.example.demo.concurrency.synchronize.inner.SubWidget.doSomething(SubWidget.java:14)
	  - locked <0x1f2> (a com.example.demo.concurrency.synchronize.inner.SubWidget)
	  at com.example.demo.concurrency.synchronize.inner.InnerReentryTest.main(InnerReentryTest.java:13)
```

看到锁住的是 SubWidget 对象。

2. 在断点2处查看 Thread Dump

```java
"main@1" prio=5 tid=0x1 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at com.example.demo.concurrency.synchronize.inner.Widget.doSomething(Widget.java:12)
	  - locked <0x1f2> (a com.example.demo.concurrency.synchronize.inner.SubWidget)
	  at com.example.demo.concurrency.synchronize.inner.SubWidget.doSomething(SubWidget.java:15)
	  at com.example.demo.concurrency.synchronize.inner.InnerReentryTest.main(InnerReentryTest.java:13)
```

可以看到：
-  当前调用的方法是 Widget.doSomething ；
-  前面锁住的对象还是 SubWidget ；
-  说明内置锁 Intrinsic Lock 是可重入的；
-  说明子类对象中保留了一份父类对象。

需要*获取两次子类的锁*