#I/O-model #Problem-and-Solutions 

# 问题
1. 如何突破原始 I/O 的效率限制？ 

# 输入步骤
1. 等待*数据从网络中到达*。当所等待的分组到达的时候，它就被复制到内核中的某个缓冲区中；
2. 准备好后，把数据*从内核空间拷贝到应用（用户）空间*。

# 阻塞式 I/O

![[阻塞式IO模型.png]]
- 经典的应用：**阻塞 socket、Java BIO**。
- 缺点：
	1. 如果内核数据一直没准备好，那用户进程将一直阻塞，**浪费性能**；
	2. 可用**非阻塞IO**优化

# 非阻塞式 I/O
如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下
![[非阻塞IO模型.png]]

非阻塞IO的流程如下：
-   应用进程向操作系统内核，发起`recvfrom`读取数据。
-   操作系统内核数据没有准备好，立即返回`EWOULDBLOCK`错误码。
-   应用程序轮询调用，继续向操作系统内核发起`recvfrom`读取数据。
-   操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。
-   完成调用，返回成功提示。

- 简称**NIO**，`Non-Blocking IO`。
- 相对于阻塞IO，大幅提升了性能；
- 但是依然存在**性能问题**，即**频繁的轮询**，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑**IO复用模型**，去解决这个问题。

  
作者：捡田螺的小男孩  
链接：https://juejin.cn/post/7036518015462015006  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# I/O 复用

![[IO复用模型.png]]
- 使用一个单独的线程专门监听 I/O 状态；
- 当某个 I/O ready 后调用相应的线程处理。


# 信号驱动 I/O（SIGIO）

![[信号驱动IO模型.png]]

# 异步 I/O

![[异步IO模型.png]]


# 阻塞/非阻塞 IO
数据没有准备好时，IO 函数：
1. *直接返回（错误） ---- 非阻塞 IO*；
2. *等待数据就绪（调用线程处于阻塞 blocked 状态） ---- 阻塞 IO*。

## Blocking
被调用函数返回之前，调用线程会被挂起（线程进入阻塞状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

## Non-Blocking
在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。


# 同步/异步
## 同步/异步 IO
- synchronous I/O 导致调用线程阻塞；
- asynchronous I/O 不会导致调用线程阻塞；
- 所以[[IO模型]]中*前四种都是同步IO（第二步是阻塞）*，最后一个才是异步IO。

## 同步/异步调用
- 线程间关系；
- 同步调用指*调用方等待功能完成*，才从调用中返回并进行下一步操作。
- 异步调用指调用方发出功能调用后，*立即从功能调用中返回*（没有得到实际操作结果），并可进行下一步操作。
	- 如将调用交给 worker 处理后即可从调用中返回。worker 完成处理后，通过状态、通知和回调来通知原调用者处理结果。