#IO-model #Problem-and-Solutions 

# 问题
1. 如何突破原始 I/O 的效率限制？ 
2. 如何提高IO的效率，应对大量客户端（多路复用），提高响应速度？

# 输入步骤
1. 等待*数据从网络中到达*。当所等待的分组到达的时候，它就被复制到内核中的某个缓冲区中；
2. 准备好后，把数据*从内核空间拷贝到应用（用户）空间*。

# 阻塞式 I/O(Blocking IO)
- 应用程序中进程发起 IO 调用后至内核执行 IO 操作返回结果之前，若发起调用的*线程一直处于等待状态*，则此次IO操作为阻塞IO。阻塞IO简称 *BIO*，*Blocking IO*。
- 其处理流程如下图所示
![[阻塞式IO模型.png]]
- 经典的应用：**阻塞 socket、Java BIO**。
- 缺点：
	1. 如果内核数据没准备好，用户进程将*一直阻塞*，**浪费性能**；
	2. 可用**非阻塞IO**优化

# 非阻塞式 I/O(Nonblocking IO)
- 如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待；
- 进程通*过轮询的方式再来请求*。这就是*非阻塞 IO，NIO*，流程图如下
![[非阻塞IO模型.png]]

非阻塞IO的流程如下：
-   应用进程向操作系统内核，发起`recvfrom`读取数据。
-   操作系统内核数据没有准备好，立即返回`EWOULDBLOCK`错误码。
-   应用程序轮询调用，继续向操作系统内核发起`recvfrom`读取数据。
-   操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。
-   完成调用，返回成功提示。

- 简称**NIO**，`Non-Blocking IO`。
- 相对于阻塞IO，大幅提升了性能；
- 但是依然存在**性能问题**，即**频繁的轮询**，导致频繁的系统调用，同样会消耗大量的CPU资源。
- 可用**IO复用模型**解决。



# I/O 多路复用(IO multiplexing)

既然**NIO**无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？

## 文件描述符
- linux 系统中高效查找文件？
- linux 一切皆文件，用一个非负整数标记打开的文件；
- **文件描述符 fd**(File Descriptor)。

## IO复用思路
- 系统给提供**一类函数**（如**select、poll、epoll**：
	- 可以同时监控多个 `fd` 的操作；
	- 一旦任何一个内核数据就绪，应用进程就发起 `recvfrom` 调用准备接受数据。

### IO多路复用之select
- 应用进程调用select函数，同时监控多个`fd`；
- `select` 监控的`fd`中，只要有任何一个数据状态准备就绪了，`select`函数就会返回可读状态；
- 应用进程再发起`recvfrom`请求去读取数据。

![[IO多路复用-select.png]]


- 非阻塞IO模型（NIO）中，需要 `N` 次*轮询调用*;
- `select` IO多路复用模型，*只需发起一次系统调用*，大大优化了性能。

`select`缺点：
- 监听的 *IO 最大连接数有限*，在Linux系统上一般为1024。
- select 函数返回后，通过*遍历 `fdset`*，找到就绪的描述符`fd`。（仅知道有I/O事件发生，却不知是哪几个流）

### poll
- select **存在连接数限制**，又提出了**poll**。
- select相比，**poll** 解决了**连接数限制问题**。
- 但是 selec t和 poll 一样，需要*遍历文件描述符* 确定已经就绪的`socket`。
- 如果同时连接的大量客户端在一时刻只有极少处于就绪状态，伴随着监视的描述符数量的增长，**效率也会线性下降**。

### epoll

为了解决`select/poll`存在的问题，多路复用模型`epoll`诞生，它采用 *事件驱动* 来实现，流程图如下：

![[IO多路复用-epoll.png]]

- **epoll**先通过`epoll_ctl()`来注册一个`fd`（文件描述符）；
- 某个 `fd` 就绪时，*内核采用**回调机制***，迅速激活这个 `fd`；
- 进程调用 `epoll_wait()` 时便得到事件通知。
- 省去了 **遍历 fd 的过程，而是用**监听事件回调**的的机制。

### select、poll、epoll对比
![[select-poll-epoll对比.png]]


- **epoll** 优化了 IO 的执行效率;
- 缺点：
	- 进程调用 `epoll_wait()` 时，仍然*会被阻塞*。
	- 优化：不用进程询问数据是否准备就绪，等发出请求后，一旦数据准备好了通知进程，就诞生了**信号驱动IO模型**。


# 信号驱动 I/O（SIGIO Signal Driven IO）
- 实际中*不常用*；
- 不再主动询问的方式去确认数据是否就绪，而是*向内核发送一个信号*（调用`sigaction`的时候建立一个`SIGIO`的信号）；
- 应用用户进程可以去做别的事，不用阻塞。
- 当内核数据准备好后，再通过 `SIGIO` 信号通知应用进程，数据准备好后的可读状态。
- 应用用户进程收到信号之后，立即调用`recvfrom`，去读取数据

![[信号驱动IO模型.png]]
- 应用进程发出信号后，立即返回，不会阻塞进程。
- 但是**数据复制到用户空间的过程是阻塞的**。不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。

  
# 异步 I/O(Asynchronous IO)
- `AIO`实现了 *IO 全流程的非阻塞*；
- 应用进程发出系统调用后，立即返回；
- 但是立即返回的不是处理结果，而是*提交成功*的意思。
- 等内核数据准备好，将数据拷贝到用户进程缓冲区，*发送信号通知用户进程*IO操作执行完毕

![[异步IO模型.png]]
- 异步 IO 对其余四种同步 IO 的优化思路很简单，只需*向内核发送一次请求*，就可完成数据状态询问和数据拷贝的所有操作；
- 不用阻塞等待结果。
- 日常开发中，有类似的业务场景：
> 比如发起一笔批量转账，但是转账处理比较耗时，后端可以*先告知前端转账提交成功*，等到结果处理完，再通知前端结果即可。

## 对比
![[5种IO模型对比.png]]

![[IO模型分类.png]]

# 阻塞/非阻塞 IO 的实质含义
线程运行状态如下：
![[线程状态及转变#状态图]]

- 这里的 “阻塞（blocking）”是指进程在发起了一个**系统调用**(System Call)，如 I/O 操作， 由于该系统调用的操作*不能立即完成，需要等待一段时间*；
- 内核将进程*挂起为阻塞 （blocked）状态*， 以*确保不会被调度执行， 占用 CPU 资源*，所以称为阻塞IO。
- IO完成后再标记为 runnable 状态。

## 其他
- 操作系统内核在执行 System Call 时， *CPU 需要与 IO 设备完成一系列物理通信上的交互*， 其实*再一次会涉及到阻塞和非阻塞*的问题。
	- 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。
- 现代计算机中，这些物理通信操作*基本都是异步完成*， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。
- 但是大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得*应用级代码的编写更容易*（代码的执行顺序和编写顺序是一的）。
- 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。

## 非阻塞IO和异步IO
- 非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是**异步I/O系统调用 （asychronous system call）**。
- 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成；
-  应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程：
	1. *设置一个用户空间特殊的变量值*
	2. *触发一个 signal* 
	3.  产生一个*软中断* 
	4. *调用应用程序的回调函数*

### 区别
 非阻塞I/O 系统调用( nonblocking system call ) 和异步I/O系统调用 （asychronous system call）的*区别*是：
-   一个**非阻塞I/O 系统调用 read()** 操作立即返回的是**任何可以立即拿到的数据**。 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。
-   **异步I/O系统调用** read() **结果必须是完整的**， 但是操作完成的通知可以延迟到将来的一个时间点。

# 同步/异步、阻塞/非阻塞总结
- 阻塞/非阻塞核心区别就是看当前任务有没有被挂起。
- 在*进程通信*层面： **阻塞/非阻塞， 同步/异步基本是同义词**。发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。
- 在 IO 系统调用层面（ IO system call ）层面， 非阻塞IO 系统调用 和 异步IO 系统调用存在着一定的差别：
	- 它们都不会阻塞进程， 返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）。
- 阻塞和非阻塞：
	1. 等待 I/O 的期间自己会不会被挂起，处于 block 状态。
	2. 描述的是线程自己的状态。
- 同步异步：
	1. 是不是需要一直等待操作结果的返回，甚至被挂起（也可能不被挂起）。
	2. 描述的是用户线程与内核的交互方式（通信机制）。
- 同步阻塞 IO：BIO
	1. 同步等待返回；
	2. 阻塞状态。
- 同步非阻塞 IO：NIO
	1. 同步等待返回；
	2. 可执行轮询，非阻塞。
- 异步非阻塞：AIO
	1. 异步，当前线程无需等待；
	2. 非阻塞