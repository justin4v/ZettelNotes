#I/O-model #Problem-and-Solutions 

# 问题
1. 如何突破原始 I/O 的效率限制？ 

# 输入步骤
1. 等待*数据从网络中到达*。当所等待的分组到达的时候，它就被复制到内核中的某个缓冲区中；
2. 准备好后，把数据*从内核空间拷贝到应用（用户）空间*。

# 阻塞式 I/O

![[阻塞式IO模型.png]]
- 经典的应用：**阻塞 socket、Java BIO**。
- 缺点：
	1. 如果内核数据一直没准备好，那用户进程将一直阻塞，**浪费性能**；
	2. 可用**非阻塞IO**优化

# 非阻塞式 I/O
如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下
![[非阻塞IO模型.png]]

非阻塞IO的流程如下：
-   应用进程向操作系统内核，发起`recvfrom`读取数据。
-   操作系统内核数据没有准备好，立即返回`EWOULDBLOCK`错误码。
-   应用程序轮询调用，继续向操作系统内核发起`recvfrom`读取数据。
-   操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。
-   完成调用，返回成功提示。

- 简称**NIO**，`Non-Blocking IO`。
- 相对于阻塞IO，大幅提升了性能；
- 但是依然存在**性能问题**，即**频繁的轮询**，导致频繁的系统调用，同样会消耗大量的CPU资源。
- 可用**IO复用模型**解决。



# I/O 复用

既然**NIO**无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？

## 文件描述符
**文件描述符 fd**(File Descriptor)。

## IO复用思路
- 系统给提供**一类函数**（如**select、poll、epoll**：
	- 可以同时监控多个 `fd` 的操作；
	- 一旦任何一个内核数据就绪，应用进程就发起 `recvfrom` 调用准备接受数据。

### IO多路复用之select

应用进程通过调用select函数，可以同时监控多个`fd`，在`select`函数监控的`fd`中，只要有任何一个数据状态准备就绪了，`select`函数就会返回可读状态，这时应用进程再发起`recvfrom`请求去读取数据。

![[IO多路复用-select.png]]


非阻塞IO模型（NIO）中，需要`N`（N>=1）次轮询系统调用，然而借助`select`的IO多路复用模型，只需要发起一次系统调用就够了,大大优化了性能。

但是呢，`select`有几个缺点：

- 监听的IO最大连接数有限，在Linux系统上一般为1024。
- select函数返回后，是通过遍历`fdset`，找到就绪的描述符`fd`。（仅知道有I/O事件发生，却不知是哪几个流，所以遍历所有流）

因为**存在连接数限制**，所以后来又提出了**poll**。与select相比，**poll**解决了**连接数限制问题**。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的`socket`。如果同时连接的大量客户端在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，**效率也会线性下降**。

因此经典的多路复用模型`epoll`诞生。

### IO多路复用之epoll

为了解决`select/poll`存在的问题，多路复用模型`epoll`诞生，它采用事件驱动来实现，流程图如下：

![[IO多路复用-epoll.png]]

**epoll**先通过`epoll_ctl()`来注册一个`fd`（文件描述符），一旦基于某个`fd`就绪时，内核会采用回调机制，迅速激活这个`fd`，当进程调用`epoll_wait()`时便得到通知。这里去掉了**遍历文件描述符**的坑爹操作，而是采用**监听事件回调**的的机制。这就是epoll的亮点。


select、poll、epoll的区别
![[select-poll-epoll对比.png]]


**epoll**明显优化了IO的执行效率，但在进程调用`epoll_wait()`时，仍然可能被阻塞的。能不能酱紫：不用我老是去问你数据是否准备就绪，等我发出请求后，你数据准备好了通知我就行了，这就诞生了**信号驱动IO模型**。


# 信号驱动 I/O（SIGIO）

![[信号驱动IO模型.png]]

# 异步 I/O

![[异步IO模型.png]]


# 阻塞/非阻塞 IO
数据没有准备好时，IO 函数：
1. *直接返回（错误） ---- 非阻塞 IO*；
2. *等待数据就绪（调用线程处于阻塞 blocked 状态） ---- 阻塞 IO*。

## Blocking
被调用函数返回之前，调用线程会被挂起（线程进入阻塞状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

## Non-Blocking
在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。


# 同步/异步
## 同步/异步 IO
- synchronous I/O 导致调用线程阻塞；
- asynchronous I/O 不会导致调用线程阻塞；
- 所以[[IO模型]]中*前四种都是同步IO（第二步是阻塞）*，最后一个才是异步IO。

## 同步/异步调用
- 线程间关系；
- 同步调用指*调用方等待功能完成*，才从调用中返回并进行下一步操作。
- 异步调用指调用方发出功能调用后，*立即从功能调用中返回*（没有得到实际操作结果），并可进行下一步操作。
	- 如将调用交给 worker 处理后即可从调用中返回。worker 完成处理后，通过状态、通知和回调来通知原调用者处理结果。