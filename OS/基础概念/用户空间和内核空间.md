#Kernel-space #User-space #Todo 

# 背景

- CPU 指令中*有些是非常危险*的，错用将导致系统崩溃，比如*清内存、设置时钟*等。
- 如果允许所有的程序都可以使用这些指令，系统崩溃的概率将大大增加。  
- 所以，CPU 将指令分为**特权指令和非特权指令**：
	- 可能带来危险的指令，只允许操作系统及其相关模块使用；
	- 普通应用程序只能使用非特权指令。
- 如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。  
- Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)：
	-  Ring3 级别状态称为用户态，Ring0 级别称为内核态。

# 概念
- Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。
	- 在 32 bit OS 中最高 1G 为内核空间，剩下为用户空间
	- ![[32bit OS 内核和用户空间划分示意.png]]

- 为了操作系统安全，内核空间和用户空间是隔离的，用户的程序崩溃了，内核也不受影响。
- 当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。
- Kernel space 可以执行任意命令，调用系统的一切资源；
- User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统调用（又称 system call），才能向内核发出指令。

## 优点
- 对于 Linux ，区分内核空间和用户空间的设计，**隔离了操作系统与应用程序代码**(操作系统的代码要比应用程序的代码健壮很多)。
- 单个应用程序出现错误也*不影响到操作系统的稳定性*；
- 其它的程序还可以正常的运行。
- **区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。**

# 从用户空间进入内核空间
- **所有的系统资源管理都是在内核空间中完成**
	- 比如**读写磁盘文件，分配回收内存，从网络接口读写数据**等等。
- 应用程序无法直接操作，可以通过内核提供的接口来完成。  
- 如应用程序要读取磁盘上的一个文件：
	1. 向内核发起一个 "系统调用" 告诉内核："我要读取磁盘上的某某文件"。其实就是通过一个特殊的指令让进程从用户态进入到内核态(到了内核空间)，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，可以开开心心的往下执行了。  
简单说就是应用程序把高科技的事情(从磁盘读取文件)外包给了系统内核，系统内核做这些事情既专业又高效。

对于一个进程来讲，从用户空间进入内核空间并最终返回到用户空间，这个过程是十分复杂的。举个例子，比如我们经常接触的概念 "堆栈"，其实进程在内核态和用户态各有一个堆栈。运行在用户空间时进程使用的是用户空间中的堆栈，而运行在内核空间时，进程使用的是内核空间中的堆栈。所以说，Linux 中每个进程有两个栈，分别用于用户态和内核态。

下图简明的描述了用户态与内核态之间的转换：

# 参考

1. [用户空间和内核空间是什么？](https://cloud.tencent.com/developer/article/1352415)
2. [Linux 内核空间与用户空间](https://www.cnblogs.com/sparkdev/p/8410350.html)