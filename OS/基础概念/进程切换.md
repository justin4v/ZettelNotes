#Process #Operating-system #进程 

# 进程切换

![[进程切换示意图.png]]

1.  当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。
2.  操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。
3.  从 PCBj 取出进程 j 的 CPU上下文， 将 CPU控制权转移给进程 j ， 开始执行进程 j 的指令。


# 进程切换上下文
![[进程切换的全景图示意.png]]

- 发生中断时保存现场，将发生中断时的所有通用寄存器保存到进程的内核栈，使用struct pt_regs结构。
- 地址空间切换将进程自己的页全局目录的基地址 pgd 保存在 ttbr0_le1 中，用于 mmu 的页表遍历的起始点。
- 硬件上下文切换的时候，将此时的调用保存寄存器和pc, sp保存到struct cpu_context结构中。
- 做好了这几个保存工作，当进程再次被调度回来的时候，通过cpu_context中保存的pc回到了cpu_switch_to的下一条指令继续执行，
- 而由于cpu_context中保存的sp导致当前进程回到自己的内核栈，经过一系列的内核栈的出栈处理，最后将原来保存在pt_regs中的通用寄存器的值恢复到了通用寄存器，这样进程回到用户空间就可以继续沿着被中断打断的下一条指令开始执行，用户栈也回到了被打断之前的位置，而进程访问的指令数据做地址转化（VA到PA）也都是从自己的pgd开始进行，一切对用户来说就好像没有发生一样，简直天衣无缝。
# 参考
