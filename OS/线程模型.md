# 实现的方式
主流的操作系统都提供了线程实现，Jav语言则是提供了在不同硬件和操作系统平台下对线程操作的统一处理。
每个已经调用过 start() 方法且还未结束的`java.lang.Thread`类的实例就代表一个线程。  
其实Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为 Native（参见[[JVM内存结构]]） 。
在Java中，Native方法往往就意味着**没有使用或无法使用平台无关的手段来实现（通常最高效率的手段就是平台相关的手段）**

线程的实现一般有三种方式：
-   **内核线程实现**（1:1）；
-   **用户线程实现**（1:N）；
-   用户线程加轻量级进程的**混合实现**（N:M）；

## 内核线程模型
内核线程模型即完全依赖操作系统内核提供的**内核线程（Kernel-Level Thread ，KLT）** 来实现多线程。
在此模型下，线程的切换调度由系统内核完成，系统内核负责将多个线程执行的任务映射到各个CPU中去执行。
用户进程使用系统内核提供的接口——**轻量级进程（Light Weight Process，LWP**）来使用系统内核线程。
在此种线程模型下，由于一个用户线程对应一个LWP，因此某个LWP在调用过程中阻塞了不会影响整个进程的执行。

但这种线程模型也有如下缺点：
-   各种线程的操作都需要在用户态和内核态之间频繁切换，消耗较大
-   每个LWP都需要一个内核线程来支持执行用户代码，会消耗更多的内核内存空间，因此系统内核提供的KLT的数量是有限制的。


![[内核线程模型.png]]


## 用户线程模型
用户线程模型完全建立在用户空间的线程库上，不依赖于系统内核，用户线程的创建、同步、切换和销毁等操作完全在用户态执行，不需要切换到内核态。
在此种线程模型下，线程的各种操作以及切换消耗很低，但线程的所有操作都需要在用户态实现，线程的调度实现起来异常复杂，处理器映射更是无法实现。

![[用户线程模型.png]]


## 混合线程模型
混合线程模型是前述两种模型的混合版本，用户线程仍然是在用户态中创建，用户线程的创建、切换和销毁的消耗很低，用户线程的数量不受限制。而LWP在用户线程和内核线程之间充当桥梁，就可以使用操作系统提供的线程调度和处理器映射功能。

![[混合线程模型.png]]