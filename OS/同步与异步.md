# 同步与异步
## Conception
同步和异步指访问数据的机制，进程主动请求（I/O）数据，该进程：
1. 等待 I/O 数据就绪，并进行读写操作（包括从内核拷贝到用户空间）；
2. 直接从请求中返回，继续处理其他事务，等待 I/O 操作完成（数据已拷贝到用户空间）的通知，直接在用户空间操作数据。


## 同步
发出功能调用后，*等待功能完成，才从调用中返回并进行下一步操作*。
事务必须一个接着一个的完成，前一件完成了才能做下一件。


## 异步
发出功能调用后，*立即从功能调用中返回（没有得到实际操作结果），并可进行下一步操作*。
如将调用交给 worker 处理后即可从调用中返回。worker 完成处理后，通过状态、通知和回调来通知原调用者处理结果。

# 阻塞与非阻塞
## Conception
**阻塞和非阻塞指函数具体实现层面的策略**。该函数在处理数据时（一般是指 I/O 操作），如果数据没有就绪，该函数：
1. 直接返回（错误） ---- 非阻塞；
2.  等待数据就绪 ---- 阻塞。


## Blocking
被调用函数返回之前，调用线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

## Non-Blocking
在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。


# 比较
## 同步/异步与阻塞/非阻塞

## 阻塞和同步
- **同步调用很多时候当前（调用）线程是激活的**，只是从逻辑上当前函数没有返回而已。 
例如，在 socket 中调用 recv 函数，如果缓冲区中没有数据，recv 函数会一直等待到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。
- **阻塞时当前（调用）线程是被阻塞的**，cpu 不会分配时间片，进程暂停运行。