在现代的计算机世界中，程序的执行与实际代码的书写所体现的顺序经常会不太一致，从而使得关于一个程序以什么样的方式运行所得到的结果算是正确的这样一个问题的答案常常是模糊的。

但为什么会出现这种顺序的不致？我们通常可以从下面两方面找到答案。

# CPU中的指令重排与内存操作排序
## 指令周期
基于指令集的不同，不同CPU实际有着不同的指令周期划分，在这里我们将CPU的指令周期简单分解为如下的几个阶段（虽然实际不同的指令架构下CPU的指令执行周期具体划分会有不同，但这种不同对于我们的分析并不会有实质影响）：

  >1.指令预取（Instruction Pre-fetch)
  >2.指令解码 (Instruction Decode)， 这里可能会需要从内存中加载涉及到的操作数等
  >3.指令执行 (Instruction Execution)
  >4.结果回写 (Result Write-back)， 这里需要将运算结果写回到主存

CPU可以串行连续执行一条指令的各个阶段，但在更为常见的情况下是尽量并行地执行多个独立指令的不同阶段，从而提高指令的整体吞吐量。

在指令并行执行的情况下，我们可以作如下图所示的一种形象描述：指令流由cpu一侧进入而从另一侧产生流出产生结果，为此这种结构得名为“指令流水线”（Instruction Pipeline)。

![[指令流水线.png]]

1. 图中横坐标方向展示了指令的四个周期（也可认为是cpu中的四个部件），纵向为时间轴。
2. 一条指令执行会先后通过指令的四个周期。
3. 本图描绘了一种理想的状况：随着时间增长，指令1~6顺次串行通过了指令流水。

## 改进
为了提高CPU指令流水线的吞吐率，改进整体性能，现代CPU的设计师们必然会从目前性能最低的部分入手来做出调整，涉及到**内存操作的解码和回写部件**就成为了被关注的重点。

通常设计师们会使用寄存器，高速缓冲和队列等机制来改善这两部分的性能。

### 解码
例如，在指令解码部件中就通常会引入指令解码队列：当一条指令的解码过程因为需要访问主存而被挂起时，队列中的后续指令在与前面的指令没有逻辑依赖关系的情况下将可能被先行解码完成并被推进到流水线中先执行；

### 写回
对于写回模块，经常采用的手段是只把一个存储更新请求提交给缓存管理机制并不等待其最终完成，这个存储请求会依CPU的缓存架构设计制定的规则最终异步刷新到主存（具体的策略，视CPU架构的不同存在着不同的差异。

以Intel的Core系列CPU为例，从第一代的Nehalem 到第八代的Coffee Lake, 各代间都通常有一些Cache体系上的调整，会带来相应的存储更新方面的差异）， 这会让向内存的写操作体现出来一定的异步性。

### 影响

这些机制的存在，会导致程序在多线程条件下运行时出现一些“反直觉”（counter-intuitive）的结果。例如下面的这一段伪代码清单中所示的内容。
```java
// 假定所有变量都实现正确初始化
class CpuReorderDemo{
	int a=0;
	boolean b=true;
	
	//
	void writer(){
		a=10; //(1)
		b=false; //(2)
	}
	
	//
	void reader(){
		while(b);  //(3)
		assert(a==10); //(4)
	}
}
```