#Index 

# 索引建立原则
## 1、索引列的类型尽量小
- 尽量让索引列使用较小的类型，比如能使用 INT 就不用 BIGINT，

**因为**
1. 数据类型越小，在查询时进行的**比较操作越快（CPU层次)**
2. 数据类型越小，**索引占用的存储空间就越少**，在一个数据页内就可以放下更多的 key；
	1. **降低索引树的高度**，从而减少磁盘 I/O 带来的性能损耗；
	2. 可以把**更多的数据页缓存在内存中**，从而加快读写效率。
3. 对于表的主键来说更加适用：
	1. 不仅是聚簇索引中会存储主键值；
	2. 所有的**二级索引的节点都会存储记录的主键值**，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O。

## 2、索引的选择离散性高的
创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality)和数据表的记录总数（N）的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

很差的索引选择性就是列中的数据重复度很高，比如性别字段，正常情况下只有两种可能。那么我们在查询时，即使使用这个索引，依然可能查出一半的数据。


### hash字段作为索引

hash冲突可能性很小，可用作索引，但是hash索引缺陷也很明显：

1. 需要额外维护hash字段；
2. 哈希算法的选择决定了哈希冲突的概率，不良的哈希算法会导致重复值很多；
3. 不支持范围查找。

### 为索引开始的部分字符添加前缀索引

该方式可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。一般情况下我们需要保证某个列前缀的选择性也是足够高的，以满足查询性能。（尤其对于BLOB、TEXT或者很长的VARCHAR类型的列，应该使用前缀索引，因为MySQL不允许索引这些列的完整长度）。

关键在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间)。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。


前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

倒序存储数据，用于后缀索引

有时候后缀索引 (suffix index)也有用途（例如，找到某个域名的所有电子邮件地址)。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器或者应用程序自行处理来维护索引。

## 3、只为用于搜索、排序或分组的列创建索引
也就是说，只为出现在WHERE 子句中的列、连接子句中的连接列创建索引，而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引。又或者为出现在ORDER BY或GROUP BY子句中的列创建索引，比如：

```
SELECT * FROM ttrd_otc_trade ORDER BY create_time, update_time,trade_time;
```
查询的结果集需要先按照create_time值排序，如果记录的create_time值相同，则需要按照update_time来排序，如果update_time的值相同，则需要按照trade_time排序。回顾一下联合索引的存储结构，index_create_update_trade索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

当然ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY trade_time,update_time, create_time的顺序，那也是用不了B+树索引的。

```sql
SELECT create_time, update_time,trade_time FROM order_exp GROUP BY  create_time, update_time,trade_time;
```

这个查询语句相当于做了3次分组操作：

先把记录按照create_time值进行分组，所有create_time值相同的记录划分为一组。
将每个create_time值相同的分组里的记录再按照update_time的值进行分组，将update_time值相同的记录放到一个小分组里。
再将上一步中产生的小分组按照trade_time的值分成更小的分组。
然后针对最后的分组进行统计，如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的index_create_update_trade索引中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，所以可以直接使用B+树索引进行分组。和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致。

## 4、主键选择少改变的列
主键是按照聚集索引物理排序的，如果主键频繁改变(update)，物理顺序会改变，MySQL要不断调整B+树，并且中间可能会产生页面的分裂和合并等等，会导致性能会急剧降低。

## 5、处理冗余和重复索引
MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。

**已有的索引（AGE），扩展为（AGE,ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。**

解决冗余索引和重复索引的方法很简单，删除这些索引就可以，但首先要做的是找出这样的索引。

### 6、删除未使用的索引

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。


# 索引设计—三星索引
## 三星索引概念
对于一个查询而言，一个三星索引，可能是其最好的索引。

如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级。

三星索引概念是在《Rrelational Database Index Design and the optimizers》 一书中提出来的。原文如下：

```
<!-- 如果索引能将相关的记录放到一起则获得一星 -->
The index earns one star if it places relevant rows adjacent to each other,  

<!-- 如果索引中的数据顺序和查找中的排列顺序一致则获得二星 -->
a second star if its rows are sorted in the order the query needs, 

<!-- 如果索引中的列包含了查询中需要的全部列则获得三星 -->
and a final star if it contains all the columns needed for the query.

```

### 一星
- 让索引片尽量变窄，索引列与 where 后面的条件匹配越多，最终扫描的数据行也是越小。
- 让索引片尽量变窄，即索引的扫描范围越小越好。

### 二星
- 当查询需要排序，group by、 order by，如果查询所需的顺序与索引是一致的（索引本身是有序的），可以不用再另外排序了；
- 一般来说排序可是影响性能的关键因素。

### 三星
- 如果这个查询所需返回的所有列都包含在索引列（包括 where 子句 和 select 子句中所需的列，也就是覆盖索引）；
- 查询就不再需要回表了，减少了查询的步骤和IO请求次数，性能几乎可以提升一倍。

## 示例
```sql
create table student(
    `num` int,
    `name` varchar(10),
    `enname` varchar(10),
    `sex` int,
    `age` int,
    `class` varchar(10)
);

create index idx_stu on customer(class,name,enname,num);

```

对于下面的 SQL 而言，这是个三星索引
```sql
select num,name from student where name =’xx’ and class =’yy’ order by enname;
```

1. 第一颗星：where 中 name 和 class 字段能够过滤很多数据，符合一星。
2. 第二颗星：order by 的 enname 字段在组合索引中且是索引自动排序的，符合二星。
3. 第三颗星：select 中的 num字段、enname字段在组合索引中存在，符合三星；

### 示例2

```sql
CREATE TABLE student (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL,
  `sex` int(11) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;

```

对于下面的SQL和索引而言，达不成三星索引

```sql
create index idx_stu on customer(name,sex,age);

select name,sex,age from student where name like 'zhang%' and sex =1 ORDER BY age

```

1. 第一颗星：查询列根据最左前缀可以过滤很多数据，满足；
2. 第二颗星：**不满足，name 采用了范围匹配，sex 是过滤列，age 列无法保证有序的**；
3. 第三颗星：存在覆盖索引，满足。
4. 此时索引(user_name,sex,age)，不能满足三星索引中的第二颗星（排序）。

# 参考
1. [浅谈如何设计MySQL索引](https://blog.csdn.net/qq_44377709/article/details/122076072)