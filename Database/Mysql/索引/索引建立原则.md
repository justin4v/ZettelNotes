#Index 

# 索引建立原则
## 1、索引列的类型尽量小
我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TTNYINT、NEDUMNT、INT、BIGTNT这么几种，它们占用的存储空间依次递增，这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用NEDIUMINT就不要使用INT，

这是因为:

数据类型越小，在查询时进行的比较操作越快（CPU层次)
数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

该策略对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。

## 2、索引的选择离散性高的
创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality)和数据表的记录总数（N）的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

很差的索引选择性就是列中的数据重复度很高，比如性别字段，正常情况下只有两种可能。那么我们在查询时，即使使用这个索引，依然可能查出一半的数据。


### hash索引

但是hash索引缺陷也很明显：

需要额外维护hash字段；
哈希算法的选择决定了哈希冲突的概率，不良的哈希算法会导致重复值很多；
不支持范围查找。

### 为索引开始的部分字符添加前缀索引

该方式可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。一般情况下我们需要保证某个列前缀的选择性也是足够高的，以满足查询性能。（尤其对于BLOB、TEXT或者很长的VARCHAR类型的列，应该使用前缀索引，因为MySQL不允许索引这些列的完整长度）。

关键在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间)。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。


前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

倒序存储数据，用于后缀索引

有时候后缀索引 (suffix index)也有用途（例如，找到某个域名的所有电子邮件地址)。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器或者应用程序自行处理来维护索引。

## 3、只为用于搜索、排序或分组的列创建索引
也就是说，只为出现在WHERE 子句中的列、连接子句中的连接列创建索引，而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引。又或者为出现在ORDER BY或GROUP BY子句中的列创建索引，比如：

```
SELECT * FROM ttrd_otc_trade ORDER BY create_time, update_time,trade_time;
```
查询的结果集需要先按照create_time值排序，如果记录的create_time值相同，则需要按照update_time来排序，如果update_time的值相同，则需要按照trade_time排序。回顾一下联合索引的存储结构，index_create_update_trade索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

当然ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY trade_time,update_time, create_time的顺序，那也是用不了B+树索引的。

```sql
SELECT create_time, update_time,trade_time FROM order_exp GROUP BY  create_time, update_time,trade_time;
```

这个查询语句相当于做了3次分组操作：

先把记录按照create_time值进行分组，所有create_time值相同的记录划分为一组。
将每个create_time值相同的分组里的记录再按照update_time的值进行分组，将update_time值相同的记录放到一个小分组里。
再将上一步中产生的小分组按照trade_time的值分成更小的分组。
然后针对最后的分组进行统计，如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的index_create_update_trade索引中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，所以可以直接使用B+树索引进行分组。和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致。

4、主键选择少改变的列
主键是按照聚集索引物理排序的，如果主键频繁改变(update)，物理顺序会改变，MySQL要不断调整B+树，并且中间可能会产生页面的分裂和合并等等，会导致性能会急剧降低。

5、处理冗余和重复索引
MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。



# 参考
1. [浅谈如何设计MySQL索引](https://blog.csdn.net/qq_44377709/article/details/122076072)