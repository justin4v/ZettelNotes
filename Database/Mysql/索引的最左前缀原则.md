#Mysql #Index #Leftmost-prefix

# 介绍
- MySQL可以创建联合索引(即, 多列的索引). 一个索引可以包含最多16列. 
- 某些数据类型, 可以索引列的前缀(如Blob和Text类型, 索引前几位就可以, 如 INDEX(blob_col(10))
- 如果创建一个联合索引, 包含索引最左前缀（leftmost prefix）的查询都会被优化器(optimizer ) 用索引优化：
	- 如联合索引 (col1, col2, col3) 的所有最左前缀有：(col1), (col1, col2), (col1, col2, col3)；
	- 包含这些列的查询都会启用索引查询.  
- 不包含最左前缀里的查询都不会启用索引, 即使包含了联合索引里的部分列也不行：
	- 如(col2), (col3), (col2, col3) 都不会启用索引去查询.  
- **(col1, col3) 会启用 (col1) 的索引查询**
- 如果一个联合索引存在于col1和col2, 相应的列会被直接抓取.；
- 如果是分为单独的索引 分别存在于col1和col2, 优化器会尝试利用*索引联合优化*，或者尝试去寻找包含最多列, 最大限制的索引, 并利用该索引去抓取列.

## 示例
假设有如下表定义:

```sql
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```

- 索引 `name` 是一个包含了 `last_name` 和 `first_name` 列的索引;
- `name` 可用于为 `last_name` 和 `first_name` 组合指定一个已知范围内的查询;
- 也可用于只指定了 `last_name` 列值的查询, 因为它是*索引 `name` 的最左前缀*；
-  索引 `name` 可用于下列查询（都包含索引的最左前缀 `last_name`）：
```sql
-- 包含索引的最左前缀 leftmost prefix
SELECT * FROM test WHERE last_name='Jones';

SELECT * FROM test
  WHERE last_name='Jones' AND first_name='John';

SELECT * FROM test
  WHERE last_name='Jones'
  AND (first_name='John' OR first_name='Jon');

SELECT * FROM test
  WHERE last_name='Jones'
  AND first_name >='M' AND first_name < 'N';
```

- 索引 `name` 不能用于如下查询：

```sql
SELECT * FROM test WHERE first_name='John';

SELECT * FROM test
  WHERE last_name='Jones' OR first_name='John';
```

  
  
# 替代联合索引
- 可以用一个 *Hash 值列，以替代联合索引*；
- 如果 Hash 值列简短唯一，且*被索引*, 就可能比较很"宽"的、由多个列构成的联合更快；
- MySQL 里可以按如下使用 Hash 列:

```sql
SELECT * 
FROM tbl_name
WHERE 
  hash_col=MD5(CONCAT(val1,val2))
  AND col1=val1 AND col2=val2;
```



# 参考
1. [MySQL :: MySQL 8.0 Reference Manual :: 8.3.6 Multiple-Column Indexes](https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html)
2. [索引联合优化]([MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.3 Index Merge Optimization](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html))