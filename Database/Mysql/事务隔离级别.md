#Mysql #Transaction
# MySQL 事务

MySQL  **InnoDB 引擎**支持事务，**MyISAM 不支持事务**。

# 事务
- 一组原子性的 SQL 查询，**要么就是全部成功，要么全部失败**。

## 示例
假设一个银行的数据库有两张表：
- *支票（checking ) 表*和*储蓄（savings ）表*。
- 要从用户 Jane 的支票账户转移 200 美元到她的储蓄账户;
- 至少需要三步：
	1. 检查支票账户的余额是否高于 200 美元；
	2. 从支票账户余额中减去 200 美元。
	3. 在储蓄账户余额中增加 200 美元。
- 上述三个步骤必须打包在一个事务(transaction)中，任何一个步骤失败，必须回滚所有的步骤。

## 实际语句
- 用 `START TRANSACTION` 语句开始一个事务;
- 然后要么使用 `COMMIT` 提交事务将修改的数据持久保留;
- 要么使用 `ROLLBACK` 撤销所有的修改。
```sql
1. START TRANSACTION; 
2. SELECT balance FROM checking WHERE customer_id = 10233276; 
3. UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276; 
4. UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276; 
5. COMMIT;
```


# ACID
事务具有 ACID特性：
- **原子性**（Atomicity）；
- **一致性**（Consistency）；
- **隔离性**（Isolation）；
- **持久性**（Durability）。


## 脏读
- 读到了其他事务未*提交（临时）数据*，这些数据可能回滚，可能提交。

**现象**
- 当前线程查询到了其他事务的中间过程的数据（临时数据）
- *写锁没有排它（排斥读锁）*。

## 不可重复读

- 在**同一事务内，不同的时刻读到的同一批数据可能是不一样**。
- 该数据可能受到了其他事务的影响。

**现象**
- 在更新数据前读到的数据和更新过程中读到的数据不同。
如更新事务：
```sql
update test set version=2 where id = 1 and version = 0;
```

事务开始前查询`id`为1的数据`version=0`，在更新过程中、提交之前某个时间，`version`变成了1（有其他线程同时在更新）。

- 同时有两个线程写数据库。

### 可重复读实现
*当前事务更新数据前，保存一份数据的快照，更新过程中读取快照*


## 幻读
- 幻读是针对数据**插入（INSERT）** 操作：

- 假设事务A对某些行的内容作了更改，但是还未提交；
- 事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了。

**现象**
当前线程正在删除（更新）某条记录，提交之前，查询发现*相同的记录又出现了*，好像刚刚的**更改未起作用**，让人感觉出现了幻觉，这就叫幻读。
- 同时有两个线程写数据库


# 事务隔离级别

SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
1. **读未提交（READ UNCOMMITTED）** ——RU
2. **读提交 （READ COMMITTED）** —— RC
3. **可重复读 （REPEATABLE READ）** —— RR
4. **串行化 （SERIALIZABLE）** ——SE

- 从上往下，**隔离强度逐渐增强，性能逐渐变差**；
- **可重复读**是 MySQL 的默认级别。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读提交   | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |

串行化解决了全部这 3 个问题


## 如何设置隔离级别

我们可以通过以下语句查看当前数据库的隔离级别，通过下面语句可以看出我使用的 MySQL 的隔离级别是 REPEATABLE-READ，也就是可重复读，这也是 MySQL 的默认级别。

```sql
# 查看事务隔离级别 5.7.20 之前
show variables like 'transaction_isolation';
SELECT @@transaction_isolation

# 5.7.20 之后
SELECT @@tx_isolation
show variables like 'tx_isolation'

# 结果
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
```


**修改隔离级别的语句**：
```sql
set [作用域] transaction isolation level [事务隔离级别]

SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}。
```

其中作用于可以是 SESSION 或者 GLOBAL：GLOBAL 是全局的，而 SESSION 只针对当前回话窗口。

隔离级别是 {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} 这四种，不区分大小写。

比如下面这个语句的意思是设置全局隔离级别为读提交级别。

```sql
mysql> set global transaction isolation level read committed; 
```



## MySQL 中执行事务

事务的执行过程：
1. 以 begin 或者 start transaction 开始事务语句；
2. 最后要执行 commit 或 rollback 操作，事务结束；
3. 事务*真正开始于 begin 命令之后的第一条语句*。

例如下面示例中，select * from xxx 才是事务的开始，

```sql
begin;
select * from xxx; 
commit; -- 或者 rollback;
```

另外，通过以下语句可以查询当前有多少事务正在运行。
```sql
select * from information_schema.innodb_trx;
```

# 隔离级别的实现
1. MySQL 事务隔离其实是**依靠锁实现**的，但锁也会带来性能的损失；

接下来用一张表验证事务，表结构如下：

```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `age` tinyint(4) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
```

初始只有一条记录：

```shell
mysql> SELECT * FROM user;
+----+-----------------+------+
| id | name            | age  |
+----+-----------------+------+
|  1 | 古时的风筝       |  1   |
+----+-----------------+------+
```

## 读未提交
**任何事务对数据的修改都会第一时间暴露给其他事务**，即使事务还没有提交。

### 验证
1. 首先设置全局隔离级别为读未提交。

```sql
set global transaction isolation level read uncommitted;
```

2. 设置完成后，只对之后的 session 起作用，对已经启动 session 无效。如果用 shell 客户端那就要重新连接 MySQL，如果用 Navicat 那就要创建新的查询窗口。
	1. 启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，不提交；
	2. 在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了；
	3. 事务A还没有提交，而事务B有可能拿着已经修改过的 age=10 去进行其他操作了。

在事务B进行操作的过程中，如果事务 A 进行了**事务回滚**操作，事务B得到的就是脏数据了。
读未提交示意：
![img](读未提交.png)

## 读提交

1. **一个事务只能读到其他事务已经提交过的数据**，可以解决脏读的问题。
2. 读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。

### 验证
把事务隔离级别改为读提交级别。
```sql
set global transaction isolation level read committed;
```

1. 同样开启事务A和事务B两个事务，在事务A中使用 update 语句将 id=1 的记录行 age 字段改为 10；
2. 此时，在事务B中使用 select 语句进行查询，我们发现在事务A提交之前，事务B中查询到的记录 age 一直是1；
3. 直到事务A提交，此时在事务B中 select 查询，发现 age 的值已经是 10 了。

- 读提交隔离级别解决了脏读的问题。
- 但是**同一事务中(如本例中的查询事务B)在不同时刻，查询出来的内容是不一致的（更新事务A，提交前后数据不一致）**。
- **每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。**

读提交示意：
![img](读提交.png)


## 可重复读
- **事务不会读到其他事务对已有数据的修改，即使其他事务已提交**；
- 事务*开始时读到的数据和在事务提交前的任意时刻读到数据是一样的*。
- 但对于其他事务**新插入**的数据还是可以读到的，这就是**幻读**问题。

设置隔离级别为可重复读级别。
```sql
set global transaction isolation level repeatable read;
```

![[可重复读.png]]



对于新插入的行记录，有可能存在幻读。我们看一下这个过程：

- 事务A开始后，执行 update 操作，将 age = 1 的记录的 name 改为“风筝2号”；
- 事务B开始后，在事务执行完 update 后，执行 insert 操作，插入记录 age =1，name = 古时的风筝，这和事务A修改的那条记录值相同，然后提交。
- 事务B提交后，事务A中执行 select，查询 age=1 的数据，这时，会发现多了一行，并且发现还有一条 ”name = 古时的风筝“，”age = 1“ 的记录，这其实就是事务B刚刚插入的，这就是幻读。

![[幻读.png]]

### 注意
**MySQL 的可重复读隔离级别其实解决了幻读问题**


## 串行化

- 串行化解决了脏读、可重复读、幻读的问题，但是效率最差；
- 它将事务的执行变为顺序执行，相当于**单线程**，后一个事务的执行必须等待前一个事务结束。

# MySQL事务隔离实现

1. 读未提交，不加锁，可以理解为没有隔离。
2. 串行化：
	1. 读的时候加**共享锁**，其他事务可以并发读，但是不能写。
	2. 写的时候加**独占锁**，其他事务不能并发写也不能并发读。
3. 读提交和可重复读。这两种隔离级既要允许一定的并发，又想要兼顾的解决问题。

## 实现可重复读
**MySQL 采用了 MVCC (多版本并发控制，Multi-Version Concurrency Control) 的方式**实现可重复读。

### MVCC 实现
1. 数据库表中一行记录实际上有**多个版本**；
2. 每个版本的记录除了有数据本身外，还要有一个**表示版本的字段row trx_id**，字段的值是对应的**事务 id**；
3. 事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。

![img](MVCC示意.png)
上图中一行记录现有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。

### 快照
- **快照**，又叫做**一致性视图**，是可重复读和不可重复读的关键；
- **可重复读**是在事务开始的时候生成一个当前事务**全局性的快照**，而**读提交**则是每次执行语句的时候都**重新生成快照**。

一个快照能够读到哪些版本数据，要遵循以下**规则**：
1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；


## 并发写问题

两个事务，对同一条数据做修改：
- 事务A执行 update 操作，要对所修改的行加**行锁**，锁会在提交之后才释放；
- 在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务 A 持有，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行。
如下图：
![[并发写加锁.png]]

加锁的过程要分**有索引和无索引**两种情况，比如下面这条语句
```sql
update user set age=11 where id = 1
```

### 有索引加锁
id 是这张表的主键，是**有索引**的情况，**MySQL 直接就在索引数中找到了这行数据，然后加上行锁就可以了**。

### 无索引加锁
下面这条语句

```sql
update user set age=11 where age=10
```

- 表中并**没有为 age 字段设置索引**， MySQL 无法直接定位到这行数据。
- **MySQL 会为这张表中所有行加行锁**，**在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行**。

虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以，如果是大表的话，建议合理设计索引。

## 解决幻读
MySQL 已经在可重复读隔离级别下解决了幻读的问题。

**并发写问题的解决方式就是行锁**，而**解决幻读用间隙锁**，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 **Next-Key 锁**。

### 示例
1. 假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。
2. 在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。
3. 假设如下图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁。

![img](间隙锁.png)


### 间隙锁加锁

![img](间隙锁-加锁过程.png)

图中事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。

1. 当事务A执行`update user set name='风筝2号’ where age = 10;` 的时候，由于条件 where age = 10 ，数据库在 age =10 的行上添加了行锁；
2. 而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁；
3. 而导致事务B插入操作无法完成，只能等待事务A提交。
4. 大于等于30的记录则不受影响，解决了幻读问题。
5. 如果 age 不是索引列，数据库会为*整个表加上间隙锁*。

如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。

# 总结

- MySQL 的 InnoDB 引擎才支持事务，其中**可重复读**是默认的隔离级别；
- 读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行；
- 读提交解决了脏读问题；
- **行锁**解决了并发更新的问题。
-  MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 **Next-Key 锁**实现的。