#MVCC #InnoDB

# 总结
- 使用*版本（InnoDB 中表现为 DB_TRX_ID）标记数据*，避免对数据加锁：
	- 以解决*并发*下数据查询可能会出现的问题（脏读、不可重复读、幻读）。
	- 满足数据库事务的 ACID 特性（关键是一致性 consistency 和隔离性 Isolation）。
- 版本选择逻辑转化为简单的 ID 数值比较。
- 联想*乐观锁也用 version 标记数据*：
	- 但是 *MVCC 为了保证读取的一致性*，目的是**读取**；
	- 乐观锁最终是为了*保证写入的正确和有序性*，目的是**写入**。
	- 乐观锁实际上也*没有加锁*，只是校验了数据版本。

# 简介
- MVCC 使得*数据库读不会对数据加锁*，*普通的 SELECT 请求不会加锁*，提高了数据库的并发处理能力。
- MVCC只在 *REPEATABLE READ* 和 *READ COMMITIED* 两个隔离级别下工作。
- READ UNCOMMITIED *总是读取最新的数据行*，而不是符合当前事务版本的数据行。
- 而 SERIALIZABLE 则*会对所有读取的行都加锁*。
- 借助MVCC，数据库可以实现RC，RR等隔离级别；
- 用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性）

# InnoDB MVCC 实现
Mysql 实现依赖的是 
- *undo log* 
- *read view* 
- 每行数据的两个隐藏列：*事务 ID（DB_TRX_ID，递增）*，*回滚指针（DB_ROLL_PT）*
- 如果没有设置主键还会多添加： *主键（ROW_ID）*
- 查询时需要用*当前事务id和行记录的事务id进行比较*。

保存这两个额外事务编号，使大多数读操作都可以不用加锁。
使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

## undo log
undo log分为：**insert undo log** 和 **update undo log**
### insert undo log
- insert 操作中产生的 undo log；
- insert 操作记录只对当前事务本身可见，对于其他事务不可见；
- insert undo log 在事务提交后直接删除而不需要进行 purge 操作。

> purge的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收undo pages

数据库 Insert时的数据初始状态：
![[InnoDB Insert的MVCC状态.png]]

### update undo log

- update 或 delete 操作中产生的 undo log。
- 会对已经存在的记录产生影响，因此 update undo log 不能在事务提交时就进行删除；
- 将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。

数据第一次被修改时
![[Update log第一次修改.png]]

## ReadView
 - MVCC 中**RC(READ COMMITTED)** 和 **RR(REPEATABLE READ)** 两种隔离级别的*核心是判断所有版本中哪个版本是当前事务可见*。
 - InnoDB 设计了 **ReadView** 的概念：
	 -  **ReadView** 主要包含*当前系统中有哪些活跃的读写事务*；
	 - 将它们的事务 id 放到一个列表**m_ids**。

### 版本可见判断逻辑
查询时的版本链数据是否看见的判断逻辑：
- *被访问版本数据的 trx_id 属性值小于 m_ids 列表中最小的事务 id*（最早的事务）：
	- 生成该版本数据的事务在 ReadView 生成前已经提交，所以该版本可以被当前事务访问。
- *被访问版本数据的 trx_id 属性值大于 m_ids 列表中最大的事务id*（最晚的事务）：
	- 生成该版本的事务在 ReadView 生成后才生成，所以该版本不可以被当前事务访问。
- *被访问版本数据的 trx_id 属性值在 m_ids 列表中最大的事务id和最小事务id之间*：
	- *trx_id 在 m_ids 列表中*，创建 ReadView 时生成该版本数据的事务还是*活跃*的，该版本不可以被访问；
	- *trx_id 不在 m_ids 列表中*，说明创建 ReadView 时生成该版本数据的事务已经*被提交*，该版本可以被访问

# RC和RR
- RC 级别的事务在每次查询开始时都会生成一个独立的 ReadView(m_ids列表)
- RR 级别的事务只在在事务开始后第一次读取数据时生成一个 ReadView(m_ids列表)

## 示例
- 假设之前插入该行的事务`C` `ID` 为 `100`，age 值为 10；
- 事务 `A` 的 `ID` 为 `200`，更新 age 为 20；
- 事务 `B` 的 `ID` 为 `300`，查询 age 值。

### RC
- 当事务 `A` 未提交时，事务 `B` 进行查询，此时生成 `ReadView` 的 `m_ids` 为 [200，300]（事务A 和B）；
- 最新版本的 `trx_id` 为 `200`（事务A，正在更新），处于 `m_ids`中，则该版本记录不可被访问；
- 查询版本链得到上一条记录的 trx_id 为 `100`（事务 C 结果），小于 `m_ids`的最小值 `200`，因此可以被访问。
- 此时事务 `B` 就查询到值 `10`（事务 C 结果） 而非 `20`。
- 事务 `A` 提交之后，事务 `B` 进行查询，此时会**重新生成 `ReadView`** 的 `m_ids` 为 [300]；
- 最新的版本记录中 `trx_id` 为 `200`（事务A结果），小于 `m_ids` 的最小值 `300`，因此可以被访问到，此时事务 `B` 就查询到 `20`。

### RR
- `RR` 下生成 `ReadView` 是在事务开始时生成的，m_ids 为 [200,300]，后面不发生变化；
- 即使事务 `A` 提交了，`trx_id` 为 `200` 的记录依旧处于 `m_ids` 中，不能被访问；只
- 能访问版本链中的记录 `10`（事务C 结果）。