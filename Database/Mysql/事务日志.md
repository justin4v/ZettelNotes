#Mysql #事务日志 #Problem-and-Solutions #Write-Ahead-Log
# 目的
- 存储引擎在*修改表中数据*时：
	1. *只需要修改其内存拷贝*；
	2. 再把行为记录事务日志中；
	3. 事务日志持久化到硬盘，后台进程后续执行事务，持久化数据到硬盘；
	4. *不用每次都将修改的数据本身持久到磁盘*。
- 日志采用*追加（append）* 的方式：
	1. 因此写日志是*磁盘上一块区域内的顺序 I/O*；
	2. 而不像随机 I/O 要在磁盘多个地方写入；
	3. 所以采用事务日志响应快的多。
- 事务日志持久以后，内存中被修改的数据在*后台可以慢慢刷回到磁盘*。
- 如果数据修改事务已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时*系统崩溃*，存储引擎在重启时能*依据日志自动恢复修改的数据*。

目前*大多数存储引擎都是这样实现（Redis AOF 备份）*，称为**预写式日志**（*Write-Ahead Log，WAL），修改数据需要*写两次磁盘（先写日志，再写数据）*。

# 优势
InnoDB  使用日志：
- *减少提交事务时的开销（只持久化到日志）*。
- 日志中记录了事务，无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。
- 事务修改的数据和索引通常会映射到表空间的随机位置，所以变更到磁盘需要随机 IO。 *随机IO比顺序IO昂贵*。
- *把随机 IO 变成顺序 IO（顺序读写日志）*。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB 可以*重放日志并且恢复已经提交的事务*。
- 后台线程不断刷新变更到数据文件。可以*批量组合写入*，使得数据写入更有顺序，以提高效率。

# 类型
**重做日志 redo log** 和 **回滚日志undo log**

## redo log
- 重做日志；
- 实现*持久化（Durability）和原子性（Atomicity）*；
- InnoDB 存储引擎中 *redo log* 和 *日志缓冲(InnoDB Log Buffer)* 实现事务日志。
	1.  事务开启时，事务中的操作，*都会先写入存储引擎的日志缓冲*中；
	2. 事务*提交之前*，*缓冲中日志提前刷新到磁盘上持久化*，称为 *日志先行(Write-Ahead Log)*。
	3. 事务*提交之后*，在 *Buffer Pool 中映射的数据文件才慢慢刷新到磁盘*。
	4. 如果数据库崩溃或者宕机，系统重启进行恢复时，可以*根据 redo log 中记录的日志，把数据库恢复到崩溃前的一个状态*。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。
- 系统启动的时候，已经*为 redo log 分配了一块连续的存储空间*，以顺序追加的方式记录 Redo Log，通过顺序IO来改善性能。
- 所有的事务共享redo log的存储空间，它们的 Redo Log 按语句的执行顺序，依次交替的记录在一起。


## undo log
-  回滚日志
-  *实现一致性（Consistency）*
- 服务于*事务的回滚*。
	1. 事务执行的过程中，除了记录 redo log，还会记录一定量 undo log。
	2. undo log 记录了*数据在每个操作前的状态*；
	3. 如果事务需要回滚，可以根据 undo log 进行回滚操作。
	4. 单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。
    
    Undo 记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）
    
# 总结
- 二种日志均可以视为一种恢复操作 ;
- redo_log 是恢复提交事务修改的页操作 ;
- undo_log 是回滚行记录到特定版本。
- 二者记录的内容也不同：
	- redo_log 是物理日志，记录页的物理修改操作；
	- 而undo_log是逻辑日志，根据每行记录进行记录。