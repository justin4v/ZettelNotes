#Mysql #事务日志
# 目的
- 存储引擎在*修改表中数据*时：
	1. *只需要修改其内存拷贝*；
	2. 再把行为记录事务日志中；
	3. 事务日志持久化到硬盘，后台进程后续执行事务，持久化数据到硬盘；
	4. *不用每次都将修改的数据本身持久到磁盘*。
- 日志采用*追加（append）* 的方式：
	1. 因此写日志是*磁盘上一块区域内的顺序 I/O*；
	2. 而不像随机 I/O 要在磁盘多个地方写入；
	3. 所以采用事务日志响应快的多。
- 事务日志持久以后，内存中被修改的数据在*后台可以慢慢刷回到磁盘*。
- 如果数据修改事务已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时*系统崩溃*，存储引擎在重启时能*依据日志自动恢复修改的数据*。

目前*大多数存储引擎都是这样实现（Redis AOF 备份）*，通常为**预写式日志**（*Write-Ahead Logging*），修改数据需要*写两次磁盘（先写日志，再写数据）*。

# 优势
InnoDB  使用日志：
- 减少提交事务时的开销。
- 日志中记录了事务，无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。
- 事务修改的数据和索引通常会映射到表空间的随机位置，所以变更到磁盘需要随机 IO。 随机IO比顺序IO昂贵得多。
- 把随机 IO 变成顺序 IO（顺序读写日志）。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB 可以*重放日志并且恢复已经提交的事务*。
- 后台线程不断刷新变更到数据文件。可以批量组合写入，使得数据写入更有顺序，以提高效率。



# 类型
**重做日志redo**和**回滚日志undo**
-   **redo log（重做日志**） 实现持久化和原子性
    
    在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。
    
    在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。
    
-   **undo log（回滚日志）** 实现一致性
    
    undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。
    
    Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）
    

二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。