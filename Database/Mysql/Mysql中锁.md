#Mysql #Lock #Problem-and-Solutions 
# 解决问题
1. 并发控制，加锁策略？
2. Mysql 幻读的解决？
# 策略
- 乐观锁与悲观锁是两种*并发控制的思想*；
- 可解决数据库中*丢失更新*问题

## 乐观锁
- 乐观地*假定大概率不会发生更新冲突*；
- 访问、处理数据过程中*不加锁*，只在*更新数据时，再根据版本号或时间戳判断是否有冲突*；
- 有冲突则处理，无则提交事务。
- 用*数据版本（Version）机制*实现，这是乐观锁最常用的一种实现方式(另外一种是 [[CAS]])

## 悲观锁
- 悲观地假定*大概率会发生并发更新冲突*；
- 访问、处理数据前*加排他锁*；
- 在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。


# 锁模式(InnoDB 三种行锁算法)
## 记录锁(Record Locks)
- 单行记录锁。
- 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
	1. 在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行；
    ```mysql
	-- 锁定 id=1 的行
    SELECT * FROM table WHERE id = 1 FOR UPDATE;
    ```
    2. 通过 *主键索引* 与 *唯一索引* 进行 UPDATE 操作时，也会对该行数据加记录锁：
    ```mysql
    -- id 列为主键列或唯一索引列
	-- 锁定 id =1 的行
    UPDATE SET age = 50 WHERE id = 1;
    ```
    
## 间隙锁（Gap Locks）
- *范围条件*而不是相等条件检索数据；
- 并请求共享或排他锁时，InnoDB 会给*符合条件的、已有数据记录的索引项加锁*。
- 对于*键值在条件范围内但并不存在*的记录，叫做*间隙*。InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。
- 对索引项之间的“间隙”加锁，*锁定记录的范围*（第一条记录前的间隙或最后一条将记录后的间隙），*不包含索引项本身*。
- 其他事务不能在锁范围内插入数据，*防止了别的事务新增幻影行*。
- 间隙锁基于非唯一索引，它锁定一段范围内的索引记录。
- 间隙锁基于`Next-Key Locking` 算法：**间隙锁锁住的是一个区间，而不仅仅是区间中的每一条数据**。
- 目的是为了防止同一事务的两次当前读，*出现幻读*的情况。
    
    ```mysql
	-- 锁定 (1,10) 的间隙
	-- 开区间
    SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;
    ```
    
    - 所有`（1，10）`区间内的记录行都会被锁住；
    - 所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞；
    - 1 和 10 两条记录行并不会被锁住。
    
## 临键锁(Next-key Locks)
- *记录锁与间隙锁的组合*，封锁范围既包含索引记录，又包含索引区间。
- 主要目的时候为了避免**幻读**(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。
- 可以理解为一种特殊的**间隙锁**，也可以理解为一种特殊的**算法**。
-  每个数据行上的索引列（非唯一索引）上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。
- `InnoDB` 中*行级锁是基于索引实现*，*临键锁只与非唯一索引列有关*，在*唯一索引列（包括主键列）上不存在临键锁*。
- 对于行的查询，都是采用该方法

### select for update 有什么含义，会锁表还是锁行还是其他？

- for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
- MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。
- 排他锁包含行锁、表锁。
- InnoDB 这种实现特点意味着：
	- 通过*索引条件检索数据*，InnoDB *才使用行级锁*；
	- 否则，*InnoDB 将使用表锁*；
1. 明确指定主键，并且有数据：row lock
```mysql
SELECT * FROM products WHERE id='3' FOR UPDATE;
SELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;
```

2. 明确指定主键，若无数据：无 lock
```mysql
SELECT * FROM products WHERE id='-1' FOR UPDATE;
```

3. 无主键：table lock
```mysql
SELECT * FROM products WHERE name='Mouse' FOR UPDATE;
```

4. 主键不明确：table lock
```mysql
SELECT * FROM products WHERE id<>'3' FOR UPDATE;
```

5. 主键不明确：table lock
```mysql
SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;
```

	
# 具体加锁情况
### 有索引加锁
- id 是这张表的主键，是**主键索引**；
- MySQL 直接找到这行数据，然后加上行锁。

### 无索引加锁
下面这条语句
```sql
update user set age=11 where age=10
```

- 表中并**没有为 age 字段设置索引**， MySQL 无法直接定位到这行数据。
- MySQL 加表锁，然后MySQL 会*进行一遍过滤，发现不满足的行就释放锁*，最终只留下符合条件的行。

## 解决幻读
MySQL 已经在可重复读隔离级别下解决了幻读的问题。
- **解决幻读用间隙锁**，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，叫做 **Next-Key 锁**。

### 示例
1. 假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。
2. 在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。
3. 假设如下图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁。

![img](间隙锁.png)


### 间隙锁加锁

![img](间隙锁-加锁过程.png)

1. 当事务A执行`update user set name='风筝2号’ where age = 10;` 的时候，由于条件 where age = 10 ，数据库在 age =10 的行上添加了行锁；
2. 而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁；
3. 事务B插入操作无法完成，只能等待事务A提交。
4. *大于等于30的记录则不受影响*，解决了幻读问题。
5. 如果 age 不是索引列，数据库会为*整个表加上间隙锁*。不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。
