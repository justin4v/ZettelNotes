## 并发写问题

两个事务，对同一条数据做修改：
- 事务A会对所修改的行加**行锁**（独占锁），锁会在提交之后才释放；
- 如下图
![[并发写加锁.png]]

加锁的过程分**有索引和无索引**两种情况，比如下面这条语句
```sql
update user set age=11 where id = 1
```

### 有索引加锁
- id 是这张表的主键，是**有索引**；
- **MySQL 直接在索引中找到这行数据，然后加上行锁**。

### 无索引加锁
下面这条语句
```sql
update user set age=11 where age=10
```

- 表中并**没有为 age 字段设置索引**， MySQL 无法直接定位到这行数据。
- **MySQL 会为这张表中所有行加行锁**，在加上行锁后，MySQL 会*进行一遍过滤，发现不满足的行就释放锁*，最终只留下符合条件的行。

## 解决幻读
MySQL 已经在可重复读隔离级别下解决了幻读的问题。
- **解决幻读用间隙锁**，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，叫做 **Next-Key 锁**。

### 示例
1. 假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。
2. 在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。
3. 假设如下图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁。

![img](间隙锁.png)


### 间隙锁加锁

![img](间隙锁-加锁过程.png)

1. 当事务A执行`update user set name='风筝2号’ where age = 10;` 的时候，由于条件 where age = 10 ，数据库在 age =10 的行上添加了行锁；
2. 而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁；
3. 事务B插入操作无法完成，只能等待事务A提交。
4. *大于等于30的记录则不受影响*，解决了幻读问题。
5. 如果 age 不是索引列，数据库会为*整个表加上间隙锁*。不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。
