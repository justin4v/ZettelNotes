#SQL #Mysql #Optimize

# 架构和查询过程
![[Mysql架构示意.png]]

- 最上一层为客户端，处理：*连接处理、授权认证、安全*等功能。
- 中间层为 MySQL 核心服务：
	- 包括查询*解析、分析、优化、缓存、内置函数*。
	- *跨存储引擎*的功能也在这一层实现：存储过程、触发器、视图等。
- 最下一层为*存储引擎*，负责MySQL中的*数据存储和提取*

## 查询过程
![[mysql查询过程示意.png]]

## 客户端/服务端通信
- 类似“半双工”通信方式；
- 同一时刻，要么客户端向服务端发送数据，要么反过来。不能同时进行。
- 实际开发中，尽量保持查询简单且只返回必需的数据，查询中尽量 *避免使用 SELECT \* 以及加上 LIMIT 限制*。


## 查询缓存
- MySQL将结果缓存在一个引用表（类似于 HashMap）中，通过哈希值索引；
- 哈希值和查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息有关；
- 非确定性功能将导致查询不被缓存（包括临时表，用户变量，RAND（），NOW（）和UDF）。
- MySQL的查询缓存跟踪缓存中涉及的每个表，如果表的数据或结构发生变化，和表相关的所有缓存数据都将失效。
- 任何的写操作，对应表的所有缓存都失效。
- 如果查询缓存非常大或者碎片很多，缓存就可能带来很大的系统消耗。
- 不要轻易打开查询缓存，特别是写密集型应用。
- [Mysql 8.0 版本查询缓存将被移除](https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/) ：严重的可伸缩性问题（scalability issues），且很容易成为瓶颈（bottleneck）。
- 如果需要使用查询缓存，可参考 [proxysql: High-performance MySQL proxy with a GPL license](https://github.com/sysown/proxysql)
- *越靠近用户*时，缓存会带来最大的好处。

## 语法解析和预处理
- 解析 SQL 语句，并生成解析树。
- 验证语法。如是否使用错误的关键字等等。
- 预处理进一步检查解析树是否合法。如要查询的数据表和数据列是否存在等等。


## 查询优化
- 优化器将语法树转化成查询计划。
- 多数情况下，一条查询有多种执行方式；
- MySQ L使用基于成本的优化器，查询当前会话的 `last_query_cost` 得到当前查询的成本。

```sql
show status like 'last_query_cost';
```


# 查询优化
## 一般建议
- 从Explain和Profile出发；
- 用小结果集驱动大的结果集（如join中左表为*驱动表*）；
- 在索引中完成排序；
- select 最小的 Columns；
- 尽早过滤，并使用最有效的过滤条件；
- 避免复杂的JOIN和子查询。
## 常用查询
- 尽量避免where使用 != 或 <>  
- 尽量避免 where 子句用 or 连接：
	- or 连接的所有字段都有索引，索引才会生效，否则*索引失效*。
- 乱用%导致全表扫描  
- 尽量避免where子句对字段进行表达式操作  
- 尽量避免where子句对字段进行函数操作  
- 覆盖查询，返回需要的字段  
- 优化嵌套查询，关联查询优于子查询  
- 用exist代替in  
- 避免使用 '\*' , 只返回需要的字段

## 索引
- 关联字段尽量使用索引
- 查询字段尽量使用索引
- 值变化不大的字段，索引没有意义，避免建立索引
- 组合索引或复合索引，最左索引原则  
- 尽量避免全表扫描，对where及orderby的列建立索引  