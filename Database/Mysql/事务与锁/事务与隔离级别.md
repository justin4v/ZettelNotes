#Mysql #Transaction

# 事务特性实现
1. *Isolation: 加锁（写锁/独占锁）保证*
2. *Automatic 和 Durability: [[事务日志#redo log|redo log]] 保证* ;
3. *Consistency: [[事务日志#undo log|undo log]] 保证*

# MySQL事务隔离级别实现
1. *读未提交*：不加锁，可以理解为*没有隔离*。
2. *串行化*：所有操作都*加锁*实现
3. *读提交和可重复读*。*[[MVCC实现|MVCC]] + undo log/redo log*。


# SQL 并发问题
## 更新丢失 
*Lost Update*:
- 两个线程同时更新同样的数据，导致某个更新失效

## 脏读
*Dirty Reads*
- 读到了其他事务未*提交（临时）数据*，这些数据可能回滚，可能提交。

## 不可重复读
*Non-repeatable Reads*
- 在**同一事务内，不同的时刻读到的同一批数据可能是不一样**。
- 该数据可能受到了其他事务的影响。
- 在更新数据前读到的数据和更新过程中读到的数据不同。

## 幻读
*Phantom Reads*
- 幻读是针对数据**插入（INSERT）** 操作：
	- 事务A对某些行的内容作了更改，但是还未提交；
	- 事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了。
	- 事务A在提交之前，查询发现*相同的记录又出现了*，好像刚刚的**更改未起作用**，感觉出现了幻觉，称为幻读。



# ACID
- 事务：一组原子性的 SQL 查询，**要么就是全部成功，要么全部失败**。
- MySQL  **InnoDB 引擎**支持事务，**MyISAM 不支持事务**。

事务具有 *ACID 特性*：
- **原子性**（Atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚；
- **一致性**（Consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态；
- **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的；
- **持久性**（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。


# 事务隔离级别
## 背景
- SQL 事务隔离级别是为了*能最大限度的解决并发问题*

## 隔离级别
SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
1. **未提交读（READ UNCOMMITTED）** ——RU
	1. 事务对数据的**修改都会暴露给其他事务**，即便事务还没有提交。
	2. 会出现*脏读*问题；
2. **提交读 （READ COMMITTED）** —— RC，大多数流行数据库的默认事务隔离界别，如 Oracle
	1. *只能读到已经提交过的数据*
3. **可重复读 （REPEATABLE READ）** —— RR
	1. *不会读到其他事务对原有数据*的修改，即使其他事务已提交；
	2. *开始时读到的数据和在事务提交前的任意时刻读到数据是一样的*。
	3. 对其他事务**新插入**的数据还是可以读到的，这就是**幻读**问题。
4. **串行化 （SERIALIZABLE）** ——SE
	1. 将事务的执行变为顺序执行，相当于**单线程**，后一个事务的执行必须等待前一个事务结束。
	2. 解决了脏读、可重复读、幻读的问题，但是效率最差；

- 从上往下，**隔离强度逐渐增强，性能逐渐变差**；
- **可重复读**是 MySQL 的默认级别。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读提交   | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |

串行化解决了全部这 3 个问题


## 执行事务
执行过程：
1. 以 begin 或者 start transaction 开始事务语句；
2. 最后要执行 commit 或 rollback 操作，事务结束；
3. 事务*真正开始于 begin 命令之后的第一条语句*。

# 并发问题的解决
- *更新丢失*：应该完全避免。
	- 但并不能单靠数据库事务控制器解决，应用程序需要对更新的数据加必要的锁来解决。
-   *脏读、不可重复读和幻读*：都是*数据库读一致性问题*，由事务隔离机制来解决：
    - *加锁*：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    - *多版本并发控制（MultiVersion Concurrency Control，简称 **MVCC** 或 MCC）*、*多版本数据库*：
	    - 不加锁；
	    - *生成数据请求时间点的一致性快照* （Snapshot)， 并用快照提供一致性读取。
	    - 从用户的角度来看，好象数据库可以提供*同一数据的多个版本*。


# 总结

- MySQL 的 InnoDB 引擎才支持事务，其中**可重复读**是默认的隔离级别；
- 读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行；
- 读提交解决了脏读问题；
- **行锁**解决了并发更新的问题。
-  MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 **Next-Key 锁**实现的。


# 参考
1. [[MVCC实现]]