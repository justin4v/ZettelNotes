#Mysql #Transaction

# 事务
- 很多场景下，用户希望一组操作可以做为一个整体一起生效，这就是事务。
- **事务是数据库状态变更的基本单元**，包含一个或多个操作（例如多条SQL语句）

经典的转账事务，就包括三个操作：（1）检查A账户余额是否足够。（2）如果足够，从A扣减100块。（3）B账户增加100块。

事务有个基本特性：这一组操作要么一起生效，要么都不生效，事务执行过程中如遇错误，已经执行的操作要全部撤回，这就是事务的**原子性**。

如果失败发生后，部分生效的事务无法撤回，那数据库就进入了不一致状态，与真实世界的事实相左。例如转账事务从A账户扣款100块后失败了，B账户还未增加款项，如果A账户扣款操作未撤回，这个世界就莫名奇妙丢失了100块。原子性可以通过记日志（更改前的值）来实现，还有一些数据库将事务操作缓存在本地，如遇失败，直接丢弃缓存里的操作。

事务只要提交了，它的结果就不能改变了，即使遇到系统宕机，重启后数据库的状态与宕机前一致，这就是事务的**持久性**。

数据只要存储非易失存储介质，宕机就不会导致数据丢失。因此数据库可以采用以下方法来保证持久性：（1）事务完成前，所有的更改都保证存储到磁盘上了。或（2）提交完成前，事务的更改信息，以日志的形式存储在磁盘，重启过程根据日志恢复出数据库系统的内存状态。一般而言，数据库会选择方法（2），原因留给读者思考。

数据库为了提高资源利用率和事务执行效率、降低响应时间，允许事务并发执行。但是多个事务同时操作同一对象，必然存在冲突，事务的中间状态可能暴露给其它事务，导致一些事务依据其它事务中间状态，把错误的值写到数据库里。需要提供一种机制，保证事务执行不受并发事务的影响，让用户感觉，当前仿佛只有自己发起的事务在执行，这就是**隔离性**。

隔离性让用户可以专注于单个事务的逻辑，不用考虑并发执行的影响。数据库通过并发控制机制保证隔离性。由于隔离性对事务的执行顺序要求较高，很多数据库提供了不同选项，用户可以牺牲一部分隔离性，提升系统性能。这些不同的选项就是**事务隔离级别**。

数据库反映的是真实世界，真实世界有很多限制，例如：账户之间无论怎么转账，总额不会变等现实约束；年龄不能为负值，性别最多只能有男、女、跨性别者三种选项等完整性约束。事务执行，不能打破这些约束，保证事务从一个正确的状态转移到另一个正确的状态，这就是**一致性**。

不同与前三种性质完全由数据库实现保证，一致性既依赖于数据库实现（原子性、持久性、隔离性也是为了保证一致性），也依赖于应用端编写的事务逻辑。



# 事务特性实现
1. *Isolation: 加锁（写锁/独占锁）保证*
2. *Automatic 和 Durability: [[事务日志#redo log|redo log]] 保证* ;
3. *Consistency: [[事务日志#undo log|undo log]] 保证*

# MySQL事务隔离级别实现
1. *读未提交*：不加锁，可以理解为*没有隔离*。
2. *串行化*：所有操作都*加锁*实现
3. *读提交和可重复读*。*[[MVCC实现|MVCC]] + undo log/redo log*。


# SQL 并发问题
## 更新丢失 
*Lost Update*:
- 两个线程同时更新同样的数据，导致某个更新失效

## 脏读
*Dirty Reads*
- 读到了其他事务未*提交（临时）数据*，这些数据可能回滚，可能提交。

## 不可重复读
*Non-repeatable Reads*
- 在**同一事务内，不同的时刻读到的同一批数据可能是不一样**。
- 该数据可能受到了其他事务的影响。
- 在更新数据前读到的数据和更新过程中读到的数据不同。

## 幻读
*Phantom Reads*
- 幻读是针对数据**插入（INSERT）** 操作：
	- 事务A对某些行的内容作了更改，但是还未提交；
	- 事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了。
	- 事务A在提交之前，查询发现*相同的记录又出现了*，好像刚刚的**更改未起作用**，感觉出现了幻觉，称为幻读。

事务A在第一次查询时得到1条记录，在第二次*执行相同查询时却得到两条记录*:
![[幻读示意.png]]


为了解决幻读问题，innodb引入了gap锁（间隙锁）。
1. 在事务 B 执行：`insert into msg values (null,‘asd',’hello’);`  
	1. innodb 首先会和 RC 级别一样，给索引上的记录添加上X锁：
	2. 还在非唯一索引’asd’与相邻两个索引的区间加上锁。
2. 当事务 A 在执行` update msg set message=‘订单’ where token=‘asd’; commit;`
	1. 首先检查这个区间是否被锁上，如果被锁上，则不能立即执行，需要等待该gap锁被释放

![[mysql间隙锁示意.png]]

# ACID
- 事务：一组原子性的 SQL 查询，**要么就是全部成功，要么全部失败**。
- MySQL  **InnoDB 引擎**支持事务，**MyISAM 不支持事务**。

事务具有 *ACID 特性*：
- **原子性**（Atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚；
- **一致性**（Consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态；
- **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的；
- **持久性**（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。


# 事务隔离级别
## 背景
- SQL 事务隔离级别是为了*能最大限度的解决并发问题*

## 隔离级别
SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
1. **未提交读（READ UNCOMMITTED）** ——RU
	1. 事务对数据的**修改都会暴露给其他事务**，即便事务还没有提交。
	2. 会出现*脏读*问题；
2. **提交读 （READ COMMITTED）** —— RC，大多数流行数据库的默认事务隔离界别，如 Oracle
	1. *只能读到已经提交过的数据*
3. **可重复读 （REPEATABLE READ）** —— RR
	1. *不会读到其他事务对原有数据*的修改，即使其他事务已提交；
	2. *开始时读到的数据和在事务提交前的任意时刻读到数据是一样的*。
	3. 对其他事务**新插入**的数据还是可以读到的，这就是**幻读**问题。
4. **串行化 （SERIALIZABLE）** ——SE
	1. 将事务的执行变为顺序执行，相当于**单线程**，后一个事务的执行必须等待前一个事务结束。
	2. 解决了脏读、可重复读、幻读的问题，但是效率最差；

- 从上往下，**隔离强度逐渐增强，性能逐渐变差**；
- **可重复读**是 MySQL 的默认级别。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读提交   | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |

串行化解决了全部这 3 个问题


## 执行事务
执行过程：
1. 以 begin 或者 start transaction 开始事务语句；
2. 最后要执行 commit 或 rollback 操作，事务结束；
3. 事务*真正开始于 begin 命令之后的第一条语句*。

# 并发问题的解决
- *更新丢失*：应该完全避免。
	- 但并不能单靠数据库事务控制器解决，应用程序需要对更新的数据加必要的锁来解决。
-   *脏读、不可重复读和幻读*：都是*数据库读一致性问题*，由事务隔离机制来解决：
    - *加锁*：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    - *多版本并发控制（MultiVersion Concurrency Control，简称 **MVCC** 或 MCC）*、*多版本数据库*：
	    - 不加锁；
	    - *生成数据请求时间点的一致性快照* （Snapshot)， 并用快照提供一致性读取。
	    - 从用户的角度来看，好象数据库可以提供*同一数据的多个版本*。


# 总结

- MySQL 的 InnoDB 引擎才支持事务，其中**可重复读**是默认的隔离级别；
- 读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行；
- 读提交解决了脏读问题；
- **行锁**解决了并发更新的问题。
-  MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 **Next-Key 锁**实现的。


# 参考
1. [[MVCC实现]]
2. [纯干货 | 一篇讲透如何理解数据库并发控制 ](https://developer.aliyun.com/article/757147?spm=a2c6h.12873639.article-detail.7.9ddd4dbakEkXkB)