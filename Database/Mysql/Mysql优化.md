#SQL #Mysql #Optimize

# 架构和查询过程
![[Mysql架构示意.png]]

- 最上一层为客户端，处理：*连接处理、授权认证、安全*等功能。
- 中间层为 MySQL 核心服务：
	- 包括查询*解析、分析、优化、缓存、内置函数*。
	- *跨存储引擎*的功能也在这一层实现：存储过程、触发器、视图等。
- 最下一层为*存储引擎*，负责MySQL中的*数据存储和提取*

## 查询过程
![[mysql查询过程示意.png]]

## 客户端/服务端通信
- 类似“半双工”通信方式；
- 同一时刻，要么客户端向服务端发送数据，要么反过来。不能同时进行。
- 实际开发中，尽量保持查询简单且只返回必需的数据，查询中尽量 *避免使用 SELECT \* 以及加上 LIMIT 限制*。


## 查询缓存
- MySQL将结果缓存在一个引用表（类似于 HashMap）中，通过哈希值索引；
- 哈希值和查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息有关；
- 非确定性功能将导致查询不被缓存（包括临时表，用户变量，RAND（），NOW（）和UDF）。
- MySQL的查询缓存跟踪缓存中涉及的每个表，如果表的数据或结构发生变化，和表相关的所有缓存数据都将失效。
- 任何的写操作，对应表的所有缓存都失效。
- 如果查询缓存非常大或者碎片很多，缓存就可能带来很大的系统消耗。
- 不要轻易打开查询缓存，特别是写密集型应用。
- [Mysql 8.0 版本查询缓存将被移除](https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/) ：严重的可伸缩性问题（scalability issues），且很容易成为瓶颈（bottleneck）。
- 如果需要使用查询缓存，可参考 [proxysql: High-performance MySQL proxy with a GPL license](https://github.com/sysown/proxysql)
- *越靠近用户*时，缓存会带来最大的好处。


# 查询优化
## 
- 尽量避免全表扫描，对where及orderby的列建立索引  
- 尽量避免where使用 != 或 <>  
- 尽量避免where子句用 or 连接条件  
- 乱用%导致全表扫描  
- 尽量避免where子句对字段进行表达式操作  
- 尽量避免where子句对字段进行函数操作  
- 覆盖查询，返回需要的字段  
- 优化嵌套查询，关联查询优于子查询  

- 用exist代替in  
- 避免使用 '\*' , 只返回需要的字段

## 索引
- 关联字段尽量使用索引
- 查询字段尽量使用索引
- 值变化不大的字段，索引没有意义，避免建立索引
- 组合索引或复合索引，最左索引原则  