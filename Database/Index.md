#B-Tree #Index

索引（index）是在*存储引擎（storage engine）层面实现*，而不是server层面

# MySQL索引分类
## 数据结构角度
- **B+ TREE** 索引：大部分引擎支持  
- **HASH** 索引：只有memory引擎支持  
- **R TREE** 索引：MyISAM 的一个特殊索引类型，主要用于地理空间数据类型  
- **full-text** 索引：全文索引，MyISAM 特殊索引类型，innodb从 5.6 开始支持

## 物理存储角度
- *聚集索引（clustered index）*
- *非聚集索引（non-clustered index）*，也叫辅助索引（secondary index）
	- 聚集索引和非聚集索引都是 B+ 树结构
    

## 逻辑角度
- *主键索引*：主键索引是一种特殊的唯一索引，不允许有空值
- *普通索引或者单列索引*：每个索引只包含单个列，一个表可以有多个单列索引
- *多列索引（复合索引、联合索引）*：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循*最左前缀原则*；
- *唯一索引或者非唯一索引*
- *空间索引*：空间索引是对空间数据类型的字段建立的索引；
	- MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
	- 空间索引只能在存储引擎为 MYISAM 的表中创建。


## B-Tree
- “B“有多种解释，可取 *Balance* 含义；
- B-Tree 是为磁盘等外存储设备设计的一种*多路平衡查找树*，和 *BST（ 二叉查找树）*对比。
- 系统从磁盘读取数据到内存时以*磁盘块（block）为基本单位*，位于同一个磁盘块中的数据会*被一次性读取出来*，而不是需要什么取什么。
- InnoDB 存储引擎：
	1. *页（Page）是磁盘管理的最小单位*。
	2. 默认大小为 16KB，可通过参数 `innodb_page_size` 设置为 4K、8K、16K；
	3. MySQL 中查看页的大小：`show variables like 'innodb_page_size';`
- 系统磁盘中 block 往往没有这么大，InnoDB 申请的磁盘空间都是*若干地址连续的 block* ，以达到 Page 的大小。
- InnoDB *以页为基本单位将磁盘数据读入到内存*，查询时如果页中的数据*能有助于定位数据记录的位置（地址）*，这将*减少磁盘 I/O 次数，提高查询效率*。

## 特性
- B-Tree 结构可以让系统高效的找到数据所在的磁盘块。
- 将*一条记录映射为一个二元组 [key, data]*：
	- key 为记录的键值，表中的*主键值*；
	- data 为一行记录中*除主键外的数据*；
	- 对于不同的记录，key 值互不相同。
- 一棵 *m阶* 的B-Tree有如下特性： 
	1. 每个节点*最多有 m 个孩子*； 
	2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子；
	4. 所有*叶子节点都在同一层*；
	7. *ki(i=1,…n)为关键字（数据库中为主键）*，且关键字升序排序；
	8. pi(i=1,…n)为指向子树根节点的指针。
	9. p(i-1)指向的*子树的所有节点关键字均小于ki，但都大于k(i-1)*；
- B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支

## 示例
如下图所示为一个 3 阶的 B-Tree：

![[B树结构示意.png]]
- 每个节点占用一个盘块的磁盘空间；
- 一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
- 两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。
- 以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：
1.  根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2.  比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3.  根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4.  比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5.  根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6.  在磁盘块8中的关键字列表中找到关键字29。

- 上面过程需要3次磁盘I/O操作，和3次内存查找操作。
- 由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。
- 而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。
- B-Tree相对于 AVL Tree 缩减了节点个数，减少了层数，减少了磁盘 I/O。


# B+Tree
- B+Tree 是 B-Tree 的一种优化，使其更适合*外存储索引结构*，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。
- B-Tree 中每个节点中不仅包含数据的 key 值，还有 data 值：
	- 而 Page 的空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小；
	- 每个节点 key 很少将导致 B-Tree 的深度较大，增加查询时的磁盘 I/O 次数，进而影响查询效率。
- B+Tree 中，所有数据都是按照键值大小顺序存放在同一层的叶子节点上；
- 非叶子节点上只存储 key 值信息，可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。

## 比较
B+Tree 相对于 B-Tree 有几点不同：
1. *非叶子节点只存储键值信息*。
2. *数据都存放在叶子节点中*。
3. 叶子节点形成一个双向链表。

## 示例
假设每个磁盘块能存储 4 个键值及指针信息，则 B+Tree 结构如下图所示：   
![[B+ 树示意.png]]

- 对B+Tree进行两种查找运算：
	- 对*主键的范围查找和分页查找*；
	- *从根节点开始，进行随机查找*。
- 下面做一个推算：
	- InnoDB 存储引擎中 Page 的大小为 16KB；
	- 一般表的主键类型为 INT（占用4个字节）或 BIGINT（占用8个字节），指针类型也一般为4或8个字节；
	- 一个页（ B+Tree 中的一个节点）中大概存储 16 KB/(8B+8B) = 1K(1024) 个键值；
	- 为了方便估算，取 1 k=1000。一个*深度为 3 的 B+Tree 索引可以维护* $$10^3*10^3*10^3 = 10^9$$*10 亿条记录*。

- 实际情况节点可能不满，因此在数据库中，B+Tree 的**高度一般在2~4层**。
- InnoDB 存储引擎是将*根节点常驻内存*的，也就是说查找某一键值的行记录时**最多只需要1~3次磁盘I/O操作**。

## 总结
1.  由上可知 IO 次数取决于B+ Tree的*高度 h*，假设数据表的*数据量为 N*，每个*block 能存储的数据项量是 m*，则有 $$h=log(m+1)N$$
	1. 当数据量 N 一定的情况下，m 越大，h 越小；
	2. 而磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。
	3. 每个数据项，即索引字段要尽量的小，比如尽量用 int，而非 bigInt。
	4. B+ 树把数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。
	5. 当数据项 m 等于1时将会退化成线性表。
2. B+ 树的数据项如果是*复合的数据结构*，比如 (name,age,sex) 的时候：
	1. B+ 树是按照*从左到右的顺序来建立搜索树*；
	2. 如检索 (张三,20,F)：
	3. B+ 树*优先比较 name 来确定下一步的所搜方向*，如果 name 相同再依次比较age和sex，最后得到检索的数据；
	4. 但当检索 (20,F) ，B+ 树不知道下一步该查哪个节点，因为建立搜索树的时候 name 是*第一个比较因子*，必须要根据 name 来搜索才能知道下一步去哪里查询，此时将会*全表查询，索引失效*。
	5. 当检索 (张三,F) ，B+ 树可用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了，即[[索引的最左前缀原则]]。