#Mysql #Logic-delete #Physical-delete


# join 查询
- left jion 获取左边所有信息，故左表存在逻辑删除字段时，查询需*先排除已经被逻辑删除的数据*，deleted=0 （1表示已删除）

```sql
-- 错误写法
SELECT a.id,b.id
FROM A a LEFT JOIN B b 
ON a.id=b.a_id WHERE a.deleted=0 AND b.deleted=0
 
 
--正确写法
SELECT a.id,b.id
FROM 
	(SELECT id FROM A WHERE deleted=0) a 
LEFT JOIN
	(SELECT id,a_id FROM B WHERE deleted=0) b 
ON c.id=b.a_id 
```
- 过滤越早越好；
- 小表驱动大表，所以*左表需要先过滤逻辑删除记录*。
- 右表可在子查询或者 where 中。（？）

# Mysql 数据恢复
## binlog 日志
- binlog 是二进制日志，记录：
	- 数据库表结构变更 DDL（例如CREATE、ALTER TABLE…）；
	- 表数据修改 DML（INSERT、UPDATE、DELETE…）；
- 用 binlog 恢复数据：
	- 通过 binlog 找到 DML 操作；
	- 按顺序执行除去删除数据的 SQL 语句外的其它语句，可将数据恢复。

示意图如下：
![[binlog恢复数据库数据示意.png]]

  
- 要停掉数据库；
- 假如数据量大的话，难以筛选恢复数据的 sql；

## 数据库延时同步节点
-   配置一个同步数据的数据库；
-   同步时间，要延时：比如 1 小时同步一次
-   当出现问题的时候，只要在这个延时时间内，都还可以恢复出数据

综上：
1. 数据删除之后的恢复是要付出很大代价；
2. 存在不可恢复的风险。
3. 出于安全考虑，生产环境数据库应当禁止`物理删除`。

# 逻辑删除的问题
## 数据冗余
- 存在冗余数据，占用空间；
- 量大时影响查询效率。

## 影响惟一性约束
- 如果表的某个字段要求唯一，并强制约束，比如用户表中的登录用户名字段；
- 逻辑删除时，新的同用户名记录就无法插入。
- 如果不将该字段设置为数据库层面的唯一性约束，业务逻辑中，每次插入数据前，需先进行一次查询，判断有无（逻辑）删除的同名记录存在。
	- 高并发情景容易出现并发问题（check-then-set）；
	- 效率低下。

## 逻辑删除中限制唯一性
将*唯一约束字段*和*删除相关字段*组合成*唯一索引*。
### 方案1
- 数据库添加新的一列 delete_token；
- 当某一条记录需要删除时，将delete_token 设置为一个 UUID，（name，delete_token）为唯一键；
- delete=0 时，delete_token 为默认固定值，能够有效地限制 name 唯一；
- 当记录被删除时，delete_token 是一个唯一的 UUID，每条记录都不一样，便能新增同名记录不会被唯一约束束缚。
- 但 UUID及其索引 *会占用很大的空间*，所以不推荐使用。
- 该方法还有批量操作的问题：
	- 当需要批量删除时，需要对每一条记录进行逐行删除。
	- 因为需要*为每条记录 delete_token 插入一个 UUID*，所以需要将其拆分，一条条更新。

### 改进
- 将 *delete_token设 置为该记录的 id*。
- 将删除标记设置默认值(例如0)。当某一记录需要删除时，*将删除标记置为 NULL*。
	- *NULL 不会和其他字段有组合唯一键的效果*，当记录被删除时(删除标记被置为NULL时)，解除了唯一键的约束。
	- 也能很好地解决批量删除的问题(只要置为NULL)，消耗的空间也并不多(1位 + 联合索引)。
    
### 方案2
- 添加一个删除时间 `delete_time` 字段；
- 设置一个*不为 NULL 的默认值*，和*惟一字段组成联合唯一索引*；
- 进行逻辑删除的时候同时更新 `delete_time`。
    

# 应该用逻辑删除吗？
- 逻辑删除有好处，但是也有代价。
## 项目规模角度
- 一般*小型系统*可用`物理删除`。因为*数据恢复的成本*、数据的价值，相比`逻辑删除`的开发、运维付出要少。
- 但是`物理删除`!=`随意删除`，要认识到物理删除的风险，*重要数据应该设计历史表*，删除之前将删除的数据复制到历史表。
- *中大型项目*应该用`逻辑删除`，有一句话“*数据是无价的*”。很多时候，数据的价值是远远高于人工的成本的。
        
## 数据价值角度
- 价值比较高的数据，如*电商系统的订单*等，一般都是只允许`逻辑删除`的；
- 即使必须要做`物理删除`，也要通过*历史表、备份日志*等方式保证数据可以快速恢复。
- 价值比较低的数据，比如*用户操作日志*之类；
- 价值不高，而且量很大，在资源有限的情况下，可以考虑`物理删除`；
- 但是这种危险操作*尽量也不要由系统功能完成*，而应该由专业的 DBA去 完成。


# 参考
1. [数据库，逻辑删还是物理删？](https://juejin.cn/post/6946577362301485063)
2. [实现数据逻辑删除的一种方案](https://www.cnblogs.com/54chensongxia/p/14247966.html)