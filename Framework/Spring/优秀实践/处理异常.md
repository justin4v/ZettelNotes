#Practice #Exception 

# 目标
- 以优雅的 Assert（断言）校验业务异常情况，只关注业务逻辑；
- 不写冗余的 try catch 代码块；

## Assert
- assert 使用示例：
```java
	@Test
    public void test1() {
        ...
        // assert
        User user = userDao.selectById(userId);
        Assert.notNull(user, "用户不存在.");
        ...
    }

    @Test
    public void test2() {
        // if
        User user = userDao.selectById(userId);
        if (user == null) {
            throw new IllegalArgumentException("用户不存在.");
        }
    }
```
- *assert 相对 if 更加方便优雅*；
- org.springframework.util.Assert 部分源码
```java
public abstract class Assert {
    public Assert() {
    }

    public static void notNull(@Nullable Object object, String message) {
        if (object == null) {
            throw new IllegalArgumentException(message);
        }
    }
}
```
- *Assert 其实就是把封装了 if {...} *， 虽然简单，但是编码提升了一个档次。

## 思路
- 模仿 org.springframework.util.Assert 写一个断言；
- *失败后抛出自己定义的异常*。

## 实现
### 枚举类
- 业务逻辑中的异常有对应特定场景，如根据用户 id 获取用户信息，查询结果为 null，抛出的异常UserNotFoundException，并且有特定的异常码（比如 7001）和异常信息“用户不存在”；
- 每一种异常都定义一个 BaseException 的实现很繁琐，使用*枚举(code,message)* 描述不同的异常场景；

```java
public interface IResponseEnum {

    String getCode();
    String getMessage();

}
```
- 枚举接口，定义枚举规约(spec)


### BaseException
```java
@Getter
public class BaseException extends RuntimeException implements Serializable {

    private static final long serialVersionUID = -3831999267208849245L;

    protected final IResponseEnum responseEnum;
    protected final Object[] args;


    public BaseException(String message, IResponseEnum responseEnum,Object... args) {
        super(message);
        this.responseEnum=responseEnum;
        this.args = args;
    }

    public BaseException(String message,Throwable cause,IResponseEnum responseEnum, Object... args) {
        super(message, cause);
        this.responseEnum=responseEnum;
        this.args=args;
    }
}
```


### Assert
```java
public interface Assert {
	// 自定义异常构造函数
    BaseException newException(Object... args);

    BaseException newException(Throwable t, Object... args);

    /**
     * <p>断言对象<code>obj</code>非空。如果对象<code>obj</code>为空，则抛出自定义异常
     *
     * @param obj 待判断对象
     */
    default void assertNotNull(Object obj) {
        if (obj == null) {
            throw newException(obj);
        }
    }

    /**
     * <p>断言对象<code>obj</code>非空。如果对象<code>obj</code>为空，则抛出异常
     * <p>异常信息<code>message</code>支持传递参数方式，避免在判断之前进行字符串拼接操作
     *
     * @param obj 待判断对象
     * @param args message占位符对应的参数列表
     */
    default void assertNotNull(Object obj, Object... args) {
        if (obj == null) {
            throw newException(args);
        }
    }
}
```
- 抛出自定义异常 BaseException ；
- BaseException 构造交由子类实现；


# 参考
1. 为什么不建议用try catch处理异常？(微信文章)