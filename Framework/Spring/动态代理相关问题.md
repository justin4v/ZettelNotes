#Proxy #Spring 

# 内部方法调用AOP不生效的问题
- Spring AOP中*内部方法调用，切面逻辑是不生效*。

```java
//事务注解
@Transactional(rollbackFor = Exception.class)
@Override  
public Result create(Api api) {  
    saveApi(api);    
    return Result.OK();  
}

// public 方法
public void saveApi(Api api){
    //数据库操作
	sqlSave(api);
}
```

- `@Transactional` 原理是动态代理，实际调用是*通过代理类调用*； 
- SQL 操作在 `private` 方法中，调用 saveApi() *实际代码为 `this.saveApi(api)`*，非是通过代理类调用，无法被代理。

# 解决方案
 - 使用 `AopContext#currentProxy()`，获取当前类的代理对象，然后调用方法：
```java
@Transactional(rollbackFor = Exception.class)
@Override  
public Result create(Api api) {
	// 获取当前类的代理对象
	ApiServiceImpl service = (ApiService)AopContext.currentProxy();
	service.saveApi(api);    
	return Result.OK();  
}
```
 - 在当前类中获取自身的 Bean 实例，再用 Bean 进行内部调用：
```java
@Service
public class A{

  // 或者使用 ApplicationContext.getBean() 获取本class bean实例
  //拿到代理类
  @Autowired
  private A self;

  public void a(){
    //通过代理类来调用方法
    self.b();
    self.c();
  }
}
```


# 参考
1. [[动态代理]]