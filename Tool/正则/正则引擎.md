#Regex #Regex-engine 
# 正则引擎类型

正则引擎主要可以分为两大类：
- **DFA(Deterministic Finite Automatons/确定性有限自动机)**；
- **NFA(Nondeterministic Finite Automatons/非确定性有限自动机)**。
- **DFA可以称为文本主导的正则引擎**
- **NFA可以称为表达式主导的正则引擎**

# NFA与DFA工作的区别：

- 常常说**用正则去匹配文本**，是 NFA 的思路；
- DFA本质上其实是**用文本去匹配正则**。

```javascript
'for tonight's'.match(/to(nite|knite|night)/);
```

- 如果是NFA引擎，**表达式占主导**地位：
	1. 在字符串先查找字符串中的 t，然后依次匹配；
	2. 如果是 o，则继续(以此循环)。
	3. 匹配到 to 后，匹配 n，就面临三种选择，每一种都去尝试匹配一下：
	4. 第一个分支也是依次匹配，到 t (表达式中)这里停止(nite 分支到t这里直接被淘汰)；
	5. 同理，接着第二个分支在 k 这里也停止了；
	6. 在第三个分支找到了自己的归宿。 
	7. NFA 工作方式是**以正则表达式为标准，反复测试字符串**，这样同样一个字符串有可能被反复测试了很多次！
- 如果是 DFA 引擎，文本占主导地位：
	1. 从整个字符串第一个字符开始 f 开始查找 t；
	2. 查找到 t 后，定位到 t，已知文本中 t 后面为 o，则查看正则表达式其相应位置是否为 o；
	3. 如果是，则继续（以此循环)，再去查正则表达式 o 后是否为n（此时淘汰knite分支）；
	4. 再后是否为g(淘汰nite分支)；
	5. 此时只剩一个分支，直接匹配到终止即可。

- 只有正则表达式才有分支和范围，文本仅仅是一个字符流。
- 这带来什么样的后果？
	- **NFA 引擎在匹配失败的时候，如果有其他的分支或者范围，它会返回**，去尝试其他的分支。
	- **DFA 引擎一旦匹配失败，就结束了**，它没有退路。

这就是它们之间的本质区别。其他的不同都是这个特性衍生出来的。

# NFA VS DFA

首先，正则表达式在计算机看来只是一串符号，正则引擎首先肯定要解析它。NFA引擎只需要编译就好了；而DFA引擎则比较繁琐，编译完还不算，还要遍历出表达式中所有的可能。因为对DFA引擎来说机会只有一次，它必须得提前知道所有的可能，才能匹配出最优的结果。

所以，**在编译阶段，NFA引擎比DFA引擎快**。

其次，DFA引擎在匹配途中一遍过，溜得飞起。相反NFA引擎就比较苦逼了，它得不厌其烦的去尝试每一种可能性，可能一段文本它得不停返回又匹配，重复好多次。当然运气好的话也是可以一遍过的。

所以，**在运行阶段，NFA引擎比DFA引擎慢**。

最后，因为NFA引擎是表达式占主导地位，所以它的表达能力更强，开发者的控制度更高，也就是说开发者更容易写出性能好又强大的正则来，当然也更容易造成性能的浪费甚至撑爆CPU。DFA引擎下的表达式，只要可能性是一样的，任何一种写法都是没有差别(可能对编译有细微的差别)的，因为对DFA引擎来说，表达式其实是死的。而NFA引擎下的表达式，高手写的正则和新手写的正则，性能可能相差10倍甚至更多。

也正是因为主导权的不同，正则中的很多概念，比如非贪婪模式、反向引用、零宽断言等只有NFA引擎才有。

所以，**在表达能力上，NFA引擎秒杀DFA引擎**。

但是NFA以表达式为主导，因而NFA更容易操纵，因此一般程序员更偏爱NFA引擎！

当今市面上大多数正则引擎都是NFA引擎，应该就是胜在表达能力上。

总体来说，两种引擎的工作方式完全不同，一个(NFA)以表达式为主导，一个(DFA)以文本为主导！两种引擎各有所长，而真正的引用则取决与你的需要以及所使用的语言。

这两种引擎都有了很久的历史(至今二十多年)，当中也由这两种引擎产生了很多变体！

> 因为NFA引擎比较灵活，很多语言在实现上有细微的差别。所以后来大家弄了一个标准，符合这个标准的正则引擎就叫做POSIX NFA引擎，其余的就只能叫做传统型NFA引擎咯。 Deterministic finite automaton,Non-deterministic finite automaton,Traditional NFA,Portable Operating System Interface for uniX NFA

于是POSIX的出台规避了不必要变体的继续产生。这样一来，主流的正则引擎又分为3类：DFA，传统型NFA，POSIX NFA。


# 参考
1. [深入正则表达式(3):正则表达式工作引擎流程分析与原理释义 ](https://cloud.tencent.com/developer/article/1639509)