#Java基础 #JVM #问题排查

# 线上问题简介

## 分类
- 内存占用率高：内存溢出、查数据库全量数据
- CPU负载高：死循环、死锁、数据库锁等待、频繁full GC
- 性能瓶颈排查
- 偶现的线上bug

## 痛点
> 其主要表现在本地不易复现，陷入加日志、部署的循环中，效率低下，其原因主要在于以下几个方面：
- 代码是否一致
- 配置文件
- 运行环境
- 数据量及数据特征

## 解决途径
> 通过一些工具拿到现场的第一手信息，本文重点介绍以下工具
- JDK工具:jps、jstack、jstat、jmap等
- arthas
- skywalking

> 示例：在排查图像归档慢的问题时，如果能直接获取到一次请求的总耗时及各局部的耗时占比，就能轻松找性能瓶颈，比研究源码和业务流分析出可能的性能瓶颈、进行验证的方法要高效。

# JDK工具

## 常用工具介绍
- jps
- jstack
- jstat
- jmap

## 案例分享

### GC调优

- 环境描述：部署在阿里云主机上，没有采用容器化部署，4台实例，配置为4核8G，jdk1.8，GC为CMS，通过监控平台可以观察主机的内存与CPU的指标变化；
- 问题描述：在某天下午，CPU负载由平时的4（25%）以下上升到长时间处于5-10（50%-75%），峰值会达到15（100%）左右；
- 排查过程：
1. 通过top -H -p、printf、jstack等命名查出Java进程中哪些线程占用CPU负载高，结果是GC线程；
2. 通过jstat -gcutil命令观察GC情况，Young GC：5秒内执行10次，Full GC：200秒内10次；
3. 通过jmap -heap查看JVM的堆内存分布情况，堆内存分配4G，Young区只占332.75M，其余都是Old区，默认Young区和Old区分别占堆的1/3和2/3；
4. 通过jps -lmv查看JVM启动参数，发现MaxTenuringThreshold=2，即Young区经过2次GC还存活的就会进入Old区，默认这个值是15；
- 问题分析：
1. Young区较小，很容易占满，导致Young GC频繁；
2. Young区较小，当有较大对象，Young区承载不了，就会直接分配到Old区，导致Old区增长较快；
3. MaxTenuringThreshold较小，Young区存活的对象很容易晋升到Old区，导致Old区增长较快；
4. 由于2和3导致Old区增长较快，容易引发Full GC；
- 优化方案：
1. 将Young区占比调大：通过-Xmn1G指定Young区为1G，Old区为3G；
2. 采取灰度更新的策略，方便比对调整前后的效果：先只调整其中2个实例，其余2个实例不变；
- 优化效果：
1. 通过jmap -heap确认调整Young区已经生效；
2. 通过jstat -gcutil观察GC情况，调整后：Young GC：5秒内执行3次，Full GC：200秒内1次；
3. 通过监控平台观察CPU负载，调整后：基本维持在5以下；
> 综上所述，优化措施在较大程度上改善CPU负载高的问题；






