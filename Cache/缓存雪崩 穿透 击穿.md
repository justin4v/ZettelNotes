#Cache #CacheAvalanche #CachePenetration #CacheBreakdown #Todo 

# 缓存雪崩
- **Cache Avalanche**
- 缓存集中失效（*same expiration time*，will *fail at the same time*）；
- 或者缓存系统出现故障。
- 缓存层阻挡了大量请求，保护了存储层。缓存的集中失效或者缓存系统的故障，将导致存储层请求激增，甚至出现级联（cascade）故障停机。

![[redis缓存雪崩示意.png]]


## 解决

1. 在原有的失效时间上加上一个随机值，比如1-5分钟随机。避免了因为采用相同的过期时间导致的缓存雪崩。
2. **限流降级**（熔断）机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
3.   高可用，如 Redis *Sentinel* or Redis *Cluster*
4. **数据预热**。
	1. 上线前，提前设置，将可能大量访问的数据加载到缓存；


# 缓存穿透
- **Cache Penetration**
- 请求数据时，在缓存层和数据库层都不存在。
- Cache penetration causes non-existent data to be queried to the storage layer every time a request is made, *losing the meaning of cache protection for back-end storage*。

原因可能有两种：
- 业务代码问题；
- 多次恶意请求空对象；


## 解决
- 缓存空对象。当第一次从数据库中查询出来的结果为空时，将空对象加载到缓存，并设置合理的过期时间。
- 布隆过滤器，布隆过滤器可以针对大数据量的、有规律的键值进行处理。用 Bloom filter 过滤不存在的数据****。

![[bloom过滤器示意.png]]

# 缓存击穿
Hotspot Invalid
- 有大并发访问的热点Key，突然 Key 失效，导致大并发全部打在数据库上，导致数据库压力剧增。
- 和缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，缓存击穿是一个热点的 Key 失效。

## 解决

- 关键在于某个热点的key失效了，导致大并发集中打在数据库上。
- 有两种方案：
	1. 如果业务允许的话，对于热点的key可设置永不过期。
	2. 使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。

# 参考
1. [Redis Cache Penetration, Cache Breakdown, Cache Avalanches and Solutions](https://www.fatalerrors.org/a/redis-cache-penetration-cache-breakdown-cache-avalanches-and-solutions.html)
2. [什么是缓存雪崩、缓存击穿、缓存穿透](https://developer.aliyun.com/article/781428)