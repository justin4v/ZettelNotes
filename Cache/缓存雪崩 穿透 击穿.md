#Cache #CacheAvalanche #CachePenetration #CacheBreakdown #Todo 

# 缓存雪崩
- **Cache Avalanche**
- 缓存集中失效（*same expiration time*，will *fail at the same time*）；
- 或者缓存系统出现故障。
- 缓存层阻挡了大量请求，保护了存储层。缓存的集中失效或者缓存系统的故障，将导致存储层请求激增，甚至出现级联（cascade）故障停机。

![[redis缓存雪崩示意.png]]


## 解决

造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？

**解决方案：**

1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。

如果真的发生了缓存雪崩，有没有什么兜底的措施？

2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。

3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。

4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。

- 常用的方案是*保证 Redis 的高可用*：
	1.  Redis 高可用，如 Redis *Sentinel* or Redis *Cluster*。
- **限流降级**：
	1. 例如，缓存失效后，通过*加锁或者队列来控制读数据库*的线程数量。
	2. 如设置某些 Key 只允许一个线程查询数据和写缓存，其他线程等待。
- **数据预热**。
	1. 将可能大量访问的数据加载到缓存；
	2. 在即将发生大并发访问的时候，提前手动触发加载不同的数据到缓存中，并为数据设置不同的过期时间，让缓存失效的时间点尽量均匀，不至于在同一时刻全部失效。

# 缓存穿透
- **Cache Penetration**
- 请求数据时，在缓存层和数据库层都不存在。
- Cache penetration causes non-existent data to be queried to the storage layer every time a request is made, *losing the meaning of cache protection for back-end storage*。

原因可能有两种：
- 业务代码问题；
- 多次恶意请求空对象；


## 解决
- 缓存空对象。当第一次从数据库中查询出来的结果为空时，将空对象加载到缓存，并设置合理的过期时间。
- 布隆过滤器，布隆过滤器可以针对大数据量的、有规律的键值进行处理。用 Bloom filter 过滤不存在的数据****。

![[bloom过滤器示意.png]]

# 缓存击穿
Hotspot Invalid
- 有大并发访问的热点Key，突然 Key 失效，导致大并发全部打在数据库上，导致数据库压力剧增。
- 和缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，缓存击穿是一个热点的 Key 失效。

## 解决

- 关键在于某个热点的key失效了，导致大并发集中打在数据库上。
- 有两种方案：
	1. 如果业务允许的话，对于热点的key可设置永不过期。
	2. 使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。

# 参考
1. [Redis Cache Penetration, Cache Breakdown, Cache Avalanches and Solutions](https://www.fatalerrors.org/a/redis-cache-penetration-cache-breakdown-cache-avalanches-and-solutions.html)
2. [什么是缓存雪崩、缓存击穿、缓存穿透](https://developer.aliyun.com/article/781428)