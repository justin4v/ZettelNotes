#Redis #近似计数 #LFU #Todo #Approximate-counting

Redis在4.0之后支持配置缓存淘汰使用LFU（Least Frequently Used, 最少使用算法）。先简单回顾下LFU算法：

# LFU算法
LFU是缓存淘汰算法。一般我们可用于缓存的空间有限，但是我们需要缓存的数据可能是无限，为了能够提升缓存的命中率，我们希望留在缓存中的会是我们之后较短时间内最可能有到的那部分，这时候缓存淘汰就有用武之地了。

LFU算法的思路是： 我们记录下来每个（被缓存的/出现过的）数据的请求频次信息，如果一个请求的请求次数多，那么它就很可能接着被请求。

在数据请求模式比较稳定（没有对于某个数据突发的高频访问这样的不稳定模式）的情况下，LFU的表现还是很不错的。在数据的请求模式大多不稳定的情况下，LFU一般会有这样一些问题：

1）微博热点数据一般只是几天内有较高的访问频次，过了这段时间就没那么大意义去缓存了。但是因为在热点期间他的频次被刷上去了，之后很长一段时间内很难被淘汰；
2）如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；
3）如果记录全部出现过的数据的访问信息，会占用更多的内存空间。

对于上面这些问题，其实也都有一些对应的解决方式，相应的出现了很多LFU的变种。如：Window-LFU、LFU*、LFU-Aging。在Redis的LFU算法实现中，也有其解决方案。

# 近似计数算法 – Morris算法
Redis记录访问次数使用了一种近似计数算法——Morris算法。Morris算法利用随机算法来增加计数，在Morris算法中，计数不是真实的计数，它代表的是实际计数的量级。

算法的思想是这样的：算法在需要增加计数的时候通过随机数的方式计算一个值来判断是否要增加，算法控制 在计数越大的时候，得到结果“是”的几率越小。

我们来玩个逃脱游戏，游戏规则是这样的：
1） 你被困在一个倒金字塔结构的地下7层建筑里头，金字塔从底向上我们分别标号0、1、2、3、4、5、6；
2） 每层的天花板被划分成1 0 n 10^n10 
n
 个大小相等的区块，n nn为当层的标号（0层1块，1层10块，2层100块 …），这些区块的从1到1 0 n 10^n10 
n
 进行编号（随机，9号编号盘的可能是232，且从下往上看天花板看不到编号）；
3） 每层天花板上的1 0 n 10^n10 
n
 个区块中有1 0 n − 1 10^n - 110 
n
 −1块被铺上了坚硬的地板砖，仅剩下的一个区块（被随机选定的）是一个升降机，没错，它就是带你逃离这层的，但是它看着和其他地板砖没任何差别；
5） 每层有一个摇号机，通过这个摇号机能够得到一个1到1 0 n 10^n10 
n
 间的号，当摇到的号是升降机所在的区块，升降机将会降下来，带你离开这层；
4） 你被困在最底层 – 0层，站在摇号机边，开始你的游戏。
从上面的游戏看，最顺利的情况下，经过7次摇号，你就能逃离了。但是实际呢？概率是个很神奇的东西。


# 参考
1. [Redis LFU 实现 -- 掷硬币的艺术](https://blog.csdn.net/jh0218/article/details/95389361)