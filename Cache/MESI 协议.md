#Todo #MESI #Cache #Cache-coherency

# Cache

- 高速缓存（cache）是一种存取速率远比主内存大而容量远比主内存小的存储部件，每个处理器都有其高速缓存。
- 引入 cache 之后， 处理器在执行内存读、 写操作的时候并*不直接与主内存打交道*， 而是通过高速缓存进行的。
- cache 的内部结构相当于一个*拉链散列表(ChainedHash Table)*：
	- 包含若干*桶(Bucket, 硬件上称为Set)*,；
	- 每个桶又可以包含若干*缓存条目(CacheEntry)* .
![[cache的内部结构.png]]

## CacheEntry
 - 缓存条目可被进一步划分为Tag、Data Block以及Flag；
 - *Data Block* 也被称为**缓存行(CacheLine)** ：
	 - 高速缓存与主内存之间的数据交换最小单元；
	 - 用于存储从内存中读取的或者准备写往内存的数据。 
 - *Tag* 则包含了 cacheLine 中数据的**主内存（memory）地址的部分信息**（内存地址的高位比特）。
 - *Flag* 用于表示相应缓存行的状态信息。 
 - *缓存行的容量*（也被称为缓存行宽度）通常是2的倍数， 其大小在16-256 字节(Byte)之间不等。
 - 一个缓存行可以存储若干变量的值， 多个变量的值也可能被存储在同一个缓存行之中。

![[cacheEntry 缓存条目示意.png]]


# 缓存命中
## CPU 解码

- CPU 首先从二进制代码中得到要访问的内存地址，之后对地址进行解码；
- 内存地址的解码结果包括 tag、index 、offset 数据。
	- *index 相当于桶编号*，用来定位内存地址对应的桶；
	- *tag 相当于缓存条目的编号*， 与同一个桶中的各个缓存条目中的 Tag 部分进行比较（一个桶可能包含多个缓存条目）， 以定位一个具体的缓存条目；
	- *offset 是变量在缓存行的位置偏移*， 确定一个变量在一个缓存行中的存储起始位置（一个缓存条目中的缓存行可以用来存储多个变量，）。

## 命中
- 根据内存地址的解码结果，如果高速缓存中能够*找到相应的缓存行且缓存行所在的缓存条目的 Flag 表示缓存条目是有效*， 就称相应的内存操作产生了*缓存命中(CacheHit)* ;
- 否则，我们就称相应的内存操作产生了*缓存未命中(CacheMiss)*。

### 从性能角度来看，减少缓存未命中

- 缓存未命中包括读未命中(Read Miss)和写未命中(Write Miss), 分别对应内存读和写操作。
- 读未命中时， 处理器所需读取的数据会从主内存中加载并被存入相应的缓存行之中。 会*导致处理器停顿(Stall)* 而不能执行其他指令，这不利于发挥处理器的处理能力。

### 缓存未命中不可避免

- 由于高速缓存的*总容量远小于主内存的总容量*，同一个缓存行在不同时刻存储的可能是不同的一段数据， 因此缓存未命中是不可避免的。
- 在Linux系统中内核工具perf来查看程序运行过程中的缓存未命中情况。
  
# 缓存一致性协议

## 缓存一致性问题

- 多个线程并发访问同一个共享变量的时候，线程的执行处理器上的高速缓存各自都会保留一份该共享变撒的副本；
- 一个处理器对其副本数据进行更新之后， 其他处理器如何 *“察觉” 到该更新并做出适当反应*， 以确保这些处理器后续读取该共享变扯时能够读取到这个更新。*缓存一致性问题*。  


### 实质

实质就是如何防止**读脏数据和丢失更新**的问题。 

### 总线锁  
- 当一个CPU对其缓存中的数据进行操作的时候，往总线中发送一个Lock信号。
- 其他处理器的请求将会被阻塞，那么该处理器可以独占共享内存。
- 总线锁相当于把CPU和内存之间的通信锁住了，会导致CPU的性能下降，所以P6系列以后的处理器，出现了另外一种方式，就是缓存锁。

### 缓存锁  
如果缓存在处理器缓存行中的内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理不在总线上声明LOCK信号，而是修改内部的缓存地址，然后通过缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域的数据，当其他处理器回写已经被锁定的缓存行的数据时会导致该缓存行无效。所以如果声明了CPU的锁机制，会生成一个LOCK指令，会产生两个作用。

1.  Lock前缀指令会引起引起处理器缓存回写到内存，在P6以后的处理器中，LOCK信号一般不锁总线，而是锁缓存。
2.  一个处理器的缓存回写到内存会导致其他处理器的缓存无效


# MESI

- MESI协议对内存数据访问的控制**类似读写锁**，它使得针对同一地址的读内存操作是并发的，而针对同一地址的写内存操作是独占的，即针对同一内存地址进行的写操作在任意一个时刻只能够由一个处理器执行。 在MESI协议中， 一个处理器往内存中写数据时必须持有该数据的所有权。

-  MESI将缓存条目的状态划分为Modified(更新的)、Exclusive(排外的)、Shared(共享的)和Invalid(无效的)这4种， 并在此基础上定义了一组消息(Message)用于协调各个处理器的读、 写内存操作。

## 状态值
MESI协议中一个缓存条目的 Flag 值：  
- **invalid (无效的．记为I)**。 相应缓存行中*不包含任何内存地址对应的有效副本数据*。
	- 缓存条目的*初始状态*。  
- **Shared (共享的，记为s)**。 相应缓存行以**共享的方式**保留了相应内存地址**有效的最新副本数据**。 
	- 其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。
	- 一个缓存条目的状态如果为 Shared, 其他处理器上也存在 Tag 值与该缓存条目的 Tag 值相同的缓存条目，那么这些缓存条目的状态也为 Shared。
- **Exclusive (独占的，记为 E)** 。相应缓存行以**独占的方式**保留了相应内存地址**有效的最新副本数据**。  
	- 其他所有处理器上的高速缓存当前**都不保留该数据的有效副本**。
- **Modified (更改过的，记为 M)** 。相应缓存行保留了相应内存地址**最新更新结果**，数据和主存不一致。
	- 协议中的任意一个时刻只能够有一个处理器对同一内存地址对应的数据进行更新，；
	- 多个处理器上的高速缓存中 Tag 值相同的缓存条目中， 任意一个时刻只能够有一个缓存条目处于该状态。 处于该状态的 缓存条目。

## 消息
- MESI 协议定义了一组消息 (Message) 用于协调各个处理器的读、 写内存操作，
- 比照 HTTP 协议， 可以将 MESI 协议中的消息分为请求消息和响应消息。
- 处理器在执行内存读、写操作时在必要的情况下会往总线 (Bus) 中发送特定的请求消息，同时每个处理器还*嗅探 (Snoop, 也称拦截）* 总线中由其他处理器发出的请求消息并在一 定条件下往总线中回复相应的响应消息。
![[MESI中消息示例.png]]


  
  
# MESI协议的处理器读写操作？

## 读取操作
- 下面讨论在Processor 0上读取数据 D 的实现。
- 设内存地址A上 的数据S是处理器Processor 0 和处理器Processor 1  **可能共享**的数据。

1. Processor 0 会根据地址A找到对应的缓存条目， 并读取该缓存条目的Tag和Flag值（不讨论Tag值的匹配问题）。 
2. Processor0 找到的缓存条目的状态如果为*M、 E或者S（缓存和主存数据一致）*，处理器可以直接从相应的缓存行中读取地址 A 所对应的数据， 无须往总线中发送任何消息。
3. Processor 0找到的缓存条目的状态如果*为 I，则处理器的高速缓存中并不包含 D 的有效副本数据*；
4. Processor 0 需要往总线发送 Read 消息以读取地址 A 对应的数据， 其他*处理器 Processor 1 或者主内存*则需要回复 ReadResponse 以**提供相应的数据**
5. Processor 0 接收到 Read Response 消息时， 会将其中携带的数据（包含数据 D 的数据块） **存入缓存行并将该缓存条目的状态更新为 S** 。
6. Processor 0 接收到的 Read Response 消息可能来自主内存也可能来自其他处理器(Processor I)。
7. Processor 1 会嗅探总线中由其他处理器发送的消息。
	1. Processor I嗅探到 Read 消息的时候，会从该消息中*取出待读取的内存地址*．并根据该地址在其高速缓存中查找对应的缓存条目。
	2. 如果Processor 1 找到的缓存条目的状态*不为 I* (表11-2所示的情况）． 则该处理器的高速缓存中存在该数据的副本，此时Processor 1 构造相应的 ReadResponse 消息并将相应*缓存行的整块数据*（而不仅仅是Processor0所请求的数据s)  塞入 “ 该消息。
	3. 如果 Processor1 找到的相应缓存条目的状态*为 M*, 那么 Processor 1 可能在**往总线发送 ReadResponse 消息前将相应缓存行中的数据写入主内存**。Processor 1 往总线**发送 ReadResponse 之后，缓存条目的状态会被更新为 S**。 
	4. 如果 Processor 1 找到的高速缓存条目的状态*为 I*， 那么 Processor 0 所接收到的 ReadResponse 消息就**来自主内存**。


- 在Processor0读取内存的时候，即便Processor I对相应的内存数据进行了更新且更新还停留在Processor I 的高速缓存中而造成高速缓存与主内存中的数据不一致的情况下；
- MESI 消息的协调下这种不一致也并不会导致Processor0 读取到一个过时的旧值。

## 写入操作
1. 任何一个处理器执行内存写操作时必须**拥有相应数据的所有权**。
2. 在执行内存写操作时，Processor 0 会先根据内存地址A找到相应的缓存条目。
3. Processor 0 所找到的缓存条目的状态若为*E或者M*, 则该处理器*已经拥有相应数据的所有权*，该处理器可以直接将数据**写入相应的缓存行并将状态更新为M** 。
4. Processo r0 所找到的缓存条目的状态如果不为*E、M* , 则需要往总线*发送 Invalidate 消息*以获得数据的所有权。
5. 其他处理器接收到 Invalidate 消息后，将缓存中相应的缓存条目**状态更新为I (相当于删除相应的副本数据）** 并回复 Invalidate Acknowledge消息。
6. Invalidate 消息的发送者，必须在接收到**其他所有处理器所回复的 Invalidate Acknowledge 消息**之后再将数据更新到相应的缓存行之中.
![[MESI写操作示意.png]]


7. Processor 0 的缓存条目的状态若*为 S*，则说明Processor l上的高速缓存可能也保留了地址 A 的数据副本.：
	1. Processor 0 需要往总线发送 Invalidate 消息。
	2. Processor 0在接收到其他所有处理器所回复的 InvalidateAcknowledge 消息之后会将相应的缓存条目的**状态更新为 E**, 此时 Processor 0 *获得了地址 A 上数据的所有权*。 
	3. 接着，Processor 0 便可以将数据写入相应的缓存行， 并将相应缓存条目的**状态更新为 M** 。
8. Processor 0 所找到的缓存条目的状态若*为 I*, 则该处理器不包含地址 A 对应的有效副本数据,：
	1.  Processor 0 需要往总线发送 Read Invalidate 消息。
	2. Processor 0 在接收到 Read Response 消息以及其他所有处理器所回复的 Invalidate Acknowledge 消息之后， 会将相应缓存条目的**状态更新为 E**, 这表示该处理器已经获得相应数据的所有权。
	3.  Processor 0 便可以往相应的缓存行中写入数据了并将相应缓存条目的**状态更新为 M** 。 
9. 其他处理器在接收到 Invalidate 消息或者 Read Invalidate 消息之后， 必须根据消息中包含的内存地址在该处理器的高速缓存中查找相应的高速缓存条目。
	1. 若 Processor I 所找到的高速缓存条目的状态*不为 I* , 那么 Processor I 必须将相应缓存条目的状态更新为I, 以删除相应的副本数据并给总线回复 Invalidate Acknowledge 消息。可见. Invalidate 消息和 Invalidate Acknowledge 消息使得针对同一个内存地址的写操作在任意一个时刻只能由一个处理器执行， 从而避免了多个处理器同时更新同一数据可能导致的数据不一致问题。

  
  
作者：先生zeng  
链接：https://www.jianshu.com/p/5e860ffd6912  
来源：简书  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 参考
1. [深入学习缓存一致性问题和缓存一致性协议MESI(一)](https://www.cnblogs.com/dongc/p/12271042.html)
2. [[CPU 缓存]]