#Todo #MESI #Cache #Cache-coherency

# Cache

- 高速缓存（cache）是一种存取速率远比主内存大而容量远比主内存小的存储部件，每个处理器都有其高速缓存。
- 引入 cache 之后， 处理器在执行内存读、 写操作的时候并*不直接与主内存打交道*， 而是通过高速缓存进行的。
- cache 的内部结构相当于一个*拉链散列表(ChainedHash Table)*：
	- 包含若干*桶(Bucket, 硬件上称为Set)*,；
	- 每个桶又可以包含若干*缓存条目(CacheEntry)* .
![[cache的内部结构.png]]

## CacheEntry
 - 缓存条目可被进一步划分为Tag、Data Block以及Flag；
 - *Data Block* 也被称为**缓存行(CacheLine)** ：
	 - 高速缓存与主内存之间的数据交换最小单元；
	 - 用于存储从内存中读取的或者准备写往内存的数据。 
 - *Tag* 则包含了 cacheLine 中数据的**主内存（memory）地址的部分信息**（内存地址的高位比特）。
 - *Flag* 用于表示相应缓存行的状态信息。 
 - *缓存行的容量*（也被称为缓存行宽度）通常是2的倍数， 其大小在16-256 字节(Byte)之间不等。
 - 一个缓存行可以存储若干变量的值， 多个变量的值也可能被存储在同一个缓存行之中。

![[cacheEntry 缓存条目示意.png]]


# 缓存命中
## CPU 解码

- CPU 首先从二进制代码中得到要访问的内存地址，之后对地址进行解码；
处理器在执行内存访问操作时会将相应的内存地址解码。内存地址的解码结果包括 tag、index以及offset这三部分数据。其中，index相当于桶编号，它可以用来定位内存地址对应的桶；

一个桶可能包含多个缓存条目. tag相当于缓存条目的相对编号， 其作用在于用来与同一个桶中的各个缓存条目中的Tag部分进行比较， 以定位一个具体的缓存条目； 一个缓存条目中的缓存行可以用来存储多个变量，offset是缓存行内的位置偏移， 其作用在于确定一个变量在一个缓存行中的存储起始位置。


根据这个内存地址的解码结果，如果高速缓存子系统能够找到相应的缓存行并且缓存行所在的缓存条目的Flag表示相应缓存条目是有效的， 那么我们就称相应的内存操作产生了缓存命中(CacheHit) 3; 否则，我们就称相应的内存操作产生了缓存未命中(CacheMiss)。

从性能角度来看，减少缓存未命中

缓存未命中包括读未命中(Read Miss)和写未命中(Write Miss), 分别对应内存读和写操作。当读未命中产生时， 处理器所需读取的数据会从主内存中加载并被存入相应的缓存行之中。 这个过程会导致处理器停顿(Stall)而不能执行其他指令，这不利于发挥处理器的处理能力。

缓存未命中不可避免

由于高速缓存的总容量远小于主内存的总容量，同一个缓存行在不同时刻存储的可能是不同的一段数据， 因此缓存未命中是不可避免的。

在Linux系统中，我们可以使用Linux内核工具perf来查看程序运行过程中的缓存未命中情况。

高速缓存通常被称为一级缓存(LI Cache)、 二级缓存(L2 Cache)、 三级缓存(L3 Cache)

  
  
作者：先生zeng  
链接：https://www.jianshu.com/p/5e860ffd6912  
来源：简书  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 参考
1. [深入学习缓存一致性问题和缓存一致性协议MESI(一)](https://www.cnblogs.com/dongc/p/12271042.html)
2. [[CPU 缓存]]