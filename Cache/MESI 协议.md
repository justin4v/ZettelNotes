#Todo #MESI #Cache #Cache-coherency

# Cache

- 高速缓存（cache）是一种存取速率远比主内存大而容量远比主内存小的存储部件，每个处理器都有其高速缓存。
- 引入 cache 之后， 处理器在执行内存读、 写操作的时候并*不直接与主内存打交道*， 而是通过高速缓存进行的。
- cache 的内部结构相当于一个*拉链散列表(ChainedHash Table)*：
	- 包含若干*桶(Bucket, 硬件上称为Set)*,；
	- 每个桶又可以包含若干*缓存条目(CacheEntry)* .
![[cache的内部结构.png]]

## CacheEntry
 - 缓存条目可被进一步划分为Tag、Data Block以及Flag；
 - *Data Block* 也被称为**缓存行(CacheLine)** ：
	 - 高速缓存与主内存之间的数据交换最小单元；
	 - 用于存储从内存中读取的或者准备写往内存的数据。 
 - *Tag* 则包含了 cacheLine 中数据的**主内存（memory）地址的部分信息**（内存地址的高位比特）。
 - *Flag* 用于表示相应缓存行的状态信息。 
 - *缓存行的容量*（也被称为缓存行宽度）通常是2的倍数， 其大小在16-256 字节(Byte)之间不等。
 - 一个缓存行可以存储若干变量的值， 多个变量的值也可能被存储在同一个缓存行之中。

![[cacheEntry 缓存条目示意.png]]


# 缓存命中
## CPU 解码

- CPU 首先从二进制代码中得到要访问的内存地址，之后对地址进行解码；
- 内存地址的解码结果包括 tag、index 、offset 数据。
	- *index 相当于桶编号*，用来定位内存地址对应的桶；
	- *tag 相当于缓存条目的编号*， 与同一个桶中的各个缓存条目中的 Tag 部分进行比较（一个桶可能包含多个缓存条目）， 以定位一个具体的缓存条目；
	- *offset 是变量在缓存行的位置偏移*， 确定一个变量在一个缓存行中的存储起始位置（一个缓存条目中的缓存行可以用来存储多个变量，）。

## 命中
- 根据内存地址的解码结果，如果高速缓存中能够*找到相应的缓存行且缓存行所在的缓存条目的 Flag 表示缓存条目是有效*， 就称相应的内存操作产生了*缓存命中(CacheHit)* ;
- 否则，我们就称相应的内存操作产生了*缓存未命中(CacheMiss)*。

### 从性能角度来看，减少缓存未命中

- 缓存未命中包括读未命中(Read Miss)和写未命中(Write Miss), 分别对应内存读和写操作。
- 读未命中时， 处理器所需读取的数据会从主内存中加载并被存入相应的缓存行之中。 会*导致处理器停顿(Stall)* 而不能执行其他指令，这不利于发挥处理器的处理能力。

### 缓存未命中不可避免

- 由于高速缓存的*总容量远小于主内存的总容量*，同一个缓存行在不同时刻存储的可能是不同的一段数据， 因此缓存未命中是不可避免的。
- 在Linux系统中内核工具perf来查看程序运行过程中的缓存未命中情况。
  
# 缓存一致性协议

## 缓存一致性问题

- 多个线程并发访问同一个共享变量的时候，线程的执行处理器上的高速缓存各自都会保留一份该共享变撒的副本；
- 一个处理器对其副本数据进行更新之后， 其他处理器如何 *“察觉” 到该更新并做出适当反应*， 以确保这些处理器后续读取该共享变扯时能够读取到这个更新。*缓存一致性问题*。  


### 实质

实质就是如何防止**读脏数据和丢失更新**的问题。 

### 总线锁  
- 当一个CPU对其缓存中的数据进行操作的时候，往总线中发送一个Lock信号。
- 其他处理器的请求将会被阻塞，那么该处理器可以独占共享内存。
- 总线锁相当于把CPU和内存之间的通信锁住了，会导致CPU的性能下降，所以P6系列以后的处理器，出现了另外一种方式，就是缓存锁。

### 缓存锁  
如果缓存在处理器缓存行中的内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理不在总线上声明LOCK信号，而是修改内部的缓存地址，然后通过缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域的数据，当其他处理器回写已经被锁定的缓存行的数据时会导致该缓存行无效。所以如果声明了CPU的锁机制，会生成一个LOCK指令，会产生两个作用。

1.  Lock前缀指令会引起引起处理器缓存回写到内存，在P6以后的处理器中，LOCK信号一般不锁总线，而是锁缓存。
2.  一个处理器的缓存回写到内存会导致其他处理器的缓存无效


# MESI

- MESI协议对内存数据访问的控制**类似读写锁**，它使得针对同一地址的读内存操作是并发的，而针对同一地址的写内存操作是独占的，即针对同一内存地址进行的写操作在任意一个时刻只能够由一个处理器执行。 在MESI协议中， 一个处理器往内存中写数据时必须持有该数据的所有权。

-  MESI将缓存条目的状态划分为Modified(更新的)、Exclusive(排外的)、Shared(共享的)和Invalid(无效的)这4种， 并在此基础上定义了一组消息(Message)用于协调各个处理器的读、 写内存操作。

## 状态值
MESI协议中一个缓存条目的 Flag 值：  
- **invalid (无效的．记为I)**。 相应缓存行中*不包含任何内存地址对应的有效副本数据*。
	- 缓存条目的*初始状态*。  
- **Shared (共享的，记为s)**。 相应缓存行以**共享的方式**保留了相应内存地址**有效的最新副本数据**。 
	- 其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。
	- 一个缓存条目的状态如果为 Shared, 其他处理器上也存在 Tag 值与该缓存条目的 Tag 值相同的缓存条目，那么这些缓存条目的状态也为 Shared。
- **Exclusive (独占的，记为 E)** 。相应缓存行以**独占的方式**保留了相应内存地址**有效的最新副本数据**。  
	- 其他所有处理器上的高速缓存当前**都不保留该数据的有效副本**。
- **Modified (更改过的，记为 M)** 。相应缓存行保留了相应内存地址**最新更新结果**。 
	- 协议中的任意一个时刻只能够有一个处理器对同一内存地址对应的数据进行更新， 因此在多个处理器上的高速缓存中 Tag 值相同的缓存条目中， 任意一个时刻只能够有一个缓存条目处于该状态。 处于该状态的 缓存条目， 其缓存行中包含的数据与主内存中包含的数据不一致。</pre>

MESI 协议定义了一组消息 (Message) 用于协调各个处理器的读、 写内存操作，如表11-1 所示。 比照 HTTP 协议， 我们可以将 MESI 协议中的消息分为请求消息和响应消息。处理器在执行内存读、写操作时在必要的情况下会往总线 (Bus) 中发送特定的请求消息，同时每个处理器还嗅探 (Snoop, 也称拦截）总线中由其他处理器发出的请求消息并在一 定条件下往总线中回复相应的响应消息。

  
  
作者：先生zeng  
链接：https://www.jianshu.com/p/5e860ffd6912  
来源：简书  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 参考
1. [深入学习缓存一致性问题和缓存一致性协议MESI(一)](https://www.cnblogs.com/dongc/p/12271042.html)
2. [[CPU 缓存]]