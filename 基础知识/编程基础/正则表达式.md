#Regex
# 正则基础

**正则表达式（regular expression）** 
- 用一个字符串**描述一个特征**；
- 然后**验证另一个字符串是否符合特征**。

如：
表达式“*ab+*” 描述的特征是：
- 一个 'a' 和 任意个 'b' ；
- 那么 'ab', 'abb', 'abbbbbbbbbb' 都符合这个特征。

1. regex 表达式*整体作为规则去匹配另外一个字符串的内容*；
2. 并给出相应的*结果与副作用（side-effect)*.

## 单个普通字符

- **只能匹配单个字符**
- *字母、数字、汉字、下划线、标点符号*。
- regex 中*普通字符，匹配与之相同的一个字符*。



## 元字符
构造 regex 表达式的**基本元素**。

常用的元字符如下：

| 元字符   |    说明                                                              |
| ------ | ----------------------------------------------------------------- |
| .      | 匹配*除换行符以外的任意单个字符*            |
| \w     | 匹配*字母/数字/下划线*                   |
| \s     | 匹配*任意的空白符*                      |
| \d     | 匹配*数字*                |
| \b     | 匹配一个**单词边界**，单词和空格之间的位置，不匹配任何字符  |
| ^      | 匹配**整个字符串的开始位置**，不匹配任何字符。多行模式下匹配每一行开头 |
| $      | 匹配**整个字符串的结束位置**，不匹配任何字符     |

### 注意
注意其中匹配的模式：
- 匹配单个字符
- 匹配边界。`^pattern` / `pattern&` 要求字符串匹配（包含）整个 pattern， `^pattern$` 意味着*相等*。

## example
1. 匹配 abc 开头的字符串：
	```
	\babc 或者 ^abc
	```

2. 匹配8位数字：
	```
	^\d\d\d\d\d\d\d\d$
	```

2. 匹配1开头11位数字：
	```
	^1\d\d\d\d\d\d\d\d\d\d$
	```

## 重复限定符

**可匹配单个字符或表达式多次**
部分常用重复限定符如下：

| 语法  | 说明                                 |
| ----- | ------------------------------------ |
| *     | 重复零次或多次；贪婪模式，尽可能多 |
| +     | 重复一次或多次；贪婪模式 |
| ?     | 重复零次或一次；贪婪模式   |
| {n}   | 重复至少n次；贪婪模式    |
| {n,}  | 重复至少n次或更多次；贪婪模式  |
| {n,m} | 重复至少n次，至多m次；贪婪模式    |

简化前面的 regex：
1. 匹配1开头的11数字：`^1\d{10}`
2. 匹配以a开头，0个或多个b结尾：`^ab*$`

## 分组
1. 从`^ab*$`中看到，`*` 限定符*只会作用在左边最近的一个字符*；
2. 使用分组`小括号()` **同时限定多个字符**：
	1. 分组会保存结果到内存；
	2. 通常和捕获概念一起使用，称为捕获组；

匹配字符串中包含0到多个ab开头： `^(ab)*$`

## 转义

把元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是 \ 即可。

 如：要匹配**以 (ab) 开头**： ```^(\(ab\))*```

## 逻辑或

> 符号 `|`表示**逻辑或**

如
```
^(130|131|132|155|156|185|186|145|176)\d{8}$
```
## 区间
*括号 [] * 表示**区间**

如：
```
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

# 正则进阶

## 1. 零宽断言

> **断言**：断定*指定内容的前后，会出现满足指定规则的内容*
>
> **零宽**：*没有宽度*。
> - 正则中，*断言只匹配位置*；
> - 匹配结果*不会返回断言字符本身*。

### 正向先行断言

**正/负向、先/后行** 解释：
> **正向**：找到 **匹配 pattern** 的内容，*Is 逻辑，等号 "="*
>
> **负向**：找到 **不匹配 pattern** 的内容，*Not 逻辑，感叹号  "!"*
>
> **先行**：在 *pattern* 的内容**前面**查找 *expression* 的匹配，*expression 前面*。
>
> **后行**：在 *pattern* 的内容**后面**查找 *expression* 的匹配，*expression 后面*，pattern **加 “<”**。

语法：
> **正向先行断言 (正前瞻)**：   
>   - *语法*：*expression(?=pattern)*
>   - *作用*：返回 *pattern 前面匹配 expression 的内容*，不返回 pattern 本身。
>   - *含义*：断定 pattern 前面存在 expression 匹配的内容，并返回该内容
>   - pattern 和 expression 都是正则表达式 


如匹配
```
1"<span class="read-count">阅读数：641</span>"
```
中  `\</span>`  前面数字。
用*正向先行断言* `(?=</span>)` 匹配。
 代码：
```java
 String reg=".+(?=</span>)";
 String test = "<span class=\\"read-count\\">阅读数：641</span>";
 Pattern pattern = Pattern.compile(reg);
 Matcher mc =  pattern.matcher(test);
 while(mc.find()){
   System.out.println("匹配结果：")
   System.out.println(mc.group());
 }

//匹配结果：
//<span class="read-count">阅读数：641
```

### 正向后行断言

语法：
 **正向后行断言 (正后顾)**:  
 - *语法*：*(?<=pattern)expression*
-  *作用*：返回 pattern 后面匹配 expression 的内容，不返回本身
-  *含义*：断定 pattern 后面存在 expression 匹配的内容，并返回该内容


### 负向先行断言

 **负向先行断言（负前瞻）**  
- 语法：*expression(?!pattern)*
 - 作用：返回 pattern 前面不匹配 expression 的内容，不返回本身。
 - 含义：断定 pattern 前面存在不匹配 expression 的内容，并返回该内容 

如 “我爱祖国，我是祖国的花朵” 。
现在找到不是 '的花朵' 前面的祖国
用正则就可以这样写：
```
祖国(?!的花朵)
```

### 负向后行断言
语法：
**负向后行断言（负后顾）**  
- 语法：*(?<!pattern)expression*
- 作用：返回*pattern 后面不匹配 expression 的内容*，不返回本身
- 含义：断定 pattern 后面存在不匹配 expression 的内容，并返回该内容



### 总结
 零宽断言：
 1. 先用 pattern 限定搜索的范围（pattern 定位 + 搜索方向）
 2. 然后在限定范围中搜索 expression 匹配内容


## 2. 捕获和非捕获

1. **捕获：匹配表达式**
2. 捕获组：
	1. 匹配子表达式的内容；
	2. 结果保存到内存中*以数字或显式命名的组*里；
	3. 可以通过序号或名称获取匹配结果。

### 数字编号捕获组

 **语法：(exp)**
 解释：
 1. *从表达式左侧开始，匹配表达式的内容为一个捕获组*。
 2. *第 0 组为整个表达式，不计入分组个数，第一组开始为分组*。

如
- 内容：020-85653333
- 正则表达式为：(0\d{2})-(\d{8})
有如下分组：

| 序号 | 编号 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (0\d{2})     |     020      |
|  2   |  2   |     (\d{8})      |   85653333   |


Java 代码：
```java
String test = "020-85653333";
String reg="(0\\d{2})-(\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：
```
分组的个数有：2
第0个分组为：020-85653333
第1个分组为：020
第2个分组为：85653333
```

### 命名编号捕获组

 1. 语法：**(\?\<name\>exp)**；
 2. 解释： 分组的*命名由表达式中的 name 指定*。
 	比如区号也可以这样写: **(?\<quhao>\0\d{2})-(?\<haoma>\d{8})** 
表达式有如下分组：

| 序号 | 名称  |       分组       |     结果     |
| :--: | :---: | :--------------: | :----------: |
|  0   |   0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   | quhao |     (0\d{2})     |     020      |
|  2   | haoma |     (\d{8})      |   85653333   |

代码验证：
```java
String test = "020-85653333";
String reg="(?<quhao>0\\\\d{2})-(?<haoma>\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    System.out.println(mc.group("quhao"));
    System.out.println(mc.group("haoma"));
}
```

输出结果：
```
分组的个数有：2
分组名称为:quhao,匹配内容为：020
分组名称为:haoma,匹配内容为：85653333
```

### 非捕获组
1. 语法：**(?:exp)**
2. 解释：和捕获组刚好相反，标识不需要捕获的分组。

如上面的正则表达式，程序不需要用到第一个分组：

```
(?:\\0\\d{2})-(\\d{8})
```

| 序号 | 名称 |       分组       |     结果     |
| :--: | :--: | :--------------: | :----------: |
|  0   |  0   | (0\d{2})-(\d{8}) | 020-85653333 |
|  1   |  1   |     (\d{8})      |   85653333   |

验证：
```java
String test = "020-85653333";
String reg="(?:0\\\\d{2})-(\\\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find()){
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++){
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}
```

输出结果：
```
分组的个数有：1
第0个分组为：020-85653333
第1个分组为：85653333
```

## 3. 反向引用

1. 捕获会返回一个捕获组**保存在内存中**。
2. 可在表达式*外部通过程序引用*，
3. 也可在*表达式内部引用*，这就是*反向引用*。

根据捕获组的命名规则，反向引用可分为：

1. *数字编号*组反向引用：\k\<number>或\number 
2.  *命名编号*组反向引用：\k\<name>或者\\'name'

### 示例
*查找 "aabbbbgbddesddfiid" 里成对的字母* 
1. 用**程序思维理一下思路**：

> 1）匹配到一个字母
> 2）匹配第下一个字母，检查是否和上一个字母是否一样 
> 3）如果一样，则匹配成功，否则失败

2. 匹配下一个字母时，需要用到上一个字母，可利用捕获*把上一个匹配成功的内容用来作为本次匹配的条件*。
	1.  首先匹配一个字母：\w，*分组才能捕获*，因此是：(\w)
	2.  然后*以捕获组作为条件*：**(\w)\1** 
	*\1 是数字编号组反向引用*，表示引用前面第一个捕获组的内容

测试：
```java
String test = "aabbbbgbddesddfiid";
Pattern pattern = Pattern.compile("(\\w)\\1");
Matcher mc= pattern.matcher(test);
while(mc.find()){
    System.out.println(mc.group());
}
```

输出结果：

```
aa
bb
bb
dd
dd
ii
```

假如想要把字符串中abc换成a

```
String test = "abcbbabcbcgbddesddfiid";
String reg="(a)(b)c";
System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```
abbabcgbddesddfiid
```

## 4. 贪婪和非贪婪
### 1.贪婪

 **贪婪匹配**：
 - 表达式中包含[[#重复限定符]]时，匹配**尽可能多**的字符。

如：
```java
String reg="\\d{3,6}";        
String test="61762828 176 2991 871";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```
输出结果：
```
文本：61762828 176 2991 44 871
贪婪模式：\\d{3,6}
匹配结果：617628
匹配结果：176
匹配结果：2991
匹配结果：871
```

由结果可见：
- 其实只要匹配3个数字（617）就已经匹配成功，但是匹配到了最大能匹配的字符--6个。

### 多个贪婪量词
多个贪婪在一起时：
1.  如果字符串能满足各自最大程度的匹配时，就互不干扰；
2.  如果不能满足时，会根据*深度优先原则*：
	1.  *从左到右的贪婪量词，优先级从高到低*；
	2.  *先优先满足左边量词*，再满足量词。

```java
String reg="(\\d{1,2})(\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：
```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2})(\\d{3,4})
匹配结果：617628
匹配结果：2991
匹配结果：87321
```

1. “617628” ：前面的\d{1,2}匹配出了61，后面的匹配出了7628 
2.  "2991" ：前面的\d{1,2}匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)
3.  "87321"：前面的\d{1,2}匹配出了87，后面的匹配出了321



### 2. 懒惰（非贪婪）
**懒惰匹配**：
- 表达式中包含[[#重复限定符]]时，匹配**尽可能少**的字符
- 懒惰量词是在**贪婪量词后面加个“？”**

| 语法   | 说明                        |
| ------ | --------------------------- |
| *?     | 重复零次或更多次,但尽可能少 |
| +?     | 重复一次或更多次,但尽可能少 |
| ??     | 重复零次或一次,但尽可能少   |
| {n}?   | 重复n次,但尽可能少          |
| {n,}?  | 重复n次或更多次,但尽可能少  |
| {n,m}? | 重复n到m次,但尽可能少       |

### 示例

```java
String reg="(\\d{1,2}?)(\\\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
System.out.println("贪婪模式："+reg);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
	System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：
```
文本：61762828 176 2991 87321
贪婪模式：(\\d{1,2}?)(\\d{3,4})
匹配结果：61762
匹配结果：2991
匹配结果：87321
```

1. “61762” ：左边的懒惰匹配出6，右边的贪婪匹配出1762
2.  "2991" ：左边的懒惰匹配出2，右边的贪婪匹配出991
3.  "87321" ：左边的懒惰匹配出8，右边的贪婪匹配出7321



## 5. 反义
**反义元字符**：

| 元字符 | 说明                                         |
| ------ | -------------------------------------------- |
| \W     | 匹配 任意不是字母或数字或下划线或汉字 的字符 |
| \S     | 匹配 任意不是空白符 的字符                   |
| \D     | 匹配 任意不是数字 的字符                     |
| \B     | 匹配 不是**单词**的开始或结束 的位置         |
| [\^x]   | 匹配 除了 x 以外的任意字符                   |
