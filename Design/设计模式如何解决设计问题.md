# 确定适合的抽象
Design patterns help you *identify less-obvious abstractions and  objects* that can capture them. 
For example, objects that represent a process or algorithm don't occur in nature, yet they are a crucial part of flexible designs. 
- The Strategy (315) pattern describes how to implement interchangeable families of algorithms. 
- The State (305) pattern represents each state of an entity as an object. 

These objects are seldom found during analysis or even the early stages of design; they're discovered later in the course of making a design more flexible and reusable.

# 决定Object粒度
Objects can vary tremendously in size and number. They can represent everything down to the hardware or all the way up to entire applications. How do we decide what should be an object? 

Design patterns address this issue as well. The Facade (185) pattern describes how to represent complete subsystems as objects, and the Flyweight (195) pattern describes how to support huge numbers of objects at the finest granularities. Other design patterns describe specific ways of decomposing an object into smaller objects.Abstract Factory (87) and Builder(97) yield objectswhose only responsibilities are creatingother objects. Visitor (331) and Command (233)yield objectswhose only responsibilities are to implement a request on another object or group ofobjects.