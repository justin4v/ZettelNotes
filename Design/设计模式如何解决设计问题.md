# 确定适合的抽象
Design patterns help you *identify less-obvious abstractions and  objects* that can capture them. 
For example, objects that represent a process or algorithm don't occur in nature, yet they are a crucial part of flexible designs. 
- The Strategy (315) pattern describes how to implement interchangeable families of algorithms. 
- The State (305) pattern represents each state of an entity as an object. 

These objects are seldom found during analysis or even the early stages of design; they're discovered later in the course of making a design more flexible and reusable.

# 决定Object粒度
Objects can vary tremendously in size and number. They can represent everything down to the hardware or all the way up to entire applications. How do we decide what should be an object? 

Design patterns address this issue as well：
1. The Facade  pattern describes how to represent complete subsystems as objects,
2. Flyweight  pattern describes how to support huge numbers of objects at the finest granularities. 

Other design patterns describe specific ways of decomposing an object into smaller objects：
1. Abstract Factory  and Builder yield objectswhose only responsibilities are creatingother objects. 
2. Visitor  and Command yield objects whose only responsibilities are to implement a request on another object or group ofobjects.


# 复用机制
Most people can understand concepts like objects, interfaces,classes, and inheritance. The challenge lies in applying them to build flexible, reusable software, and design patterns can show you how


