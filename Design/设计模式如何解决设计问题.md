# 确定适合的抽象
Design patterns help you **identify less-obvious abstractions and  objects** that can capture them. 
For example, *objects that represent a process or algorithm don't occur in nature, yet they are a crucial part of flexible designs*. 
- The Strategy pattern describes how to implement interchangeable families of algorithms. 
- The State pattern represents each state of an entity as an object. 

These objects are seldom found during analysis or even the early stages of design; they're discovered later in the course of making a design more flexible and reusable.

# 决定Object粒度
Objects can vary tremendously in size and number. They can represent everything down to the hardware or all the way up to entire applications. How do we decide what should be an object? 

Design patterns address this issue as well：
1. The Facade  pattern describes how to represent complete subsystems as objects,
2. Flyweight  pattern describes how to support huge numbers of objects at the finest granularities. 

Other design patterns describe specific ways of decomposing an object into smaller objects：
1. Abstract Factory  and Builder yield objectswhose only responsibilities are creatingother objects. 
2. Visitor  and Command yield objects whose only responsibilities are to implement a request on another object or group ofobjects.


# 复用机制
Most people can understand concepts like objects, interfaces,classes, and inheritance. The challenge lies in applying them to *build flexible, reusable software,* and design patterns can show you how.

## Inheritance vs. Composition
**class inheritance lets you define the implementation of one class(子类) in terms of another's（父类）**. 依照父类定义子类实现


Reuseby subclassing is often referred to as **white-box reuse**. The term "white-box" refers to *visibility*: With inheritance, the internals of parent classes are often visible to subclasses.

Object composition is an alternative to class inheritance. Here, new functionality is obtained by assembling or composing objects to get more complex functionality.
Object composition requires that the objects being composed have *well-defined interfaces*. This style of reuse is called **black-box reuse**, because no internal details of objects are visible. Objects appear only as "black boxes."

### advantages
Class inheritance:
1. defined statically at compile-time and is straightforward to use;
2. makes it easier to modify the implementation being reused by overridden operations;

Object composition :
1. defined dynamically at run-time through objects acquiring references to other objects.
2. requires objects to respect each others' interfaces, which in turn requires carefully designed interfaces that *don't stop you from using one object with many others*.


### disadvantages
1.  you can't change the implementations inherited from parent classes at run-time;
2.  generally worse, parent classes often define at least part of their subclasses' physical representation.Because inheritance exposes a subclass to details of its parent's implementation, it's often said that "inheritance breaks encapsulation".

Implementation dependencies can cause problems when you're trying to reuse a subclass. Should any aspect of the inherited implementation not be appropriate for new problem domains, the parent class must be rewritten or replaced by something more appropriate. This dependency *limits flexibility and ultimately reusability*. 
One cure for this is to **inherit only from abstract classes**, since they usually provide little or no implementation.



# Class Inheritance vs. Interface Inheritance
In short, it's a mechanism for code and representation sharing. In contrast, **interface inheritance** (or subtyping) describes *when an object can be used in place of another*.****