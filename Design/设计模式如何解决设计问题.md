# 确定适合的抽象
Design patterns help you *identify less-obvious abstractions and  objects* that can capture them. 
For example, objects that represent a process or algorithm don't occur in nature, yet they are a crucial part of flexible designs. 
- The Strategy (315) pattern describes how to implement interchangeable families of algorithms. 
- The State (305) pattern represents each state of an entity as an object. 

These objects are seldom found during analysis or even the early stages of design; they're discovered later in the course of making a design more flexible and reusable.

# 决定Object粒度
Objects can vary tremendously in size and number. They can represent everything down to the hardware or all the way up to entire applications. How do we decide what should be an object? 

Design patterns address this issue as well：
1. The Facade  pattern describes how to represent complete subsystems as objects,
2. Flyweight  pattern describes how to support huge numbers of objects at the finest granularities. 

Other design patterns describe specific ways of decomposing an object into smaller objects：
1. Abstract Factory  and Builder yield objectswhose only responsibilities are creatingother objects. 
2. Visitor  and Command yield objects whose only responsibilities are to implement a request on another object or group ofobjects.


# 复用机制
Most people can understand concepts like objects, interfaces,classes, and inheritance. The challenge lies in applying them to *build flexible, reusable software,* and design patterns can show you how.

## Inheritance vs. Composition
**class inheritance lets you define the implementation of one class(子类) in terms of another's（父类）**. 依照父类定义子类实现
Reuseby subclassing is often referred to as **white-box reuse**. The term "white-box" refers to *visibility*: With inheritance, the internals of parent classes are often visible to subclasses.

Object composition is an alternative to class inheritance. Here, new functionality is obtained by assembling or composing objects to get more complex functionality.
Object composition requires that the objects being composed have *well-defined interfaces*. This style of reuse is called **black-box reuse**, because no internal details of objects are visible. Objects appear only as "black boxes."