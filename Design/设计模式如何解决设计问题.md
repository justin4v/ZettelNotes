# 确定适合的抽象
Design patterns help you **identify less-obvious abstractions and  objects** that can capture them. 
For example, *objects that represent a process or algorithm don't occur in nature, yet they are a crucial part of flexible designs*. 
- The Strategy pattern describes how to implement interchangeable families of algorithms. 
- The State pattern represents each state of an entity as an object. 

These objects are seldom found during analysis or even the early stages of design; they're discovered later in the course of making a design more flexible and reusable.

# 决定Object粒度
Objects can vary tremendously in size and number. They can represent everything down to the hardware or all the way up to entire applications. How do we decide what should be an object? 

Design patterns address this issue as well：
1. The Facade  pattern describes how to represent complete subsystems as objects,
2. Flyweight  pattern describes how to support huge numbers of objects at the finest granularities. 

Other design patterns describe specific ways of decomposing an object into smaller objects：
1. Abstract Factory  and Builder yield objectswhose only responsibilities are creatingother objects. 
2. Visitor  and Command yield objects whose only responsibilities are to implement a request on another object or group ofobjects.

# 明确对象接口
Specifying Objects Interfaces

## 动态绑定（Dynamic Binding）
- When a request issent to an object, the particular operation that'sperformed depends on both the *request* and the *receiving object*. **Different objects that support identical（same） requests may have different implementations of the operations that fulfill these requests.** 
- The run-time association of a request to an object and one of its operations is known as **dynamic binding**.
- Dynamic binding means that issuing a request doesn't commit you to a particular implementation until run-time. Consequently, you can write programs that expect an object with a particular interface, knowing that any object that has the correct interface will accept the request.

## 多态（polymorphism）
- dynamic binding lets you **substitute objects that have identical（same） interfaces for each other at run-time**. 
- This substitutability is known as **polymorphism**, and it's a key concept in object-oriented systems.
- polymorphism  lets a client object *make few assumptions* about other objects beyond supporting a particular interface. 
- Polymorphism *simplifies the definitions of clients, decouples objects from each other, and lets them vary their relationships to each other at run-time*.



# 明确对象实现

# 复用机制
Most people can understand concepts like objects, interfaces,classes, and inheritance. The challenge lies in applying them to *build flexible, reusable software,* and design patterns can show you how.

## Inheritance vs. Composition
**class inheritance lets you define the implementation of one class(子类) in terms of another's（父类）**. 依照父类定义子类实现

Reuseby subclassing is often referred to as **white-box reuse**. The term "white-box" refers to *visibility*: With inheritance, the internals of parent classes are often visible to subclasses.

Object composition is an alternative to class inheritance. Here, new functionality is obtained by assembling or composing objects to get more complex functionality.
Object composition requires that the objects being composed have *well-defined interfaces*. This style of reuse is called **black-box reuse**, because no internal details of objects are visible. Objects appear only as "black boxes."

### advantages
Class inheritance:
1. defined statically at compile-time and is straightforward to use;
2. makes it easier to modify the implementation being reused by overridden operations;

Object composition :
1. defined dynamically at run-time through objects acquiring references to other objects.
2. requires objects to respect each others' interfaces, which in turn requires carefully designed interfaces that *don't stop you from using one object with many others*.
3. Because objects are accessed *solely through their interfaces*, we **don't break encapsulation**. *Any object can be replaced at run-time by another as long as it has the same type*. 
4. Moreover, because an object's implementation will be written in terms of object interfaces, there are substantially *fewer implementation dependencies*.

Favoring object composition over class inheritance helps you *keep each class encapsulated and focused on one task*. Your classes and class hierarchies will remain small and will be less likely to grow into unmanageable monsters.

### disadvantages
1.  you *can't change the implementations* inherited from parent classes *at run-time* ;
2.  generally worse, *parent classes often define at least part of their subclasses' physical representation.* Because inheritance exposes to a subclass the details of its parent's implementation, it's often said that "**inheritance breaks encapsulation(继承破坏封装)**"；
3.  Implementation dependencies can cause problems when you're trying to reuse a subclass. If any aspect of the inherited implementation not be appropriate for new problem domains, the *parent class must be rewritten or replaced* by something more appropriate. This dependency *limits flexibility and ultimately reusability*. 
One cure for this is to **inherit only from abstract classes**, since they usually provide little or no implementation.

### 注意
- You shouldn't have to create new components to achieve reuse. You should be able to get all the functionality you need just by assembling existing components through object composition.
- Reuse by inheritancemakesit easier to make new components that can be composed with old ones. Inheritance and object composition thus work together.
- *Favor object composition over class inheritance*.


## 委托（Delegation）

# Class Inheritance vs. Interface Inheritance
In short, it's a mechanism for code and representation sharing. In contrast, **interface inheritance** (or subtyping) describes *when an object can be used in place of another*.****