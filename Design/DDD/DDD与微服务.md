#DDD #Design 

DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署

## 约定-服务调用

![[服务调用示意.png]]

第一种是应用服务调用并组装领域服务。此时领域服务会组装实体和实体方法，实现核

心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。

第二种是应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象

## 约定-服务封装与组合
![[服务封装和组合示意.png]]
 
## 约定- 服务与数据视图

![[服务与数据视图.png]]


## 约定-服务内调用严格分层
![[服务内调用严格分层.png]]
 
 
## 约定-领域事件驱动

![[领域事件驱动示意1.png]]

![[领域事件驱动示意2.png]]
  
DDD提倡聚合之间产生的业务协同使用领域事件的方式来完成，领域事件就是将上游聚合处理完成这个动作通过事件的方式抽象，封装完成下游聚合所需的数据，通过消息队列中间件（跨微服务）或本地应用中的消息总线框架（同一个微服务跨聚合）来完成聚合之间业务的解耦。

1. 领域内的事件:
	1. 通过本地事件表存储；
	2. 通过eventbus发布事件

2. 领域外的事件:
	1. 通过消息队列
	2. 通过公共的事件库通信

## 约定-DDD微服务目录结构
 ![[DDD微服务目录结构.png]]
 
 api （方便deploy,供同步调用）
主要包括:
-   dto包，即数据传输对象，即内部接口之间的数据传输字段封装。包括 requestDTO 和 responseDTO 两部分。
-   api接口，即api接口，供feignClient接口继承。
    

### 2、Interfaces（用户接口层）
二级目录：
-   Assembler 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。
-   Facade 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。
-   dto 接口间数据传输的封装
    

### 3、Application（应用层）
二级目录：
-   Service（应用服务）：对多个领域服务或其他微服务应用服务进行封装、编排和组合，对外提供粗粒度的服务。可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。
    
### 4、Domain（领域层）
由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合包内的目录：
-   entity（实体） 存放聚合根、实体、值对象以及工厂模式（处理DO到PO的初始化,DO到PO的初始化，指当聚合根被创建时，聚合内所有依赖的对象将会被同时创建，将所有依赖的DO对象一次性转换为PO对象）相关代码。
-   event（事件） 存放事件实体以及与事件活动相关的业务逻辑代码，分为publish和subscribe目录，publish存放事件发布相关代码，listener存放事件订阅相关代码。
-   service(领域服务) 存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑
-   repository（仓储）仓储实现本应该属于基础层代码，但在微服务架构中的演进过程中会涉及到聚合的拆分，所以这里把仓储层放在这是为了与聚合进行整体迁移方便，其中包括facade、mapper、persistence包，facade为统一为其他层提供服务定义的接口，mapper是各个框架中需实现的mapper接口，persistence用于PO与查询结果和查询条件间的适配。
    

### 5、Infrastructure（基础层）
二级目录：
-   config 主要存放配置相关代码。
-   util 主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码
-   client 存放feignClient。
    

# 参考
[[DDD领域设计基础]]