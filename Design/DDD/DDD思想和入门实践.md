# DDD领域驱动设计设计思想和入门实践

# 后端架构演进
## 传统MVC架构

 ![[MVC架构.png]]
优点：关注前后端分离
缺点：模型层分层太粗，融合了数据处理、业务处理等所有的功能。核心的复杂业务逻辑都放到模型层，导致模型层很乱
适应场景：后端业务逻辑简单的服务，比如接口直接提供对数据库增删改查

## 后端三层架构 
![[后端三层架构.png]]

### 定义
1.  表现层：controller
2.  逻辑层：service
3.  数据访问层：dao
    
优点：逻辑与数据层分离
缺点：模型层分层比较粗，核心的复杂业务逻辑都放到模型层，导致模型层很乱
适应场景：后端业务逻辑简单的服务，比如接口直接提供对数据库增删改查

## 阿里分层架构
![[阿里分层架构.png]]
 
架构来源：参照阿里发布的《阿里巴巴 Java 开发手册 v1.4.0（详尽版）》，将原先的三层架构细化而来

特点：添加了Manager 通用业务处理层。

这一层有两个作用，一、可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；二、也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等RPC接口。

优点：相比于三层方式，添加了通用处理层对接外部平台。上下游对接划分的比较清晰

缺点：核心业务逻辑层没有划分

适应场景：业务逻辑不复杂的常用业务

## DDD分层架构
整洁架构和六边形架构都是DDD架构的一种方式，只不过是视角不同。

### 整洁架构
特点：整洁架构的层就像洋葱片一样，它体现了分层的设计思想

整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。

![[整洁架构.png]]
 
 
## 六边形架构

六边形架构又名“端口适配器架构”。追溯微服务架构的渊源，一般都会涉及到六边形架构。

六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下API网关盛行的主要原因吧。

也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括APP、Web应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。

 ![[六边形架构.png]]
 
 
 DDD四层架构
- 从DDD理论架构（整洁架构/六边形架构）发展而来，而且还经历传统四层架构到优化后到四层架构的演进。最终形成如下图所示。
![[传统四层架构和依赖倒置的四层架构.png]] 
 
- 在最早的传统四层架构中，其它层都依赖于基础层，基础层位于核心位置；
- DDD 中领域层才是软件的核心，采用了依赖倒置（Dependency inversion principle,DIP）的设计，优化了传统的四层架构，实现了各层对基础层的解耦。

# DDD四层架构详解
![[DDD四层架构.png]]
 
 
## 分层定义
- *用户接口层*：用于提供统一对外的接口，同样一个应用服务可能用于不同的端，入参和出参不太一样，所以在上游添加一个用户接口层对不同格式入参出参进行处理，提供对应用服务层的复用。
- *应用层* ：对各个*领域服务或其他微服务的提供的接口进行编排*，协作完成业务操作。应用服务粒度较粗，需要注意可复用性。应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。另外，应用层代码较薄，不包含业务规则或逻辑，主要是控制业务流程走向，逻辑部分委托给领域层。
- *领域层* ：主要包含实体类、值对象类、事件类、领域服务。领域服务供应用层调用，实现业务的规则和逻辑，但对于只与单一实体自己相关的一些动作，这部分逻辑由实体类自己来实现。
- *基础层* ：基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等
    

## 特点
1.  数据、缓存等都视为基础层， 可以被所有层调用
2.  抽离了领域层，负责核心业务逻辑处理，领域层调用外部依赖全部通过接口，以保证领域层的100%单测覆盖率
3.  应用层聚合多个领域层的能力，只做功能的组合、转发，不负责具体业务逻辑

### 优点
相比于三层方式，更关注领域服务，即业务核心逻辑的划分、收敛
### 缺点
分层复杂， 如果业务逻辑简单没有必要
### 适应场景
*业务复杂的业务*

## 和传统三层架构的对比
![[DDD和传统三层架构对比.png]]
 
DDD四层架构也基于传统三层架构的，不同点有以下几方面：
1.  关注点不一样：三层架构关注请求调用顺序；DDD架构关注领域服务。
2.  横向划分方式不一样：三层架构主要关注纵向划分，对横向划分没有约定；DDD架构更关注纵向，即：多个领域层之间划分及交互方式。
3.  对资源的定位不一样：三层架构把所有依赖的数据都放到数据访问层；DDD架构只将领域强关联的数据放到Repository中，其他比如API层缓存、文件等都当成基础服务来处理。
    

## 小结

- DDD 分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。
- DDD 分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。
- 另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用 DAO 方式；
- DDD 分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过*依赖倒置*实现各层对基础资源的解耦。
- 仓储又分为两部分：
	- 仓储接口和仓储实现。
	- 仓储接口放在领域层中，仓储实现放在基础层。
- 原来三层架构通用的第三方工具包、驱动、Common、Utility、Config 等通用的公共的资源类统一放到了基础层

DDD四层架构，它实现了：
-   高内聚：分层的设计可以简化系统设计，让不同的层专注做某一模块的事
-   低耦合：层与层之间通过接口或API来交互，依赖方不用知道被依赖方的细节
-   复用：分层之后可以做到很高的复用
-   扩展性：分层架构可以让我们更容易做横向扩展
    

如果系统没有分层，当业务规模增加或流量增大时我们只能针对整体系统来做扩展。分层之后可以很方便的把一些模块抽离出来，独立成一个系统。

# DDD微服务实践
## DDD与微服务

DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署

## 约定-服务调用

![[服务调用示意.png]]

第一种是应用服务调用并组装领域服务。此时领域服务会组装实体和实体方法，实现核

心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。

第二种是应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象

## 约定-服务封装与组合
![[服务封装和组合示意.png]]
 
## 约定- 服务与数据视图

![[服务与数据视图.png]]


## 约定-服务内调用严格分层
![[服务内调用严格分层.png]]
 
 
## 约定-领域事件驱动

![[领域事件驱动示意1.png]]

![[领域事件驱动示意2.png]]
  
DDD提倡聚合之间产生的业务协同使用领域事件的方式来完成，领域事件就是将上游聚合处理完成这个动作通过事件的方式抽象，封装完成下游聚合所需的数据，通过消息队列中间件（跨微服务）或本地应用中的消息总线框架（同一个微服务跨聚合）来完成聚合之间业务的解耦。

1. 领域内的事件:
	1. 通过本地事件表存储；
	2. 通过eventbus发布事件

2. 领域外的事件:
	1. 通过消息队列
	2. 通过公共的事件库通信

## 约定-DDD微服务目录结构
 ![[DDD微服务目录结构.png]]
 
 api （方便deploy,供同步调用）
主要包括:
-   dto包，即数据传输对象，即内部接口之间的数据传输字段封装。包括 requestDTO 和 responseDTO 两部分。
-   api接口，即api接口，供feignClient接口继承。
    

### 2、Interfaces（用户接口层）
二级目录：
-   Assembler 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。
-   Facade 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。
-   dto 接口间数据传输的封装
    

### 3、Application（应用层）
二级目录：
-   Service（应用服务）：对多个领域服务或其他微服务应用服务进行封装、编排和组合，对外提供粗粒度的服务。可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。
    
### 4、Domain（领域层）
由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合包内的目录：
-   entity（实体） 存放聚合根、实体、值对象以及工厂模式（处理DO到PO的初始化,DO到PO的初始化，指当聚合根被创建时，聚合内所有依赖的对象将会被同时创建，将所有依赖的DO对象一次性转换为PO对象）相关代码。
-   event（事件） 存放事件实体以及与事件活动相关的业务逻辑代码，分为publish和subscribe目录，publish存放事件发布相关代码，listener存放事件订阅相关代码。
-   service(领域服务) 存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑
-   repository（仓储）仓储实现本应该属于基础层代码，但在微服务架构中的演进过程中会涉及到聚合的拆分，所以这里把仓储层放在这是为了与聚合进行整体迁移方便，其中包括facade、mapper、persistence包，facade为统一为其他层提供服务定义的接口，mapper是各个框架中需实现的mapper接口，persistence用于PO与查询结果和查询条件间的适配。
    

### 5、Infrastructure（基础层）
二级目录：
-   config 主要存放配置相关代码。
-   util 主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码
-   client 存放feignClient。
    

# DDD领域设计基础
## 目的
- 首先设计业务领域，明确业务需求，从最开始就让


### 1、聚合根
1）如果把聚合比作组织，聚合根则是组织的负责人，聚合根也叫做根实体，它不仅仅是实体，还是实体的管理者；

2）聚合根作为实体，具备自己的业务属性，业务行为，业务逻辑；

3）聚合根作为聚合的管理者，在聚合内部，负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑；

4）在聚合之间：聚合根是聚合对外的接口人，以聚合根ID的方式接受外部请求和任务，实现上下文中的聚合之间的业务协同；

5）聚合之间通过聚合根ID关联引用，如果需要访问其他聚合的实体，先访问聚合根，再导航到聚合内部的实体；即聚合外部对象不能直接访问聚合内的实体；

6）聚合解决的问题： 复杂数据模型缺少统一的业务规则控制而导致的聚合，实体之间数据不一致的问题；

7）聚合根是实体，具备唯一标识，有独立的生命周期，一个聚合只有一个聚合根，聚合根在聚合之内采用对象引用依赖的方式对实体和值对象进行组织和协调，聚合根和聚合根之间通过唯一ID进行聚合之间的协同；

#### 注意
- 聚合根和聚合内其他实体的关系是整体和部分的关系，是 UML 里面**组合**的关系；
- 可以通过*聚合根访问聚合内的其他实体*；
- 聚合划分依据：*语义相关、功能相关*
- 聚合和聚合相关，通过聚合根 ID 关联，如在本聚合根中包含其他聚合根的 id。

### 2、实体
1）实体着重唯一性和延续性，不在意属性（阅读数、转发数）的变化，它还是原来那个它；

2）实体具备ID标识，可以通过ID进行相等性比较，实体在聚合内唯一，但是状态可变，它依附于聚合根，它的生命周期由聚合根管理，实体一般都会持久化，跟数据持久化对象（PO）存在多种对应关系（一对一，一对多，多对一，1对0），实体可以引用聚合中的聚合根，实体，值对象；

### 3、值对象
1）值对象着重描述性，对属性的变化很敏感，属性变了，它就不是原来那个它；

2）值对象无ID,不可变，无生命周期，用完即失效，值对象之间通过属性值判断相等性，他的核心是值，是一组概念完整的属性集合，用于描述实体的特征和状态，值对象尽量只引用值对象；

### 4、领域事件

1）领域事件发生在微服务内部，引入事件总线（EVENT BUS）；发生在微服务外部，引入消息中间件；

2）领域事件实体类放在领域层聚合的event目录结构下。领域事件的订阅建议放在应用层的event目录结构下。领域事件发布相关代码放在领域层或者应用层都可以。

### 5、领域服务
1）领域服务通过对多个实体各实体方法进行组合和编排，完成多个实体组合的核心业务逻辑；

2）跨多个实体的业务逻辑在聚合根方法和领域服务中都可以实现。建议将这类业务逻辑尽量放在领域服务中实现，避免聚合根内的业务逻辑过于庞杂；

3）一个聚合可以建立一个领域服务类，可以将聚合中所有的领域服务都在这个领域服务类中实现；

### 6、工厂和仓储
1）一个聚合只有一个仓储；

2）仓储包括仓储接口和仓储实现，通过依赖倒置（DIP）原则实现应用业务逻辑与数据库资源逻辑的解耦；

3）聚合可以通过工厂和仓储模式两者结合，完成聚合内实体和值对象等DO对象的构建、数据初始化和持久化；

### 7、持久化对象
1）持久化对象PO主要完成DO对象的数据库持久化操作，PO一般与数据库表是一对一的关系；

### 8、应用服务
1.  应用层主要是应用服务和领域事件的发布和订阅；
[应用服务和领域服务的区别](https://enterprisecraftsmanship.com/posts/domain-vs-application-services/)

2. 应用层服务参数：command、event、query或者简单情况下用 Id。
  

# DDD领域设计实践
## DDD设计思路
### 战略设计
- 从业务视角出发，建立业务领域模型；
- 划分领域边界，建立通用语言的限界上下文；
- 限界上下文可以作为微服务设计的参考边界。

- 业务领域可按照：核心领域、支撑领域、通用领域，划分边界；
- 但是领域都是业务相关的；
- 如风险控制在银行金融业务中一般是作为支撑领域，但是在一些领域可能就是核心领域。

### 战术设计
- 从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地；
- 包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现

## DDD设计方法
1.  一步：在事件风暴（或者*四色分析*）中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。
    
2.  第二步：务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。
    
3.  第三步：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图根据领域实体之间的业务关联性，将业里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离
    

# 总结
- 贫血对象和富对象

![[架构设计目标总结.png]]




# 参考文档
领域驱动设计

https://mp.weixin.qq.com/s/kpXklmidsidZEiHNw57QAQ

https://mp.weixin.qq.com/s/MU1rqpQ1aA1p7OtXqVVwxQ

https://mp.weixin.qq.com/s/1bcymUcjCkOdvVygunShmw

https://www.cnblogs.com/junzi2099/p/13682154.html

[应用服务和领域服务的区别](https://enterprisecraftsmanship.com/posts/domain-vs-application-services/)

