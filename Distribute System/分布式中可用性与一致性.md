#Distribute-System #CAP #Availability #Consistency #Todo 

# 背景
可用性（Availability）和一致性（Consistency）是分布式系统的基本问题，著名的CAP理论定义过分布式环境下二者不可兼得的关系。
Paxos协议号称是史上最简单的分布式系统一致性算法并获得图灵奖；
开源产品ZooKeeper实现的ZAB协议号称超越Paxos，它们之间究竟有什么联系？

## CAP理论
CAP理论由加州大学伯克利分校的计算机教授Eric Brewer在2000年提出；
其核心思想是：任何基于网络的数据共享系统**最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个**，三个特性的定义如下：

-   **数据一致性**：等同于所有节点拥有数据的最新版本
-   **可用性**：数据具备高可用性
-   **分区容忍**：容忍网络出现分区，分区之间网络不可达

在大规模的分布式环境下，网络分区是必须容忍的现实，于是只能在可用性和一致性两者间做出选择，CAP理论似乎给分布式系统定义了一个悲观的结局，一时间大家都按照CAP理论在对热门的分布式系统进行判定，譬如认为HBase是一个CP系统，Cassandra是AP系统，我个人认为这是不严谨的，理由是CAP理论是对分布式系统中一个数据无法同时达到可用性和一致性的断言，而一个系统中往往存在很多类型的数据，部分数据（譬如银行账户中的余额）是需要强一致性的，而另外一部分数据（譬如银行的总客户数）并不要求强一致性，所以拿CAP理论来划分整个系统是不严谨的， CAP理论带来的价值是指引我们在设计分布式系统时需要区分各种数据的特点，并仔细考虑在小概率的网络分区发生时究竟为该数据选择可用性还是一致性。

对CAP理论的另外一种误读是系统设计时选择其一而完全不去优化另外一项，可用性和一致性的取值范围并不是只有0和1，可用性的值域可以定义成0到100%的连续区间，而一致性也可分为强一致性、弱一致性、读写一致性、最终一致性等多个不同的强弱等级，细想下去CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到。（注：这里用“极致可用性”而不用“100%可用性”是因为即使不考虑一致性，多台server组成的分布式系统也达不到100%的可用性，如果单个server的可用性是P，那n台server的极致可用性是![](http://img3.tbcdn.cn/L1/461/1/cc9c8bd3e008bf72a57f259ff14b79384dc1ae68), 公式的意思是只要任何一台或多台server可用就认为系统都是可用的）

虽然无法达到同时达到强一致性和极致可用性，但我们可以根据数据类型在二者中选择其一后去优化另外一个，Paxos协议就是一种在保证强一致性前提下把可用性优化到极限的算法。


## Paxos协议

Paxos协议由Leslie Lamport最早在1990年提出，由于Paxos在云计算领域的广泛应用Leslie Lamport因此获得了2013年度图灵奖。

Paxos协议提出只要系统中2f+1个节点中的f+1个节点可用，那么系统整体就可用并且能保证数据的强一致性，它对于可用性的提升是极大的，仍然假设单节点的可用性是P，那么2f+1个节点中任意组合的f+1以上个节点正常的可用性P(total)=![](http://img1.tbcdn.cn/L1/461/1/d8f33a62f83c661dc33b354779cdd03481d4a66e),又假设P=0.99，f=2，P(total)=0.9999901494，可用性将从单节点的2个9提升到了5个9，这意味着系统每年的宕机时间从87.6小时降到0.086小时，这已经可以满足地球上99.99999999%的应用需求。

Leslie写的两篇论文：《The Part-Time Parliament》和《Paxos Made Simple》比较完整的阐述了Paxos的工作流程和证明过程，Paxos协议把每个数据写请求比喻成一次提案（proposal），每个提案都有一个独立的编号，提案会转发到提交者（Proposer）来提交，提案必须经过2f+1个节点中的f+1个节点接受才会生效，2f+1个节点叫做这次提案的投票委员会(Quorum)，投票委员会中的节点叫做Acceptor，Paxos协议流程还需要满足两个约束条件： a）Acceptor必须接受它收到的第一个提案；b）如果一个提案的v值被大多数Acceptor接受过，那后续的所有被接受的提案中也必须包含v值（v值可以理解为提案的内容，提案由一个或多个v和提案编号组成）。

Paxos协议流程划分为两个阶段，第一阶段是Proposer学习提案最新状态的准备阶段；第二阶段是根据学习到的状态组成正确提案提交的阶段，完整的协议过程如下：

阶段 1.

1.  Proposer选择一个提案编号_n_ ，然后向半数以上的Acceptors发送编号为 _n_ 的prepare请求。
2.  如果一个Acceptor收到一个编号为_n_ 的prepare请求，且 _n_ 大于它已经响应的所有prepare请求的编号，那么它就会保证不会再通过(accept)任何编号小于 _n_ 的提案，同时将它已经通过的最大编号的提案(如果存在的话)作为响应。 

阶段 2.

1.  如果Proposer收到来自半数以上的Acceptor对于它的prepare请求(编号为_n_ )的响应，那么它就会发送一个针对编号为 _n_ ，value值为 _v_ 的提案的accept请求给Acceptors，在这里 _v_ 是收到的响应中编号最大的提案的值，如果响应中不包含提案，那么它就是任意值。
2.  如果Acceptor收到一个针对编号_n_ 的提案的accept请求，只要它还未对编号大于 _n_ 的prepare请求作出响应，它就可以通过这个提案。

用时序图来描述Paxos协议如图3所示：
![[Pasted image 20220831175343.png]]


# 参考
1. [浅谈分布式系统的基本问题：可用性与一致性](https://blog.csdn.net/weixin_40911543/article/details/87921082)