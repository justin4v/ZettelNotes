#Distribute-System #CAP #Availability #Consistency #Todo 

# 背景
- **可用性（Availability）** 和 **一致性（Consistency）** 是分布式系统的基本问题；
- 著名的 **CAP 理论** 定义了过分布式环境下二者不可兼得的关系。
- **Paxos 协议**号称是最简单的**分布式系统一致性算法**并获得图灵奖；
- 开源产品 ZooKeeper 实现的 **ZAB 协议**号称超越 Paxos，它们之间究竟有什么联系？

# CAP理论
- CAP 理论由加州大学伯克利分校的计算机教授 *Eric Brewer* 在 *2000 年*提出；
- 核心思想是：任何基于网络的数据共享系统**最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个**。
- 三个特性的定义如下：
	1.   **数据一致性**：等同于所有节点拥有数据的最新版本
	2.   **可用性**：数据具备高可用性
	3.   **分区容忍**：容忍网络出现分区，分区之间网络不可达

## CAP的理解
- 在大规模的分布式环境下，**网络分区（Partition）是必须容忍的现实**，于是**只能在可用性（Availability）和一致性（Consistency）间选择一个**；
- CAP 理论似乎给分布式系统定义了一个悲观的结局，一时间都按照 CAP 理论在对热门的分布式系统进行判定，认为 *HBase 是一个 CP 系统*，*Cassandra 是 AP 系统*，理由是 CAP 理论断言分布式系统中一个数据*无法同时达到可用性和一致性*；
- 但是系统中往往存在很多类型的数据，**部分数据（如银行账户中的余额）需要强一致性**的，而另外一**部分数据（如银行的总客户数）并不要求强一致性**，所以拿 CAP 理论来划分整个系统是不严谨的；
- CAP 理论带来的价值：在设计分布式系统时需要区分各种数据的特点，并仔细考虑在小概率的网络分区发生时究竟为该数据选择可用性还是一致性。

对CAP理论的另外一种误读是系统设计时选择其一而完全不去优化另外一项，可用性和一致性的取值范围并不是只有0和1，可用性的值域可以定义成0到100%的连续区间，而一致性也可分为强一致性、弱一致性、读写一致性、最终一致性等多个不同的强弱等级，细想下去CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到。（注：这里用“极致可用性”而不用“100%可用性”是因为即使不考虑一致性，多台server组成的分布式系统也达不到100%的可用性，如果单个server的可用性是P，那n台server的极致可用性是![](http://img3.tbcdn.cn/L1/461/1/cc9c8bd3e008bf72a57f259ff14b79384dc1ae68), 公式的意思是只要任何一台或多台server可用就认为系统都是可用的）

虽然无法达到同时达到强一致性和极致可用性，但我们可以根据数据类型在二者中选择其一后去优化另外一个，Paxos协议就是一种在保证强一致性前提下把可用性优化到极限的算法。


## Paxos协议

Paxos协议由Leslie Lamport最早在1990年提出，由于Paxos在云计算领域的广泛应用Leslie Lamport因此获得了2013年度图灵奖。

Paxos协议提出只要系统中2f+1个节点中的f+1个节点可用，那么系统整体就可用并且能保证数据的强一致性，它对于可用性的提升是极大的，仍然假设单节点的可用性是P，那么2f+1个节点中任意组合的f+1以上个节点正常的可用性P(total)=![](http://img1.tbcdn.cn/L1/461/1/d8f33a62f83c661dc33b354779cdd03481d4a66e),又假设P=0.99，f=2，P(total)=0.9999901494，可用性将从单节点的2个9提升到了5个9，这意味着系统每年的宕机时间从87.6小时降到0.086小时，这已经可以满足地球上99.99999999%的应用需求。

Leslie写的两篇论文：《The Part-Time Parliament》和《Paxos Made Simple》比较完整的阐述了Paxos的工作流程和证明过程，Paxos协议把每个数据写请求比喻成一次提案（proposal），每个提案都有一个独立的编号，提案会转发到提交者（Proposer）来提交，提案必须经过2f+1个节点中的f+1个节点接受才会生效，2f+1个节点叫做这次提案的投票委员会(Quorum)，投票委员会中的节点叫做Acceptor，Paxos协议流程还需要满足两个约束条件： a）Acceptor必须接受它收到的第一个提案；b）如果一个提案的v值被大多数Acceptor接受过，那后续的所有被接受的提案中也必须包含v值（v值可以理解为提案的内容，提案由一个或多个v和提案编号组成）。

Paxos协议流程划分为两个阶段，第一阶段是Proposer学习提案最新状态的准备阶段；第二阶段是根据学习到的状态组成正确提案提交的阶段，完整的协议过程如下：

阶段 1.

1.  Proposer选择一个提案编号_n_ ，然后向半数以上的Acceptors发送编号为 _n_ 的prepare请求。
2.  如果一个Acceptor收到一个编号为_n_ 的prepare请求，且 _n_ 大于它已经响应的所有prepare请求的编号，那么它就会保证不会再通过(accept)任何编号小于 _n_ 的提案，同时将它已经通过的最大编号的提案(如果存在的话)作为响应。 

阶段 2.

1.  如果Proposer收到来自半数以上的Acceptor对于它的prepare请求(编号为_n_ )的响应，那么它就会发送一个针对编号为 _n_ ，value值为 _v_ 的提案的accept请求给Acceptors，在这里 _v_ 是收到的响应中编号最大的提案的值，如果响应中不包含提案，那么它就是任意值。
2.  如果Acceptor收到一个针对编号_n_ 的提案的accept请求，只要它还未对编号大于 _n_ 的prepare请求作出响应，它就可以通过这个提案。

用时序图来描述Paxos协议如图3所示：
![[Paxos协议基本流程.png]]

通过上述流程 Paxos 保证数据的强一致性。
上述Paxos协议流程看起来比较复杂，是因为要保证很多边界条件下的协议完备性，譬如初试值为空、两个Proposer同时提交提案等情况，但Paxos协议的核心可以简单描述为：Proposer先从大多数Acceptor那里学习提案的最新内容，然后根据学习到的编号最大的提案内容组成新的提案提交，如果提案获得大多数Acceptor的投票通过就意味着提案被通过。由于学习提案和通过提案的Acceptor集合都超过了半数，所以一定能学到最新通过的提案值，两次提案通过的Acceptor集合中也一定存在一个公共的Acceptor，在满足约束条件b时这个公共的Acceptor时保证了数据的一致性，于是Paxos协议又被称为多数派协议。

Paxos协议的真正伟大之处在于它的简洁性，Paxos协议流程中任何消息都是可以丢失的，一致性保证并不依赖某个特殊消息传递的成功，这极大的简化了分布式系统的设计，极其匹配分布式环境下网络可能分区的特点，相比较在Paxos协议之前的“两阶段提交（2PC）”也能保证数据强一致性，但复杂度相当高且依赖单个协调者的可用性。


# 参考
1. [浅谈分布式系统的基本问题：可用性与一致性](https://blog.csdn.net/weixin_40911543/article/details/87921082)