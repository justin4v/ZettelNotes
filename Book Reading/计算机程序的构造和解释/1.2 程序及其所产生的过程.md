#SICP 
# Procedure vs. Process
- SICP 上下文中：
	- Procedure is **the description of the process**.
	- Process is **the result (in a broad meaning, not just a returned value) of applying a procedure to arguments**: all the contexts that are set up, variables with defined or set values, all the computation that will take place, etc.
	- **procedure is a blueprint**, a schematic of the building;
	- **process is actual building construction**.
- **程序（procedure）** 是一种描述一个**计算过程（computational process）局部演化（local evolution） 的模式**； ^8b3208
- 描述了计算过程中每个步骤是怎样*基于前面的步骤建立起来*。

在有了一个刻画计算过程的程序描述之后，当然希望能做出一些有关这一计算过程的*整体或全局行为*的论断。
一般来说这是非常困难的，但至少还是可以试着去*描述过程演化的一些典型模式（总结出典型的 procedure）*。

# 线性递归和迭代
有阶乘函数：
```
n!＝n·(n－1)·(n－2) …3·2·1
```

## 递归观点
有如下认识：对于一个正整数n，n!就等于n乘以（n－1）!：
```
n!＝n·[(n－1)·(n－2) …3·2·1]
  ＝n·(n－1)!
```

再注意到 `1!` 就是1，这些认识可以翻译成一个程序（procedure）：
```scheme
(define (factorial n)
		(if (= n 1)
		1
		(* n (factorial (- n 1)))))
```

利用[[1.1 基本元素#过程应用的代换模型The Substitution Model for Procedure Application|代换模型]]，可以得到这一 Procedure 在计算 `6!`时表现出的行为，如下所示：

![[6!的计算过程示例1.png]]

## 迭代观点
采用另一种*不同的观点*计算阶乘：
- 将计算阶乘 `n!` 的规则描述为：先乘 1 和 2，而后将得到的结果乘以3，而后再乘以4，这样下去直到达到 n。
- 更形式地说:
	1. 要维持一个*变动中的乘积 `product`;*
	2. 一个从*1 到 n 的计数器 counter*。
	3. *这一计算过程可以描述为 counter 和 product 如下一步步的[[#^8b3208|演化（evolution）]]过程*，都按照下面规则演化：
	   ```
		product ← counter·product 
		counter ← counter + 1
		```

可以看到：*n! 就是计数器 counter 为 n+1 时product 的值*。  

将这一描述重构为一个计算阶乘的 Procedure：
```scheme
(define (factorial n)
  		(fact-iter 1 1 n))
  
(define (fact-iter product counter max-count)
		  (if (> counter max-count)
			  product
			  (fact-iter (* counter product)
						 (+ counter 1)
						 max-count)))
```

应用替换模型来查看 6! 的计算过程，如下：

![[6!的线性计算过程.png]]

## 比较
### 相同点
- 计算的都是同一个定义域里的同一个数学函数；
- 都使用与 n 正比的步骤数目去计算出 n!；

### 不同点
- 第一个计算过程的代换模型揭示出一种*先逐步展开而后收缩*的形状；
- 展开阶段表现为一系列推迟进行的运算，收缩阶段表现为运算的实际执行；
- 