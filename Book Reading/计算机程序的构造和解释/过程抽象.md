# 基本元素
一个强有力的程序设计语言：
- 不仅是一种指挥计算机执行任务的方式；
- 还应该成为一种*框架*，使我们能够*在其中组织自己有关计算过程的思想*。
- 要注意语言所提供的、能够***将简单的认识组合以形成更复杂认识*的方法**方面。

每一种强有力的语言都为此提供了三种机制：
-   **基本表达形式 primitive expressions 元表达式**，表示语言所关心的最简单的个体。
-   **组合的方法 means of combination**，通过组合可以由较简单的东西构造出复合的元素。
-   **抽象的方法 means of abstraction**，通过抽象可以为复合对象命名，并将它们当作单元去操作。

以 [[LISP]] 为例，介绍这三种机制

# 表达式
## 数字
*数字*是基本表达式（primitive expression）之一
键入 `486`
显示 `486`

## 基本运算
+ 和 \* 等*基本运算*也是基本表达式（primitive expression）


## 组合表达式
组合表达式是：*用一对括号（界定表达式范围）括起一些表达式，形成一个表（list），表示一个过程应用*。
除了基本表达式外（可以单个出现），**多个表达式都需要用括号括起**。

```scheme
(+ 137 349)
486
(- 1000 334)
666
(* 5 99)
495
(/ 10 5)
2
```

1. 在表里最左的元素称为**运算符(operator)**，其他元素都称为**运算对象(operands)**；
2. 求值的方式是将*由运算符所刻画的过程应用于（apply to）有关的实际参数*；
3. 运算符放在所有运算对象左边，称为**前缀表示（prefix notation）**，优点
	1. *可以带有任意数量的参数*而不会出现歧义。
	2. *可以直接扩充*，允许出现*组合嵌套*的情况：
		```scheme
		(+ (* 3 5) (- 10 6)) 
		19
		```
		

## 解释器的基本运作方式
（交互式）解释器的基本运作方式是一个循环：
1. 从终端读入一个表达式；
2. 对表达式求值；
3. 打印出结果。

人们常常说这种模式的解释器运行在一个**读入-求值-打印循环（read-eval-print loop）** 之中

# 命名(Naming)和环境(Environment)
## 命名
程序设计语言需要提供一种*通过名字去使用计算对象的方式*，也就是**命名系统**（参考：[[Naming]]）。
- **名称标识符称为变量(variable)**；
- *变量的值(value)就是所对应的对象*。

在 Lisp 方言Scheme里，给*事物命名通过 define 完成*，输入：  
```scheme
(define size 2)  
```
解释器会*将值 2 与名字 size 相关联*。

### 命名的抽象
`define` 是 lisp 中最简单的**抽象方法**：允许用**简单的名字引用复杂组合运算的结果**。

一般而言，计算得到的对象完全可以具有非常复杂的结构，如果每次需要使用时，都必须*记住并重复地写出细节*，将极端不方便。

## 环境
Lisp(Scheme) 中可将值与名称符号关联（naming），而后又能获取值。
解释器必须具有*存储能力*，以便存储对*名称-值对*的跟踪（keeps track of the name-object pairs）。

这种存储被称为**环境**（更精确地说，是*全局环境*，以后将看到，在一个计算过程中完全可能涉及若干不同环境）。

环境是具有普遍性的概念，为求值过程的进行提供了一种**上下文（context）**，用于确定表达式中各个符号的意义。

# 求值
本章的一个目标，就是要把与过程性思维有关的各种问题隔离出来。

求值一个组合式过程如下：
1) 求值该组合式的各个子表达式。
	> Evaluate the subexpressions of the combination.
2) 将*最左表达式（运算符 operator）的值*作为过程（procedure）应用于实际参数，实际参数就是*其他子表达式（运算对象 operands）*  的值。
	> Apply the procedure that is the value of the leftmost subexpression (the *operator*) to the arguments that are the values of the other subexpressions (the *operands*).

## 递归
以上的简单规则显示出计算过程里的一些**具有普遍性的重要问题**。
1. 由第一步可知，为了对一个组合式的求值，需要先对组合式里的每个元素执行同样的求值过程。在性质上，这一求值过程是**递归（recursive）** 的：
> *求值中包含调用规则本身的步骤 *。It includes, as one of its steps, the need to invoke the rule itself.

2. 进一步的观察发现，反复地应用第一个步骤，总可以到达求值中的某一点，在这里遇到的*不是组合式而是基本表达式*，例如*数、基本运算符或者其他名字（变量）*。有如下规定：
	-   数的值就是它们所表示的数值。
	-   基本运算符（如+、\*）的值就是能完成相应操作的机器指令序列。
	-   其他名字的值就是在环境中关联于这一名字的那个对象。

### 递归树形表示
特别注意采用*递归的思想可以简洁地描述深度嵌套的情况*。如果不用递归，我们就需要把这种情况看成相当复杂的计算过程。

```scheme
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```
上例中需要将求值规则应用于4个不同的组合式。
用一棵树、图形化表示这一组合式的求值过程：
1. *每个组合式用一个带分支的结点(分支结点,非终端结点)表示*，它的分支是组合式里的**运算符和运算对象**。
2. 叶子（终端）结点表示的是**基本运算符或者数值**。

如下图：
![[组合求值的树形表示示例.png]]

> 以树的观点看这种求值过程，可以*设想运算对象的值从下（叶子节点）向上穿行（一直到根节点）*，从叶子结点开始，而后*在越来越高的层次中组合起来*。
> 
> 一般而言，我们把递归看作一种*处理层次性结构的（像树这样的对象）强有力的技术*。事实上，“**值向上穿行(percolate values upward)**”形式的求值是一类更一般的计算过程的一个例子，这种计算过程称为**树形积累(tree accumulation)**。

参考：
1. [[树有关术语]]
