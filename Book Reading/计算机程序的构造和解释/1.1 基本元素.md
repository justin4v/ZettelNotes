# 基本元素
一个强有力的程序设计语言：
- 不仅是一种指挥计算机执行任务的方式；
- 还应该成为一种*框架*，使我们能够*在其中组织自己有关计算过程的思想*。
- 要注意语言所提供的、能够***将简单的认识组合以形成更复杂认识*的方法**方面。

每一种强有力的语言都为此提供了三种机制：
-   **基本表达形式 primitive expressions 元表达式**，表示语言所关心的最简单的个体。
-   **组合的方法 means of combination**，通过组合可以由较简单的东西构造出复合的元素。
-   **抽象的方法 means of abstraction**，通过抽象可以为复合对象命名，并将它们当作单元去操作。

以 [[LISP]] 为例，介绍这三种机制

# 表达式Expressions
## 数字
*数字*是基本表达式（primitive expression）之一
键入 `486`
显示 `486`

## 基本运算
+ 和 \* 等*基本运算*也是基本表达式（primitive expression）


## 组合表达式
**组合式（combinations）** ：*用一对括号（界定表达式范围）括起一些表达式，形成一个表（list），表示一个过程应用*。
除了基本表达式外（可以单个出现），**多个表达式都需要用括号括起**。

```scheme
(+ 137 349)
486
(- 1000 334)
666
(* 5 99)
495
(/ 10 5)
2
```

1. 在表里最左的元素称为**运算符(operator)**，其他元素都称为**运算对象(operands)**；
2. 求值的方式是将*由运算符所刻画的过程应用于（apply to）有关的实际参数*；
3. 运算符放在所有运算对象左边，称为**前缀表示（prefix notation）**，优点
	1. *可以带有任意数量的参数*而不会出现歧义。
	2. *可以直接扩充*，允许出现*组合嵌套*的情况：
		```scheme
		(+ (* 3 5) (- 10 6)) 
		19
		```
		

## 解释器的基本运作方式
（交互式）解释器的基本运作方式是一个循环：
1. 从终端读入一个表达式；
2. 对表达式求值；
3. 打印出结果。

人们常常说这种模式的解释器运行在一个**读入-求值-打印循环（read-eval-print loop）** 之中

# 命名(Naming)和环境(Environment)
## 命名Naming
程序设计语言需要提供一种*通过名字去使用计算对象的方式*，也就是**命名系统**（参考：[[Naming]]）。
- **名称标识符称为变量(variable)**；
- *变量的值(value)就是所对应的对象*。

在 Lisp 方言Scheme里，给*事物命名通过 define 完成*，输入：  
```scheme
(define size 2)  
```
解释器会*将值 2 与名字 size 相关联*。

### 命名的抽象
`define` 是 lisp 中最简单的**抽象方法**：允许用**简单的名字引用复杂组合运算的结果**。

一般而言，计算得到的对象完全可以具有非常复杂的结构，如果每次需要使用时，都必须*记住并重复地写出细节*，将极端不方便，所以才将其抽象为一个符号。

## 环境Environment
Lisp(Scheme) 中可将值与名称符号关联（naming），而后又能获取值。
解释器必须具有*存储能力*，以便存储对*名称-值对*的跟踪（keeps track of the name-object pairs）。

这种存储被称为**环境**（更精确地说，是*全局环境*，以后将看到，在一个计算过程中完全可能涉及若干不同环境）。

环境是具有普遍性的概念，为求值过程的进行提供了一种**上下文（context）**，用于确定表达式中各个符号的意义。

# 组合式求值Evaluating Combinations
本章的一个目标，就是要把与过程性思维有关的各种问题隔离出来。

## 一般求值规则
求值一个*组合式（combination）* 过程如下：
1) 求值该组合式的各个子表达式。
	> Evaluate the subexpressions of the combination.
2) 将*最左表达式（运算符 operator）的值*作为过程（procedure）应用于实际参数，实际参数就是*其他子表达式（运算对象 operands）*  的值。
	> Apply the procedure that is the value of the leftmost subexpression (the *operator*) to the arguments that are the values of the other subexpressions (the *operands*).

## 递归
以上的简单规则显示出计算过程里的一些**具有普遍性的重要问题**。
1. 由第一步可知，为了对一个组合式的求值，需要先对组合式里的每个元素执行同样的求值过程。在性质上，这一求值过程是**递归（recursive）** 的：
> *求值中包含调用规则本身的步骤 *。It includes, as one of its steps, the need to invoke the rule itself.

2. 进一步的观察发现，反复地应用第一个步骤，总可以到达求值中的某一点，在这里遇到的*不是组合式而是基本表达式*，例如*数、内部运算符(built-in operators)或者其他符号（变量）*。有如下规定：
	-   数的值就是它们所表示的数值。
	-   内部运算符（如+、\*）的值就是能完成相应操作的机器指令序列。
	-   其他名字的值就是在环境中关联于这一名字的那个对象。

### 递归树形表示
特别注意采用*递归的思想可以简洁地描述深度嵌套的情况*。如果不用递归，我们就需要把这种情况看成相当复杂的计算过程。

```scheme
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```
上例中需要将求值规则应用于4个不同的组合式。
用一棵树、图形化表示这一组合式的求值过程：
1. *每个组合式用一个带分支的结点(分支结点,非终端结点)表示*，它的分支是组合式里的**运算符和运算对象**。
2. 叶子（终端）结点表示的是**基本运算符或者数值**。

如下图：
![[组合求值的树形表示示例.png]]

> 以树的观点看这种求值过程，可以*设想运算对象的值从下（叶子节点）向上穿行（一直到根节点）*，从叶子结点开始，而后*在越来越高的层次中组合起来*。
> 
> 一般而言，我们把递归看作一种*处理层次性结构的（像树这样的对象）强有力的技术*。事实上，“**值向上穿行(percolate values upward)**”形式的求值是一类更一般的计算过程的一个例子，这种计算过程称为**树形积累(tree accumulation)**。

参考：
1. [[树有关术语]]

## 特殊形式 special forms
上面给出的求值规则里并*没有处理定义(Definitions)*。
例如，对 `(define x 3)`的求值并不是将 `define` 应用于它的两个实际参数：符号 x 的值和数值 3。`define`的作用就是为 x 关联一个值（*(define x 3) 并不是一个组合式 combinations*）
1. 一般性求值规则的这种例外称为*特殊形式(special forms)*
2. *每个特殊形式都有自身的求值规则*，各种*不同种类的表达式（和与之相关联的求值规则）组成了程序设计语言的语法形式* 。The various kinds of expressions (each with its associated evaluation rule) constitute the *syntax* of the programming language。

# 复合过程Compound Procedures
Lisp里的某些元素，必然也会出现在任何一种强有力的程序设计语言里。如：

-  *数和算术运算*是基本的数据和过程。Numbers and arithmetic operations are primitive data and procedures.
-   *组合式的嵌套*提供了一种组织起多个操作的方法。Nesting of combinations provides a means of combining operations.
-   定义(Definitions)是一种受限的*抽象技术*，它将名字与值关联。Definitions that associate names with values provide a limited means of abstraction

## 过程定义procedure definitions
**过程定义（procedure definitions）**，是一种*抽象技术*：
1. *为复合操作提供名称*；
2. 而后将这样的操作*作为一个单元(unit)使用*了。

### 过程定义的形式
过程定义的一般形式：
```scheme
(define (⟨name⟩ ⟨formal parameters⟩) 
							⟨body⟩)
```

1. **在环境中过程与符号 ⟨name⟩ 关联**；The ⟨name⟩ is a symbol to be associated with the procedure definition in the environment；
2. ⟨formal parameters⟩ *形式参数是一些名字*，它们用在过程体 ⟨body⟩ 中，用于代表过程实际应用（apply）时的*实际参数*；The ⟨formal parameters⟩ are the names used within the body of the procedure to refer to the corresponding arguments of the procedure；
3.**⟨body⟩ 是一个表达式**，在应用过程时，⟨body⟩ 中的形式参数将被对应的实际参数取代，*对取代后的表达式求值*，得到过程应用结果；The ⟨body⟩ is an expression that will yield the value of the procedure application when the formal parameters are replaced by the actual arguments to which the procedure is applied.
4. ⟨name ⟩ 和 ⟨formal parameters⟩ 放在一对括号里，就像实际调用时写法（`(square 2)`）；The ⟨name ⟩ and the ⟨formal parameters⟩ are grouped within parentheses, just as they would be in an actual call to the procedure being defined.


### 示例
平方：求某个东西的平方，就是用它自身去乘以它自身
表述为
```scheme
(define (square x) (* x x))
```

可以这样理解：
![[平方过程定义的理解.png]]

定义好 square 之后，调用：

```scheme
(square 21)
441
(square (+ 2 5))
49
(square (square 3))
81
```

还可以*用 square 作为基本构件去定义其他过程*。
例如，$$x^2＋y^2$$可以表述为：

```scheme
(+ (square x) (square y))
```


# 过程应用的代换模型The Substitution Model for Procedure Application

对于复合过程，过程应用的计算过程是：

-   将复合过程(Compound Procedures)应用于实际参数，就是*在将过程体 ⟨body⟩ 中的形参用实参取代之后，对过程体求值*。

例如，有如下过程：
```scheme
(define (sum-of-squares x y)
  (+ (square x) (square y)))


(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
```

求 `(f 5)`，求值过程如下：
1. 首先提取出f的体：
```scheme
(sum-of-squares (+ a 1) (* a 2))
```

2. 后用实际参数5代换其中的形式参数：
```scheme
(sum-of-squares (+ 5 1) (* 5 2))
```

问题就被归约为对另一个组合式的求值，其中有两个运算对象，有关的运算符是 sum-of-squares。
`(+ 5 1)`得到 6，`(* 5 2)`得到10，因此我们就需要将sum-of-squares过程用于6和10。

3. 用这两个值代换sum-of-squares体中的形式参数x和y，表达式被归约为：
```scheme
(+ (square 6) (square 10))
```

4. 使用square的定义又可以将它归约为：

```scheme
(+ (* 6 6) (* 10 10))
```

5. 通过乘法又能将它进一步归约为：

```scheme
(+ 36 100)
```

6. 最后得到：

```scheme
136
```

上面描述的这种计算过程称为过程应用的**代换模型（substitution model）**，可以将它看作*确定过程应用的“意义”的一种模型*。

1. 代换模型只是为了*帮助领会过程调用中的情况*，而*不是对解释器实际工作方式的具体描述*；
2. 这里的代换模型只是形式化地考虑解释器求值过程的起点，并不准确完整，后面将给出有关解释器如何工作的一系列模型，更加精细和完整。

## 应用序和正则序Applicative order versus normal order
上节中解释器*首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数*。

另一种求值模型是*先不求出运算对象的值，直到实际需要它们的值时再去做*。
这种求值方式应该首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。

如果采用这一方式，对下面表达式的求值：

```scheme
(f 5)
```

将按照下面的序列逐步展开：

```scheme
(sum-of-squares (+ 5 1) (* 5 2))
(+    (square (+ 5 1))      (square (* 5 2))  )
(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
```

而后是下面归约：

```scheme
(+         (* 6 6)             (* 10 10))
(+           36                   100)
                    136
```

给出了与前面求值模型同样的结果，但其中的计算过程却是不一样的。
特别地，在对下面表达式的归约中，(＋5 1）和（* 5 2）的求值各做了两次：
```scheme
(* x x)
```

### 定义
1. “*完全展开而后归约（fully expand and then reduce）*”的求值模型称为**正则序求值 normal-order evaluation**；
2. “*先求值参数而后应用（evaluate the arguments and then apply）*”的求值模型称为应用序求值applicative-order evaluation。

可以证明，*可以通过替换模拟并能产生出合法值的过程应用，正则序和应用序求值将产生出同样的值*（参见练习1.5中一个“非法”值的例子，其中正则序和应用序将给出不同的结果）。

Lisp 采用*应用序求值*：
1. *能避免对于表达式的重复求值*（例如上面的（＋5 1）和（* 5 2）的情况），提高效率。、
2. 超出了可以采用代换方式模拟求值过程的范围之后，*正则序的处理将变得更复杂*。

# 条件表达式和谓词
## cond
一般形式：
```scheme
(cond (⟨p1⟩ ⟨e1⟩)
	  (⟨p2⟩ ⟨e2⟩)
	  . . .
	  (⟨pn⟩ ⟨en⟩))

```
1. 符号 cond，后加*子句（clauses）表达式对（pair）*：`(⟨p⟩ ⟨e⟩)`；
2. 子句中 p 为*谓词（predicate）表达式*，值为 false 或 true；
3. e 为*序列表达式（consequent expression）*；

### 求值规则
- 首先求值 p1 , 如果为 false，继续向下求值 p2；
- 如果有 predicate 为 true，停止判断，*求值且返回 e 的结果*；
- *如果没有 predicate 为 true，cond 的值是未定义的*。
- else 是特殊符号，可用在 cond 最后一个子句：如果前面的 predicate 都为 false，直接求值返回 else 后的序列表达式。
```scheme
(cond (⟨p1⟩ ⟨e1⟩)
	  (⟨p2⟩ ⟨e2⟩)
	  . . .
	  (else ⟨en⟩))

```

## if
- 是一种*特殊形式（special form）表达式*（参考[[#特殊形式 special forms]]），可以看做 cond 的一种特殊形式。
- 形如：`(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)`
- 求值规则：
	- 如果 predicate 为 true，*求值并返回 consequent 的结果*；
	- *否则，求值并返回 alternative 的结果*。

## 逻辑运算符
### (and ⟨e1⟩ . . . ⟨en⟩)
- **special form**
- 从 e1 开始求值，*如果某个求值结果为假，就不再继续求值，直接返回假*。
- 否则，一直求值直到最后。

### (or ⟨e1⟩ . . . ⟨en⟩)
- **special form**
- 从 e1 开始求值，*如果某个求值结果为真，就不再继续求值，直接返回真*。
- 否则，一直求值直到最后。

### (not ⟨e⟩)
- *普通（ordinary）表达式*
- 值为 e 求出值的反


# 过程作为黑箱（Black-Box）抽象
## 牛顿法求平方根
牛顿逐步逼近法：
1. 如果对 x 的平方根有一个猜测 y；
2. 下一个更加逼近实际平方根的猜测为：( y + x/y )/2;
3. 像这样逐步逼近直到满足要求的精度。

1.可以得到如下的过程：
```scheme
(define (sqrt-iter guess x)
		(if (good-enough? guess x)
			guess
			(sqrt-iter (improve guess x) x)))
```

2.其中，改进猜测值的过程就是求平均值：
```scheme
(define (improve guess x) (average guess (/ x guess)))
```

3.其中
```scheme
(define (average x y) (/ (+ x y) 2))
```

4.此外，精度的计算这里简单用猜测值与实际值的差值在一定范围内（实际应该用猜测值变化的梯度--导数判断）：
```scheme
(define (good-enough? guess x)
		(< (abs (- (square guess) x)) 0.001))
```

5.最后，使用1作为猜测值的起点。

## 过程抽象
1. *sqrt-iter* 的定义是递归的。
2. 其中用到的 square abs 等过程，无需关心其细节，只知道可以得到平方和绝对值结果即可；
3. square 就是一个黑箱，可以认为是一个*过程的抽象（procedural abstraction）*；
4. 可以看做一个占位符（参考：[[），实际实现上可以用任何能计算出平方的过程替换。
