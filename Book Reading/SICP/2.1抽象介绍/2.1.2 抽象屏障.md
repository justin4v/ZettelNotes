#SICP #Abstraction-with-Data 

有理数的例子中
- 所有有理数操作，都是基于构造器 `make-rat` 和选择器 `numer`、`denom定义`。
- 蕴含了 data abstraction 的潜在思想：[[2.1.1 数据抽象导引#^cbe458|数据抽象基本思想]]

# Abstraction Barriers
- 下图形象化地表示了有理数系统的结构：![[有理数中的数据抽象屏障.png]]

> - 水平线表示**抽象屏障(abstraction barriers)**，*隔离了系统中不同的层次*。
> - 在每一层中，抽象屏障把**使用数据抽象的程序（上一层）与实现数据抽象的程序（下一层）分开**。

- 使用有理数的程序（最上面）仅通过有理数 package 中可 “*公开使用(for public use)*” 的 procedure（`add-rat`、`mul-rat`、`div-rat`和 `equal-rat?`）完成对有理数的各种操作；
	- `add-rat` 等是基于构造器 `make-rat` 和 选择器 `numer`和 `denom` 实现的；
	- 构造器和选择器又是基于序对 `pairs` 实现的。只要 `pairs` 可通过 `cons`、`car` 、 `cdr` 操作，`pairs`如何实现与上层没有关系。
	- 每一层次中的 procedure(`cons`/`make-rat`/`add-rat`等) 构成了每层中抽象屏障( abstraction barriers )的接口 interface，将系统中的不同层次联系在一起。

## Advantage
- Abstraction barriers 使 program *容易维护（maintain）和修改（modify）*；
- 任意数据结构，*都可以以不同方式用基本数据结构表示*。
- 表示（representation）方式的选择会对操作它的 procedure 产生影响。
- 对于大型程序而言，表示方式的改变代价极其昂贵，需要在*设计时将依赖于 representation 部分限制在很少的几个 program modules*。

如将有理数约化到最简形式，可以不在构造时，而是在访问有理数中时完成，将导致*另一套不同的构造器和选择器*：
```scheme
(define (make-rat n d)
  (cons n d))
(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
```
- 与前面实现的不同之处在于何时计算gcd：
	- 如果在典型使用中，需要多次访问同一个有理数的分子和分母，最好是在构造有理数时计算 gcd。
	- 如果不是，那么 gcd 的计算 *推迟到访问时* 也许更好。