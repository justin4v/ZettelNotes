#SICP 
# 层次性数据结构
- 层次性 sequence 数据：元素本身也是序列的序列；
- 可认为对象 `（（1 2）3 4）`是通过下面方式构造出来的：
	- `(cons（list 1 2）(list 3 4) )`
	- 包含三个项的 list，其中的第一项本身又是 list `(1 2)`。
- 用序对的语言展示出这一结构的表示形式。
![[sicp-层次性数据示意.png]]


- 认识**元素本身也是序列的序列([[2.2 层次性数据和闭包#闭包 Closure Property|闭包性]])** 的另一种方式，把其看作**树(trees)**。
	- 序列里的元素就是树的分支；
	- 那些本身也是序列的元素就形成了树中的子树。
![[sicp-层次结构的树形表示示意.png]]

## 处理方法

- **递归**是处理树结构的一种自然的工具；
- 常常可以将**对树的操作归结为对其分支的操作**，再将这种操作归结为对*分支的分支的操作*，如此下去，直至达到了树的叶子。
- 作为例子，比较一下 `length` procedure 和下面的 `count-leaves` procedure，这个过程统计出一棵树中树叶的数目：
```lisp
(define x (cons (list 1 2) (list 3 4)))
(length x)
3
(count-leaves x)
4
(list x x)
(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))
2
(count-leaves (list x x))
8
```


- length 的递归方案：
	- 表 x 的 length 是 `(cdr x ) `的length加一;
	- 空表的 ength 是0。

- `count-leaves` 的递归方案与此类似，对于空表的值也相同：
	- 空表的 count-leaves 是 0，
- 但是在递归中，处理一个 list 的 car 时，就必须注意这一 car 本身也可能是树，其树
叶也需要考虑。正确的归约步骤应该是：
- 树 x 的 count-leaves 应该是： x 的 car 的 `count-leaves` 与 x 的 cdr 的 `count-leaves`
之和。
- 最后，在通过 car 达到一个实际的树叶时，*基本情况*：一个树叶的 count-leaves 是1

- Scheme提供了基本过程 `pair？`，**检查其参数是否为序对**。

# Mapping over trees
- map 是**处理序列的一种强有力抽象**，与此类似，map 与递归的结合也是处理树的一种强有力抽象。
- 举例来说，可以有与 2．2．1 节的 scale-list 类似的 scale-tree 过程，以一个数值因子和一棵叶子为数值的树作为参数，返回一棵具有同样形状的树，树中的每个数值都乘以了这个因子。
- 对于 scale-tree 的递归方案也与 count-leaves 的类似：

```lisp
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
	((not (pair? tree)) (* tree factor))
	(else (cons (scale-tree (car tree) factor)
				(scale-tree (cdr tree) factor)))))

(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
(10 (20 (30 40) 50) (60 70))
```


实现scale一tree的另一种方法是将树看成子树的序列，并对它使用map。我们在这种
序列上做映射，依次对各棵子树做缩放，并返回结果的表。对于基础情况，也就是当被处理
的树是树叶时，就直接用因子去乘它：

```lisp
(define (scale-tree tree factor)
	(map (lambda (sub-tree)
		(if (pair? sub-tree)
			(scale-tree sub-tree factor)
			(* sub-tree factor)))
		tree))
```