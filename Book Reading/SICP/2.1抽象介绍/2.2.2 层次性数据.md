#SICP 
# 层次性数据结构
- 层次性 sequence 数据：元素本身也是序列的序列；
- 可认为对象 `（（1 2）3 4）`是通过下面方式构造出来的：
	- `(cons（list 1 2）(list 3 4) )`
	- 包含三个项的 list，其中的第一项本身又是 list `(1 2)`。
- 用序对的语言展示出这一结构的表示形式。
![[sicp-层次性数据示意.png]]


- 认识**元素本身也是序列的序列([[2.2 层次性数据和闭包#闭包 Closure Property|闭包性]])** 的另一种方式，把其看作**树(trees)**。
	- 序列里的元素就是树的分支；
	- 那些本身也是序列的元素就形成了树中的子树。
![[sicp-层次结构的树形表示示意.png]]

## 处理方法

- 递归是处理树结构的一种很自然的工具；
- 常常可以将**对树的操作归结为对其分支的操作**，再将这种操作归结为对*分支的分支的操作*，如此下去，直至达到了树的叶子。
- 作为例子，比较一下 `length` procedure 和下面的 `count-leaves` procedure，这个过程统计出一棵树中树叶的数目：
```lisp
(define x (cons (list 1 2) (list 3 4)))
(length x)
3
(count-leaves x)
4
(list x x)
(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))
2
(count-leaves (list x x))
8
```


为了实现count-leaves，可以先回忆一下length的递归方案：
·表x的length是x的cdr的length加一
·空表的ength是0。
count一leaves的递归方案与此类似，对于空表的值也相同：
·空表的count—leaves是0，
但是在递归步骤中，当我们去掉一个表的car时，就必须注意这一car本身也可能是树，其树
叶也需要考虑。这样，正确的归约步骤应该是：
对于树x的count—leaves应该是x的car的count—leaves与x的cdr的count—leaves
之和。
最后，在通过car达到一个实际的树叶时，我们还需要另一种基本情况：
·一个树叶的count-leaves是1
