#SICP 
# 层次性数据结构
- 层次性 sequence 数据：元素本身也是序列的序列；
- 可认为对象 `（（1 2）3 4）`是通过下面方式构造出来的：
	- `(cons（list 1 2）(list 3 4) )`
	- 包含三个项的 list，其中的第一项本身又是 list `(1 2)`。
- 用序对的语言展示出这一结构的表示形式。
![[sicp-层次性数据示意.png]]


- 认识**元素本身也是序列的序列([[2.2 层次性数据和闭包#闭包 Closure Property|闭包性]])** 的另一种方式，把其看作**树(trees)**。
	- 序列里的元素就是树的分支；
	- 那些本身也是序列的元素就形成了树中的子树。
![[sicp-层次结构的树形表示示意.png]]

## 处理方法

- 递归是处理树结构的一种很自然的工具；
- 常常可以将**对树的操作归结为对其分支的操作**，再将这种操作归结为对*分支的分支的操作*，如此下去，直至达到了树的叶子。
- 作为例子，比较一下 `length` procedure 和下面的 `count-leaves` procedure，这个过程统计出一棵树中树叶的数目：
```lisp
(define x (cons (list 1 2) (list 3 4)))
(length x)
3
(count-leaves x)
4
(list x x)
(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))
2
(count-leaves (list x x))
8
```


- length 的递归方案：
	- 表 x 的 length 是 `(cdr x ) `的length加一;
	- 空表的 ength 是0。

- `count-leaves` 的递归方案与此类似，对于空表的值也相同：
	- 空表的 count-leaves 是 0，
- 但是在递归中，处理一个 list 的 car 时，就必须注意这一 car 本身也可能是树，其树
叶也需要考虑。正确的归约步骤应该是：
- 树 x 的 count-leaves 应该是： x 的 car 的 `count-leaves` 与 x 的 cdr 的 `count-leaves`
之和。
- 最后，在通过 car 达到一个实际的树叶时，*基本情况*：一个树叶的 count-leaves 是1

- Scheme提供了基本过程 pair？，它检查其参数是否为序对。
