#SICP 
# Representing Sequences
- 利用 pairs 可以构造出有用的结构：序列 *sequence*
- 一系列数据对象的有序集：
![[序列机构示意.png]]
- 每个 pairs 的 *car* 部分对应于链中的一个元素，*cdr 是链中下一个 pairs*；
- 结尾用一个不是 pairs 的值表示，*表明 sequence 的结束，用 nil 变量表示*。
	```scheme
	(cons 1
	      (cons 2
	            (cons 3
	                  (cons 4 nil))))
	```
- **通过嵌套 cons 构造的、 pairs 的 sequence 称为一个表 list**。
- Lisp 提供了 primitive procedure *list*：*(list 1 2 3 4)*
- **(list ⟨a1⟩ ⟨a2⟩ . . . ⟨an⟩)**  等同于
```scheme
(cons <a1> 
		(cons <a2> 
				(cons ... 
						(cons <an> nil) 
								...)))
```
- Lisp 通常将 *sequence 以顺序打印，外面用括号括起*。上面打印为 *(1 2 3 4)*
	```scheme
	(define one-through-four (list 1 2 3 4))
	
	one-through-four
	#|打印结果|#
	(1 2 3 4)
	```

## 注意
- 区分 expression  `(list 1 2 3 4)` 和 表list 搞混了。后面这个表是对前面表达式求值得到的结果。如果想去求值表达式（1 2 3 4），解释器就会试图将过程1应用于参数2、3和4，这时会发出一个出错信号