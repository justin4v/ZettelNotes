#SICP 
# Procedure vs. Process
- SICP 上下文中：
	- Procedure（程序） is **the description of the process**.
	- Process（过程） is **the result (in a broad meaning, not just a returned value) of applying a procedure to arguments**: all the contexts that are set up, variables with defined or set values, all the computation that will take place, etc.
	- **procedure is a blueprint**, a schematic of the building;
	- **process is actual building construction**.
- **程序（procedure）** 是一种描述一个**计算过程（computational process）局部演化（local evolution） 的模式**； ^8b3208
- 描述了计算过程中每个步骤是怎样*基于前面的步骤建立起来*。

在有了一个刻画计算过程的程序描述之后，当然希望能做出一些有关这一计算过程的*整体或全局行为*的论断。
一般来说这是非常困难的，但至少还是可以试着去*描述过程演化的一些典型模式（总结出典型的 procedure）*。

# 线性递归Linear Recursion和迭代Iteration
有阶乘函数：
```
n!＝n·(n－1)·(n－2) …3·2·1
```

## 递归观点
有如下认识：对于一个正整数n，n!就等于n乘以（n－1）!：
```
n!＝n·[(n－1)·(n－2) …3·2·1]
  ＝n·(n－1)!
```

再注意到 `1!` 就是1，这些认识可以翻译成一个程序（procedure）：
```scheme
(define (factorial n)
		(if (= n 1)
		1
		(* n (factorial (- n 1)))))
```

利用[[1.1 基本元素#过程应用的代换模型The Substitution Model for Procedure Application|代换模型]]，可以得到这一 Procedure 在计算 `6!`时表现出的行为，如下所示：

![[6!的计算过程示例1.png]]

## 迭代观点
采用另一种*不同的观点*计算阶乘：
- 将计算阶乘 `n!` 的规则描述为：先乘 1 和 2，而后将得到的结果乘以3，而后再乘以4，这样下去直到达到 n。
- 更形式地说:
	1. 要维持一个*变动中的乘积 `product`;*
	2. 一个从*1 到 n 的计数器 counter*。
	3. *这一计算过程可以描述为 counter 和 product 如下一步步的[[#^8b3208|演化（evolution）]]过程*，都按照下面规则演化：
	   ```
		product ← counter·product 
		counter ← counter + 1
		```

可以看到：*n! 就是计数器 counter 为 n+1 时product 的值*。  

将这一描述重构为一个计算阶乘的 Procedure：
```scheme
(define (factorial n)
  		(fact-iter 1 1 n))
  
(define (fact-iter product counter max-count)
		  (if (> counter max-count)
			  product
			  (fact-iter (* counter product)
						 (+ counter 1)
						 max-count)))
```

应用替换模型来查看 6! 的计算过程，如下：

![[6!的线性计算过程.png]]

## 比较
### 相同点
- 计算的都是同一个定义域里的同一个数学函数；
- 都使用与 n 正比的步骤数目去计算出 n!；

### 不同点
第一个计算过程：
- 代换模型揭示出一种*先逐步展开而后收缩*的形状；
- 展开阶段表现为一系列*推迟进行的运算（deferred operations）*，收缩阶段表现为*运算的实际执行*；
- 这种由一条推迟进行的操作链刻画的过程（process）称为**递归过程（recursive process）**。
- 执行递归计算过程，解释器需要维护好以后*将要执行的操作轨迹*；
- *推迟执行的链条的长度（要维护的信息）正比于 n*，称为**线性递归过程（linear recursive process）**。

第二个计算过程：
- *没有展开和收缩阶段*；
- 计算过程中的每一步，需要保存轨迹里，只有变量 product、counter 和 max-count的当前值，称之为**迭代计算过程（iterative process）**；
- 一般而言，迭代计算过程是：
	- **状态可用固定数目的状态变量描述**；
	- 计算过程**从一个状态转换到另一状态时，状态变量的更新规则（必需）**；
	- 计算过程**终止的检测条件（可选）**；
- 计算 n! 时，计算步骤随着 n 线性增长，称为**线性迭代过程（linear iterative process）**。

另外的角度：
- 迭代计算过程中任何一点，程序变量都提供了*有关状态的一个完整描述*。如果令计算在某两个步骤之间停下来，要想重新唤醒这一计算，只需提供有关变量的值。
- 递归计算过程中，存在着一些程序变量外的“*隐含*”信息。由解释器维持，指明了*计算过程处于运算链条的位置*。


## 递归过程 vs 递归程序
*递归过程（a recursive process）* 和 *递归程序（a recursive procedure）* 的不同：
- 当说一个程序（procedure）是递归的，是指**语法（syntactic）上的事实**：这个 procedure 的*定义中（直接或者间接地）引用了该 procedure 本身*。
- 当说一个过程（process）**具有某种模式（例如，线性递归）** 时，是指 **process 的演进（eveolves）方式**，而不是语法形式。
- 所以，*一个递归程序（recursive procedure）可能产生出一个迭代计算过程（iterative  calculation process）*。如上述的[[#迭代观点|阶乘计算示例]]

process 和 procedure 的区别可能使人感到困惑，原因之一在于：
1. 常见语言（包括C）中，*递归程序（recursive procedure）执行所消耗的存储空间与 proceure 调用的次数成正比*（线性的），即使计算过程（process）*原理上是迭代的*。
2. Scheme 的实现则没有这一缺陷，它能*在常量空间中执行迭代计算过程（iterative process）*，即使是用递归程序描述的。
3. 具有这一特性的实现称为**尾递归（tail-recursive）**。

### 相互转化
利用如下特点*转化*两个 Procedure：
- *迭代程序（Iterative Procedure）* 一般是**从初始状态开始向后累积**，每一步都具有**完整的状态**；
- *递归程序（recursive Procedure）* 一般是**从目标状态开始向前递归**，逐渐规约到最基本情况，每一步都**只具有部分状态**。

# 树形递归 Tree Recursion
## Fibobacci
考虑*斐波那契（Fibonacci）* 序列的计算，序列中的每个数都是前面两个数之和：
`0, 1, 1, 2, 3, 5, 8, 13, 21, …`

Fibonacci 数一般**定义如下**：
$$ Fib(n)= \begin{cases} 0 & \text {if $n$=0,} \\ 1 & \text{if $n$=1,} \\ Fib(n-1) + Fib(n-2) & \text{otherwise.} \end{cases} $$

## 递归计算过程
将定义翻译为一个计算 Fibonacci 的递归过程：
```scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

考虑这一计算的模式（pattern）：
1. 为了计算（fib 5），需要计算出（fib 4）和（fib 3）。
2. 而计算（fib 4），又需要计算（fib 3）和（fib 2）。

这一展开过程像一棵树：

![[斐波那契序列展开过程示意.png]]

- 上面过程作为**典型的树形递归**便于理解；
- 但却是很糟的计算方法，因为它做了太多的**冗余计算（redundant computation）**，如 `fib 3` 重复计算了2次，`fib 1`重复计算了5次。

## 迭代计算过程
也可以规划出一种斐波那契数的迭代计算过程，其基本想法是：
- 用一对整数 a 和 b，分别初始化为 Fib(1)＝1和 Fib(0)＝0；
- 而后反复地应用下面的*演化*规则（实际上是一个**线性递归过程**）：
	```
	a ← a + b, 
	b ← a.
	```

- 在n次应用变换后，a和b将分别等于 *Fib(n＋1)* 和 *Fib(n)*；

计算过程：
```scheme
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```

## 对比
- 当操作具有**层次结构的数据（hierarchically structured data）**，而不是数（numbers）时，树形递归计算过程是一种自然的、威力强大的工具；
- 即使是对于数的计算，*树形递归计算过程也有助于理解和设计程序*。

## 示例：换零钱方式数目Counting Change
问题：
- 现有0.5美元、0.25美元、10美分、5美分和1美分的若干硬币；
- 将1美元（100美分）换成零钱（make change），一共有多少种不同方式？
- 更一般的问题是，给定了任意数量的现金，能计算出所有换零钱方式的种数吗？

### 递归思想
采用递归过程，这个问题有一种很简单的解法：
假设所有硬币种类之间按照从大到小排序好，将*总面额 `a` 换成`n`种不同面额的硬币*的所有可能方法为：
1. the number of ways to change amount *a* using all but the first kind of coin, plus。使用除了第一种**面额为`d`硬币之外的所有硬币换零面额 `a`的方法数**，加上；
2. the number of ways to change amount *a − d* using all *n* kinds of coins, where *d* is the denomination（面额） of the first kind of coin。使用**所有面额的硬币换零面额 `a-d`的方法数**。

### 理解
- 步骤一：所有**一定不使用任何面额`d`换零**的方法数；
- 步骤二：所有**使用至少一个面额`d`（此时剩余面额至多为 `a-d`）换零**的方式。
- 步骤一和步骤二互相为对方的**补集**，**合在一起是所有情况的全集**。
- 步骤一将**原问题递归地归约**为**更少种类硬币**的同一问题；
- 步骤二将原问题递归地规约为**更少现金数目**的同一问题。

### 代码
假设：
-  a = 0，coc(counting of change) = 1。
-  a<0，coc = 0。
-   n=0，coc=0。

代码：
```scheme
#| 换零钱函数 |#
(define (count-change amount) 
		(cc amount 5))
  
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)  #|只有一种硬币，面额为 1美分|#
        ((= kinds-of-coins 2) 5) #|两种硬币，最大为5美分|#
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))#|5种硬币，最大为50美分|#
```

- `first-denomination` 参数为可用的硬币种类，返回第一种硬币面额；
- 默认面额种类按照从大到小排序，其实任何顺序都可。

计算：
```scheme
(count-change 100)
292
```
### 总结
- `count-change` 产生出一个树形的递归计算过程，冗余计算与 [[#递归计算过程|fib 递归计算过程]]类似。 
- *树形递归计算过程可能很低效，但很容易描述和理解*；
- *迭代计算过程可能比较高效，但不总是那么明显*；
- 人们希望设计出一种“灵巧编译器”，能将编写的*树形递归过程翻译为能计算出同样结果的更有效的过程*。
	- 解决*冗余计算（redundant computation）* 的一种途径是计算过程中**构造一个存储已经计算出的值的表格**；
	- 每次需要计算某一个过程时，首先查询表格是否计算过，如果计算过则无需重复计算。
	- 该策略称为*表格技术（tabulation）或记忆技术（memoization）*。

# 增长的阶Orders of Growth
- 不同的计算过程消耗资源的速率可能存在巨大差异。
- 描述这种差异的一种方式是用*增长的阶(order of rowth)* 记法；
- 便于理解*输入变大*时，计算过程*所需资源变化的粗略度量*。

## 定义
- 设 *R(n)* 是一个计算过程在处理规模为 n 的问题时所需要的*资源量*；
- n 是*问题规模的度量*。

### $\Theta$ 记号
-  如果存在任意正整数 $k_1$ 和 $k_2$，使得：$$0 \leq k_1f(n)\leq R(n) \leq k_2f(n)$$ 成立，则称 $R(n)$ 具有**增长阶(Order of Growth) $\Theta(f(n))$**；
- 记为* $R(n)=\Theta(f(n))$* ，读作 *$f(n)$的 Theta*；
- $R(n)$ 同时具有上界和下界，n 趋近无穷大时，$R(n)$ 趋近 $f(n)$，$f(n)$ 是$R(n)$的**渐进确界**。

### O记号
- 如果存在任意正整数 $k_1$，使得：$$0 \leq R(n) \leq k_1f(n)$$ 成立，则称 $R(n)$ 具有**增长阶(Order of Growth) $O(f(n))$**；
- 记为* $R(n)=O(f(n))$* ，读作 *$f(n)$的大 O*；
- $f(n)$ 是$R(n)$的**渐进上界**

### $\Omega$记号
- 如果存在任意正整数 $k_1$，使得：$$0 \leq k_1f(n) \leq R(n) $$ 成立，则称 $R(n)$ 具有**增长阶(Order of Growth) $\Omega(f(n))$**；
- 记为* $R(n)=\Omega(f(n))$* ，读作 *$f(n)$的omega*；
- $f(n)$ 是$R(n)$的**渐进下界**

# 实例
## 求幂Exponentiation
- 计算 $b^n$，有如下递归定义：
$$ b^n= \begin{cases} 1 & \text {if n=0,} \\ b \cdot b^{n-1} & \text{if n>0} \end{cases} $$

- 翻译为如下递归过程：
	```scheme
	(define (expt b n)
	  (if (= n 0)
		  1
		  (* b (expt b (- n 1)))))
	```
- **线性递归计算过程**，时间和空间消耗都为 $\Theta(n)$;
- 根据迭代和递归[[1.2 程序及其所产生的过程#相互转化|相互转化提示]]转化为迭代过程：
	```scheme
	(define (expt b n)
	  (expt-iter b n 1))
	(define (expt-iter b counter product)
	  (if (= counter 0)
		  product
		  (expt-iter b
					(- counter 1)
					(* b product))))
	```
- ** 线性迭代计算过程**，时间和空间消耗分别为 $\Theta(n)$ 和 $\Theta(1)$。

### 求幂的优化
**提高计算的基底**
- 如$b^8$ 原始计算过程为 b·(b·(b·(b·(b·(b·(b·b))))))；
- 基底用 $b^2$ 而不是 b :
	- $b^2=b\cdot b$
	- $b^4=b^2 \cdot b^2$
	- $b^8=b^4 \cdot b^4$
- 一般有： $$b^n= \begin{cases} (b^{n/2})^2 & \text {n 是偶数,} \\ b \cdot b^{(n-1)/2} & \text{n 是奇数} \end{cases}$$
- 其中 n 是奇数后，n-1为偶数可以继续应用偶数公式。
- 空间和时间消耗是**以2为底的对数（计算规模 n 只需要 $\log n$ 次），$\Theta(\log n)$**
- 计算 process `fast-expt` 如下：
	```scheme
	(define (fast-expt b n)
	  (cond ((= n 0) 1)
			((even? n) (square (fast-expt b (/ n 2))))
			(else (* b (fast-expt b (- n 1))))))
	```
- 判断n是否是偶数的 process `even?`：
	```scheme
	(define (even? n)
	  (= (remainder n 2) 0))
	```
- **remainder 是取余操作，是基本过程**。


## 最大公约数Greatest Common Divisors
- 两个整数 a 和 b 的*最大公约数（GCD）*是*能除尽这两个数的最大整数*；
- 欧几里得算法：*a 和 b 的公约数等于 b 和 r （r 是 a 除以 b 的余数）的公约数*：$GCD(a,b)=GCD(b,r)$，其中 r = a%b;
- 把一个GCD的计算问题连续地**归约**到越来越小的GCD计算问题：
*GCD(206, 40)＝GCD(40, 6) ＝GCD(6, 4) ＝GCD(4, 2) ＝GCD(2, 0) ＝2*
- 翻译为如下 process：
	```scheme
	(define (gcd a b)
	  (if (= b 0)
		  a
		  (gcd b (remainder a b))))
	```
- 空间和时间消耗与规模为*对数关系*。

## 素数检测Testing for Primality
**素数（prime numbers）**：大于1，除了1和自身没有其他因数的自然数。
### 寻找因子
- 定理：**如果 n 不是素数，它必然有一个小于等于$\sqrt{n}$的因子**;
- 检测素数：从 2 开始找出它的因子；
- 如果存在任意小于 n 的因子，则不是素数，否则（最小因子为 n）是素数；
- 有如下 process
	```scheme
	#|从2开始查找最小因子|#
	(define (smallest-divisor n)
	  (find-divisor n 2))

	#|依据定理查找因子|#
	(define (find-divisor n test-divisor)
	  (cond ((> (square test-divisor) n) n)
			((divides? test-divisor n) test-divisor)
			(else (find-divisor n (+ test-divisor 1)))))

	#|是否能整除|#
	(define (divides? a b)
	  (= (remainder b a) 0))
	```

- *当且仅当 n 是自己的最小因子时，n 为素数*
	```scheme
	(define (prime? n)
	  (= n (smallest-divisor n)))
	```

该算法只需在1和$\sqrt{n}$之间检查因子。因此时间消耗将具有$Omega$的增长阶