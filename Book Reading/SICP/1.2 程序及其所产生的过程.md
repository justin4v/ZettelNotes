#SICP 
# Procedure vs. Process
- SICP 上下文中：
	- Procedure（程序） is **the description of the process**.
	- Process（过程） is **the result (in a broad meaning, not just a returned value) of applying a procedure to arguments**: all the contexts that are set up, variables with defined or set values, all the computation that will take place, etc.
	- **procedure is a blueprint**, a schematic of the building;
	- **process is actual building construction**.
- **程序（procedure）** 是一种描述一个**计算过程（computational process）局部演化（local evolution） 的模式**； ^8b3208
- 描述了计算过程中每个步骤是怎样*基于前面的步骤建立起来*。

在有了一个刻画计算过程的程序描述之后，当然希望能做出一些有关这一计算过程的*整体或全局行为*的论断。
一般来说这是非常困难的，但至少还是可以试着去*描述过程演化的一些典型模式（总结出典型的 procedure）*。

# 线性递归Linear Recursion和迭代Iteration
有阶乘函数：
```
n!＝n·(n－1)·(n－2) …3·2·1
```

## 递归观点
有如下认识：对于一个正整数n，n!就等于n乘以（n－1）!：
```
n!＝n·[(n－1)·(n－2) …3·2·1]
  ＝n·(n－1)!
```

再注意到 `1!` 就是1，这些认识可以翻译成一个程序（procedure）：
```scheme
(define (factorial n)
		(if (= n 1)
		1
		(* n (factorial (- n 1)))))
```

利用[[1.1 基本元素#过程应用的代换模型The Substitution Model for Procedure Application|代换模型]]，可以得到这一 Procedure 在计算 `6!`时表现出的行为，如下所示：

![[6!的计算过程示例1.png]]

## 迭代观点
采用另一种*不同的观点*计算阶乘：
- 将计算阶乘 `n!` 的规则描述为：先乘 1 和 2，而后将得到的结果乘以3，而后再乘以4，这样下去直到达到 n。
- 更形式地说:
	1. 要维持一个*变动中的乘积 `product`;*
	2. 一个从*1 到 n 的计数器 counter*。
	3. *这一计算过程可以描述为 counter 和 product 如下一步步的[[#^8b3208|演化（evolution）]]过程*，都按照下面规则演化：
	   ```
		product ← counter·product 
		counter ← counter + 1
		```

可以看到：*n! 就是计数器 counter 为 n+1 时product 的值*。  

将这一描述重构为一个计算阶乘的 Procedure：
```scheme
(define (factorial n)
  		(fact-iter 1 1 n))
  
(define (fact-iter product counter max-count)
		  (if (> counter max-count)
			  product
			  (fact-iter (* counter product)
						 (+ counter 1)
						 max-count)))
```

应用替换模型来查看 6! 的计算过程，如下：

![[6!的线性计算过程.png]]

## 比较
### 相同点
- 计算的都是同一个定义域里的同一个数学函数；
- 都使用与 n 正比的步骤数目去计算出 n!；

### 不同点
第一个计算过程：
- 代换模型揭示出一种*先逐步展开而后收缩*的形状；
- 展开阶段表现为一系列*推迟进行的运算（deferred operations）*，收缩阶段表现为*运算的实际执行*；
- 这种由一条推迟进行的操作链刻画的过程（process）称为**递归过程（recursive process）**。
- 执行递归计算过程，解释器需要维护好以后*将要执行的操作轨迹*；
- *推迟执行的链条的长度（要维护的信息）正比于 n*，称为**线性递归过程（linear recursive process）**。

第二个计算过程：
- *没有展开和收缩阶段*；
- 计算过程中的每一步，需要保存轨迹里，只有变量 product、counter 和 max-count的当前值，称之为**迭代计算过程（iterative process）**；
- 一般而言，迭代计算过程是：
	- **状态可用固定数目的状态变量描述**；
	- 计算过程**从一个状态转换到另一状态时，状态变量的更新规则（必需）**；
	- 计算过程**终止的检测条件（可选）**；
- 计算 n! 时，计算步骤随着 n 线性增长，称为**线性迭代过程（linear iterative process）**。

另外的角度：
- 迭代计算过程中任何一点，程序变量都提供了*有关状态的一个完整描述*。如果令计算在某两个步骤之间停下来，要想重新唤醒这一计算，只需提供有关变量的值。
- 递归计算过程中，存在着一些程序变量外的“*隐含*”信息。由解释器维持，指明了*计算过程处于运算链条的位置*。
- *迭代程序（Iterative Procedure）* 一般是**从初始状态开始向后累积**，每一步都具有**完整的状态**；
- *递归程序（recursive Procedure）* 一般是**从目标状态开始向前递归**，逐渐规约到最基本情况，每一步都**只具有部分状态**。

## 递归过程 vs 递归程序
*递归过程（a recursive process）* 和 *递归程序（a recursive procedure）* 的不同：
- 当说一个程序（procedure）是递归的，是指**语法（syntactic）上的事实**：这个 procedure 的*定义中（直接或者间接地）引用了该 procedure 本身*。
- 当说一个过程（process）**具有某种模式（例如，线性递归）** 时，是指 **process 的演进（eveolves）方式**，而不是语法形式。
- 所以，*一个递归程序（recursive procedure）可能产生出一个迭代计算过程（iterative  calculation process）*。如上述的[[#迭代观点|阶乘计算示例]]

process 和 procedure 的区别可能使人感到困惑，原因之一在于：
1. 常见语言（包括C）中，*递归程序（recursive procedure）执行所消耗的存储空间与 proceure 调用的次数成正比*（线性的），即使计算过程（process）*原理上是迭代的*。
2. Scheme 的实现则没有这一缺陷，它能*在常量空间中执行迭代计算过程（iterative process）*，即使是用递归程序描述的。
3. 具有这一特性的实现称为**尾递归（tail-recursive）**。


# 树形递归 Tree Recursion
## Fibobacci
考虑*斐波那契（Fibonacci）* 序列的计算，序列中的每个数都是前面两个数之和：
`0, 1, 1, 2, 3, 5, 8, 13, 21, …`

Fibonacci 数一般**定义如下**：
$$ Fib(n)= \begin{cases} 0 & \text {if $n$=0,} \\ 1 & \text{if $n$=1,} \\ Fib(n-1) + Fib(n-2) & \text{otherwise.} \end{cases} $$

## 递归计算过程
将定义翻译为一个计算 Fibonacci 的递归过程：
```scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

考虑这一计算的模式（pattern）：
1. 为了计算（fib 5），需要计算出（fib 4）和（fib 3）。
2. 而计算（fib 4），又需要计算（fib 3）和（fib 2）。

这一展开过程像一棵树：

![[斐波那契序列展开过程示意.png]]

- 上面过程作为**典型的树形递归**便于理解；
- 但却是很糟的计算方法，因为它做了太多的**冗余计算（redundant computation）**，如 `fib 3` 重复计算了2次，`fib 1`重复计算了5次。

## 迭代计算过程
也可以规划出一种斐波那契数的迭代计算过程，其基本想法是：
- 用一对整数 a 和 b，分别初始化为 Fib(1)＝1和 Fib(0)＝0；
- 而后反复地应用下面的*演化*规则（实际上是一个**线性递归过程**）：
	```
	a ← a + b, 
	b ← a.
	```

- 在n次应用变换后，a和b将分别等于 *Fib(n＋1)* 和 *Fib(n)*；

计算过程：
```scheme
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```

## 对比
- 当操作具有**层次结构的数据（hierarchically structured data）**，而不是数（numbers）时，树形递归计算过程是一种自然的、威力强大的工具；
- 即使是对于数的计算，*树形递归计算过程也有助于理解和设计程序*。

## 示例：换零钱方式数目Counting Change
问题：
- 现有0.5美元、0.25美元、10美分、5美分和1美分的若干硬币；
- 将1美元（100美分）换成零钱（make change），一共有多少种不同方式？
- 更一般的问题是，给定了任意数量的现金，能计算出所有换零钱方式的种数吗？

### 递归思想
采用递归过程，这个问题有一种很简单的解法：
假设所有硬币种类之间按照从大到小排序好，将*总面额 `a` 换成`n`种不同面额的硬币*的所有可能方法为：
1. the number of ways to change amount *a* using all but the first kind of coin, plus。使用除了第一种**面额为`d`硬币之外的所有硬币换零面额 `a`的方法数**，加上；
2. the number of ways to change amount *a − d* using all *n* kinds of coins, where *d* is the denomination（面额） of the first kind of coin。使用**所有面额的硬币换零面额 `a-d`的方法数**。

### 理解
- 步骤一：所有**一定不使用任何面额`d`换零**的方法数；
- 步骤二：所有**使用至少一个面额`d`（此时剩余面额至多为 `a-d`）换零**的方式。
- 步骤一和步骤二互相为对方的**补集**，**合在一起是所有情况的全集**。
- 步骤一将**原问题递归地归约**为**更少种类硬币**的同一问题；
- 步骤二将原问题递归地规约为**更少现金数目**的同一问题。

### 代码
假设：
-  a = 0，coc(counting of change) = 1。
-  a<0，coc = 0。
-   n=0，coc=0。

代码：
```scheme
#| 换零钱函数 |#
(define (count-change amount) 
		(cc amount 5))
  
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)  #|只有一种硬币，面额为 1美分|#
        ((= kinds-of-coins 2) 5) #|两种硬币，最大为5美分|#
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))#|5种硬币，最大为50美分|#
```

- `first-denomination` 参数为可用的硬币种类，返回第一种硬币面额；
- 默认面额种类按照从大到小排序，其实任何顺序都可。

计算：
```scheme
(count-change 100)
292
```
### 总结
- `count-change` 产生出一个树形的递归计算过程，冗余计算与 [[#递归计算过程|fib 递归计算过程]]类似。 
- *树形递归计算过程可能很低效，但很容易描述和理解*；
- *迭代计算过程可能比较高效，但不总是那么明显*；
- 人们希望设计出一种“灵巧编译器”，能将编写的*树形递归过程翻译为能计算出同样结果的更有效的过程*。
	- 解决*冗余计算（redundant computation）* 的一种途径是计算过程中**构造一个存储已经计算出的值的表格**；
	- 每次需要计算某一个过程时，首先查询表格是否计算过，如果计算过则无需重复计算。
	- 该策略称为*表格技术（tabulation）或记忆技术（memoization）*。

# 增长的阶Orders of Growth
