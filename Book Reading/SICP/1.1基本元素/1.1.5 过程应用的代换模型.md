# The Substitution Model for Procedure Application

对于复合过程，过程应用的计算过程是：

-   将复合过程(Compound Procedures)应用于实际参数，就是*在将过程体 ⟨body⟩ 中的形参用实参取代之后，对过程体求值*。

例如，有如下过程：
```scheme
(define (sum-of-squares x y)
  (+ (square x) (square y)))


(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
```

求 `(f 5)`，求值过程如下：
1. 首先提取出f的体：
```scheme
(sum-of-squares (+ a 1) (* a 2))
```

2. 后用实际参数5代换其中的形式参数：
```scheme
(sum-of-squares (+ 5 1) (* 5 2))
```

问题就被归约为对另一个组合式的求值，其中有两个运算对象，有关的运算符是 sum-of-squares。
`(+ 5 1)`得到 6，`(* 5 2)`得到10，因此我们就需要将sum-of-squares过程用于6和10。

3. 用这两个值代换sum-of-squares体中的形式参数x和y，表达式被归约为：
```scheme
(+ (square 6) (square 10))
```

4. 使用square的定义又可以将它归约为：

```scheme
(+ (* 6 6) (* 10 10))
```

5. 通过乘法又能将它进一步归约为：

```scheme
(+ 36 100)
```

6. 最后得到：

```scheme
136
```

上面描述的这种计算过程称为过程应用的**代换模型（substitution model）**，可以将它看作*确定过程应用的“意义”的一种模型*。

1. 代换模型只是为了*帮助领会过程调用中的情况*，而*不是对解释器实际工作方式的具体描述*；
2. 这里的代换模型只是形式化地考虑解释器求值过程的起点，并不准确完整，后面将给出有关解释器如何工作的一系列模型，更加精细和完整。

## 应用序和正则序Applicative order versus normal order
上节中解释器*首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数*。

另一种求值模型是*先不求出运算对象的值，直到实际需要它们的值时再去做*。
这种求值方式应该首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。

如果采用这一方式，对下面表达式的求值：

```scheme
(f 5)
```

将按照下面的序列逐步展开：

```scheme
(sum-of-squares (+ 5 1) (* 5 2))
(+    (square (+ 5 1))      (square (* 5 2))  )
(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
```

而后是下面归约：

```scheme
(+         (* 6 6)             (* 10 10))
(+           36                   100)
                    136
```

给出了与前面求值模型同样的结果，但其中的计算过程却是不一样的。
特别地，在对下面表达式的归约中，(＋5 1）和（* 5 2）的求值各做了两次：
```scheme
(* x x)
```

### 定义
1. “*完全展开而后归约（fully expand and then reduce）*”的求值模型称为**正则序求值 normal-order evaluation**；
2. “*先求值参数而后应用（evaluate the arguments and then apply）*”的求值模型称为应用序求值applicative-order evaluation。

可以证明，*可以通过替换模拟并能产生出合法值的过程应用，正则序和应用序求值将产生出同样的值*（参见练习1.5中一个“非法”值的例子，其中正则序和应用序将给出不同的结果）。

Lisp 采用*应用序求值*：
1. *能避免对于表达式的重复求值*（例如上面的（＋5 1）和（* 5 2）的情况），提高效率。、
2. 超出了可以采用代换方式模拟求值过程的范围之后，*正则序的处理将变得更复杂*。
