# 术语
|   术语    | 描述 |
| :-----------: | :-----------: |
|*Abstract class* | Defines the *methods and common attributes of a set of classes* that are conceptually similar. Abstract classes are never instantiated. |
|*Class* |Blueprint of an object: defines the *methods and data of an object* of its type.|
|*Object*|An *entity with responsibilities*.<br> A special, self-contained holder of both data and procedures that operate on that data. An object’s data is protected from external objects.|
|*Derived class*|A class that is *specialized from a base class*. Contains all of the attributes and methods of the base class but may also contain other attributes or different method implementations.|
|*Attribute*|Data associated with an object (also called a data member)|
|*Concrete Class* | A class that *implements a particular type of behavior* for an abstract class.<br> Concrete classes are specific, nonchanging implementations of a concept.|
|*Encapsulation* | Typically defined as data hiding, but better thought of as *any kind of hiding (type, implementation, design, and so on)*.|
|*Inheritance*| A class inherits from another class when it receives some or all of the qualities of that class.The starting class is called the base, super, parent, or generalized class, whereas the inheriting class is called the derived, sub, child, or specialized class.|
|*Instance* | A *particular example of a class. (It is always an object.)* A particular instance or entity of a class.<br>Each object has its own state. This enables us to have several objects of the same type (class).  |
|*Interface*| An interface is *like a class, but only provides a specification–and not an implementation*–for its members.<br> It is similar to an abstract class consisting only of abstract members. <br>When programming, you use interfaces when you *need several classes to share some characteristics* that are not present in a common base class and want to be sure that each class implements the characteristic on its own (because each member is abstract). |
|*Perspectives* | There are three different perspectives for *looking at objects*: *conceptual, specification, and implementation.* <br>These distinctions are helpful in understanding the relationship between abstract classes and their derivations.<br> The *abstract class defines how to solve things conceptually*.<br> It also *gives the specification for communicating* with any object derived from it.<br> *Each derivation provides the specific implementation* needed. |
|*Polymorphism* | Being able to *refer to different derivations of a class in the same way*, but *getting the behavior appropriate to the derived class* being referred to. |
|*Functional decomposition*|Structured programmers usually approach program design with functional decomposition.<br> Functional decomposition is the method of *breaking down a problem into smaller and smaller functions*. Each function is *subdivided until it is manageable*.|
|*Changing requirements*|Changing requirements are inherent to the development process.<br>Rather than blaming users or ourselves about the seemingly impossible task of getting good and complete requirements, we should use development methods that deal with changing requirements more effectively.|


