# 示例
## 问题
假设你是要在一个会议上担 任讲师，听课的人在课后还要去听其他课，但他们不知道下一堂课的听课地点 。 你的责任之一，就是确保大家都知道下一堂课去哪里上。 

## 功能分解
如果按照结构化程序设计的方法，可进行如下[[功能分解]]
1. 获得听课人的名单。 
2. 对于名单上的每个人，做以下工作:
	1. 找到他或者她要听的下一堂课。 
	2. 找到该课的听课地点。 
	3. 找到从你的教室到下一堂课地点怎么走。 
	4. 告诉这个人怎样去上下一堂课

为了完成以上工作，编程实现中需要： 
1. 获得听课人名单的方法。 
2. 获得每个人课程表的方法。 
3. 告诉某个人如何从你的教室到其他任何教室的程序。 
4. 为听课的每个人服务的一个控制程序，它可以为每个人完成所需的步骤。

### 特点
直接给每个人提供指示，**必须密切关注大量细节**，除你之外没有其他人负责，责任集中，难以维护。

## 责任转移

1. 把从这个教室到其他教室的方向路线贴出来
2. 告诉课堂上的所有人：“已经将下一 堂课的地点和其他教室的位置都贴在教室后面了。请根据它找到你们下一堂课的教室。”
3. 可以预期每个人都知道自己的下一堂课是什么；
4. 且都能从列表中查到正确的教室，然后按照指示找到它。

### 特点
*只给出通用的提示*，然后期待每个人会自己弄清怎样完成任务。

1. 人们对自己的行为负责，而不再由一个中央控制程序负责决定他们的 行为。
2. 控制程序可以与不同类型的人（研究生和普通学生）交流，好像他们都一样；
3. 控制程序不需要知道学生从此教室到彼教室可能需要采取的任何特殊步骤。

### 不同层次视角
参考：[[开发过程中的三个视角]]

1. 作为讲师的你是在*概念层次*上与人交流。换句话说，你告诉学生的是 *“你要他们做什么”， 而非“如何去做”*。
2. 但他们如何去下一堂课的教室则是非常明确的，因为他们遵循着明确的指令。这是在*实现层次*进行的。

在*一个层次（概念）上交流，而在另一个层次（实现）上执行Communicating at one level (conceptually) while performing at another level*  (implementation) results :
The requestor (the instructor) *not having to know exactly what is happening, only having to know in general—conceptually—what is happening.*
*只要概念不变，请求者就与实现细节的变化隔离开*。


## 比较
最大的区别就是这种**责任的转移**。
- 第一种情况下，你要对一切负责 ； 
- 第二种情况下，学生对自己的行为负责。
- 两种情况下，要实现的目的相同 ， 但*组织方式差异很大*。

### 应对变化
- 第一种情况下，每次需要增加新的一类学生时，控制程序本身都必须作修改，要负责告诉新一类学生如何去做。
- 第二种情况下，新一类的学生不会影响控制程序，由学生自己负责弄清如何去做。


# 面向对象

## 定义
### 传统定义
传统上被定义为**带有方法的数据**。

### 责任视角
从三个视角：
- At the **conceptual** level, an object is **a set of responsibilities**.
- At the **specification** level, an object is **a set of methods (behaviors)** that can be invoked by other objects or by itself. 
- At the **implementation** level, an object is **code and data and computational interactions**（交互） between them.
