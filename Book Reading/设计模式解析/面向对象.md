# 示例
## 问题
假设你是要在一个会议上担 任讲师，听课的人在课后还要去听其他课，但他们不知道下一堂课的听课地点 。 你的责任之一，就是确保大家都知道下一堂课去哪里上。 

## 功能分解
如果按照结构化程序设计的方法，可进行如下[[功能分解]]
1. 获得听课人的名单。 
2. 对于名单上的每个人，做以下工作:
	1. 找到他或者她要听的下一堂课。 
	2. 找到该课的听课地点。 
	3. 找到从你的教室到下一堂课地点怎么走。 
	4. 告诉这个人怎样去上下一堂课

为了完成以上工作，编程实现中需要： 
1. 获得听课人名单的方法。 
2. 获得每个人课程表的方法。 
3. 告诉某个人如何从你的教室到其他任何教室的程序。 
4. 为听课的每个人服务的一个控制程序，它可以为每个人完成所需的步骤。

### 特点
直接给每个人提供指示，**必须密切关注大量细节**，除你之外没有其他人负责，责任集中，难以维护。

## 责任转移

1. 把从这个教室到其他教室的方向路线贴出来
2. 告诉课堂上的所有人：“已经将下一 堂课的地点和其他教室的位置都贴在教室后面了。请根据它找到你们下一堂课的教室。”
3. 可以预期每个人都知道自己的下一堂课是什么；
4. 且都能从列表中查到正确的教室，然后按照指示找到它。

### 特点
*只给出通用的提示*，然后期待每个人会自己弄清怎样完成任务。

1. 人们对自己的行为负责，而不再由一个中央控制程序负责决定他们的 行为。
2. 控制程序可以与不同类型的人（研究生和普通学生）交流，好像他们都一样；
3. 控制程序不需要知道学生从此教室到彼教室可能需要采取的任何特殊步骤。

### 不同层次视角
参考：[[开发过程中的三个视角]]

1. 作为讲师的你是在*概念层次*上与人交流。换句话说，你告诉学生的是 *“你要他们做什么”， 而非“如何去做”*。
2. 但他们如何去下一堂课的教室则是非常明确的，因为他们遵循着明确的指令。这是在*实现层次*进行的。

在*一个层次（概念）上交流，而在另一个层次（实现）上执行Communicating at one level (conceptually) while performing at another level*  (implementation) results :
The requestor (the instructor) *not having to know exactly what is happening, only having to know in general—conceptually—what is happening.*
*只要概念不变，请求者就与实现细节的变化隔离开*。


## 比较
最大的区别就是这种**责任的转移**。
- 第一种情况下，你要对一切负责 ； 
- 第二种情况下，学生对自己的行为负责。
- 两种情况下，要实现的目的相同 ， 但*组织方式差异很大*。

### 应对变化
- 第一种情况下，每次需要增加新的一类学生时，控制程序本身都必须作修改，要负责告诉新一类学生如何去做。
- 第二种情况下，新一类的学生不会影响控制程序，由学生自己负责弄清如何去做。


# 面向对象
## 优点
1. 定义自己的责任。（Conception 视角）
2. 对象天生知道自己的类型。   （Specification 视角）
3. 对象中的*数据能表明对象的状态*。（Implementation 视角）
4. 对象中的*方法能够使它正确工作*。

### 示例
![[课堂示例中对象及其责任.png]]


## 定义
### 传统定义
传统上被定义为**带有方法的数据**。

### 责任视角
从三个视角：
- At the **conceptual** level, an object is **a set of responsibilities**.
- At the **specification** level, an object is **a set of methods (behaviors)** that can be invoked by other objects or by itself. 
- At the **implementation** level, an object is **code and data and computational interactions**（交互） between them.


# 公开接口
**可被其他对象调用的方法的集合**称为对象的**公开接口（public interface）**

对象具有责任而且自己负责自己，所以*必须有办法告诉对象要做什么，就是对象中的方法*。
对象有：
1. 说明自己状态的数据
2. 实现必要功能的方法。

## 示例
在教室的例子中，可以编写含有一个 gotoNextClassroom()  方法 的 Student 对象。
*不需要向这个方法传递任何参数*，因为每个 Student 对象自己负责自己，且含有自身状态数据。

也就是说，Student 对象知道： 
1. 为了能够找到下一个教室，它需要什么。 
2. 怎样为完成这个任务获取所需的其他信息。


# 类
## 定义
类是**对对象行为的定义**

它包含以下内容的完整描述： 
1. 对象所包含的数据元素。 
2. 对象能够操作的方法。 
3. 访问这些数据元素和方法的方式

### 示例
1. 定义一个 “*一般学生（类）*” 来包含一些公共方法的定义，避免每个学生都定义一遍。
2. 然后有各种各样*特殊学生（对象，类的实例化）*，每个特殊学生掌握自己的私有信息。

# 抽象类
- 抽象类功能上定义了**一系列相关联的类的行为**。
- 相关联的类是指**具体的类（concrete class）**，它代表着某一个**具体的、不变的概念和概念的实现**。

## 定义
1. 抽象类经常被描述为 *“不能实例化的类”*。这是实现层次上的定义，本身没错，但是局限性太大了。
2. 概念层次，抽象类是**具体类（实现抽象类所代表的概念）的占位符**。 
3. 抽象类为我们提供了一种方法，能够**给一组相关的类赋予一个统一的概念**。 

参考：
[[开发过程中的三个视角]]

## 示例
- 本例中，Student 就是抽象类，代表一种概念。
- RegularStudent 和 GraduateStudent 则代表了两种具体类型的 Student。


# 封装
## 定义
封装（encapsulation）经常被简单地描述成数据隐藏（hiding data）
但封装可不只是指数据隐藏。**封装一般意味着各种类型的隐藏（any kind of hiding）**.

## 优点
1. The more I make my objects responsible for their own behaviors, *the less the controlling programs have to be responsible for*.  
2. Encapsulation makes *changes to an object’s internal behavior transparent to other objects*. 
3. Encapsulation helps to *prevent unwanted side effects*.

When I encapsulate something, I am necessarily loosely coupled to it. 
*Hiding implementations (encapsulating them) thus promotes loose coupling*.

## 示例
在本例中，讲师不知道哪些是普通学生，哪些是研究生。所以学生的类型 对讲师隐藏了。（也就是说，我封装了学生的类型）。

在面向对象语言中，**抽象类 Student 将隐藏从其派生的类的类型**。

# 多态
## 定义
在面向对象语言中，用抽象类类型的引用来引用对象，真正引用的是从抽象类派生的类的具体实例。
Tell the objects to do something conceptually through the abstract reference, *will get different behavior,* depending upon the specific type of derived object.
## 示例
在本例中，讲师告诉学生“去下堂课的教室”。
根据学生类型（普通学生和研究生）的不同，他们会采取不同的行为（出现了多态）。



# 相关概念
[[面向对象概念]]