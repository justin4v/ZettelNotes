#Design-Pattern 
# 传统方法
[[功能分解]]的方式：
- 难以应对变化；
- 结构化程序，主要精力都放在函数和数据上；

采用[[面向对象|面向对象范型]]：
- 以[[#对象|对象概念]]为中心；
- 编写代码时是*围绕对象而非函数*进行组织的。

# 优点
1. 定义自己的责任。（Conception 视角）
2. 对象天生知道自己的类型。   （Specification 视角）
3. 对象中的*数据能表明对象的状态*。（Implementation 视角）
4. 对象中的*方法能够使它正确工作*。

实例见[[面向对象实例]]

# 对象
## 传统定义
传统上被定义为**带有方法的数据**。

## 最佳理解
> - 对象是“**具有责任的东西** ”；
> - 对象应该**自己负责自己**；
> - 对象应该**清楚地定义自己的责任**。

## Martin Flower视角框架
从[[开发过程中的三个视角|三个视角]]：
- At the **conceptual(概念)** level, an object is **a set of responsibilities.**（*一组责任*）
- At the **specification(规约)** level, an object is **a set of methods (behaviors)** that can be invoked by other objects or by itself（*一组可以被其他对象或对象自己调用的方法*（也称行为）） 
- At the **implementation(实现)** level, an object is **code and data and computational interactions**（交互） between them（*代码和数据，以及它们之间的计算交互*）



# 概念
1. [[#公开接口]]
2. [[#类]]
3. [[#抽象类]]
4. [[#封装]]
5. [[#多态]]

# 公开接口
**可被其他对象调用的方法的集合**称为对象的**公开接口（public interface）**

**对象具有责任**，自己负责自己，所以*必须有办法告诉对象要做什么，就是对象中的方法*。
对象有：
1. 说明自己状态的数据
2. 实现必要功能的方法。

## 示例
在教室的例子中，可以编写含有一个 gotoNextClassroom()  方法 的 Student 对象。
*不需要向这个方法传递任何参数*，因为每个 Student 对象自己负责自己，且含有自身状态数据。

也就是说，Student 对象知道： 
1. 为了能够找到下一个教室，它需要什么。 
2. 怎样为完成这个任务获取所需的其他信息。


# 类
## 定义
类是**对对象行为的定义**

它包含以下内容的完整描述： 
1. 对象所包含的**数据域**（field）。 
2. 对象能够操作的**方法**（method）。 
3. 数据域和方法的**访问权限**（public/protected/private）。

### 示例
1. 定义一个 “*一般学生（类）*” 来包含一些公共方法的定义，避免每个学生都定义一遍。
2. 然后有各种各样*特殊学生（对象，类的实例化）*，每个特殊学生掌握自己的私有信息。

# 抽象类
- 抽象类功能上定义了**一系列相关联的类的行为**。
- 相关联的类是指**具体的类（concrete class）**，它代表着某一个**具体的、不变的概念和概念的实现**。

## 定义
1. 抽象类经常被描述为 *“不能实例化的类”*。这是实现层次上的定义，本身没错，但是局限性太大了。
2. 概念层次，抽象类是**具体类（实现抽象类所代表的概念）的占位符**。  ^c906d6
3. 抽象类为我们提供了一种方法，能够**给一组相关的类赋予一个统一的概念**。 

参考：
[[开发过程中的三个视角]]

## 示例
- 本例中，Student 就是抽象类，代表一种概念。
- RegularStudent 和 GraduateStudent 则代表了两种具体类型的 Student。


# 封装
## 定义
封装（encapsulation）经常被简单地描述成数据隐藏（hiding data）
但封装可不只是指数据隐藏。**封装一般意味着各种类型的隐藏（any kind of hiding）**.

## 优点
1. The more I make my objects responsible for their own behaviors, *the less the controlling programs have to be responsible for*.  
2. Encapsulation makes *changes to an object’s internal behavior transparent to other objects*. 
3. Encapsulation helps to *prevent unwanted side effects*.

When I encapsulate something, I am necessarily loosely coupled to it. 
*Hiding implementations (encapsulating them) thus promotes loose coupling*.

## 示例
在本例中，讲师不知道哪些是普通学生，哪些是研究生。所以学生的类型 对讲师隐藏了。（也就是说，我封装了学生的类型）。

在面向对象语言中，**抽象类 Student 将隐藏从其派生的类的类型**。

# 多态
## 定义
在面向对象语言中，用抽象类类型的引用来引用对象，真正引用的是从抽象类派生的类的具体实例。
Tell the objects to do something conceptually through the abstract reference, *will get different behavior,* depending upon the specific type of derived object.
## 示例
在本例中，讲师告诉学生“去下堂课的教室”。
根据学生类型（普通学生和研究生）的不同，他们会采取不同的行为（出现了多态）。


# 相关概念
# 术语
|   术语    | 描述 |
| :-----------: | :-----------: |
|*Abstract class* | Defines the *methods and common attributes of a set of classes* that are conceptually similar. Abstract classes are never instantiated. |
|*Interface*| An interface is *like a class, but only provides a specification–and not an implementation*–for its members.<br> It is similar to an abstract class consisting only of abstract members. <br>When programming, you use interfaces when you *need several classes to share some characteristics* that are not present in a common base class and want to be sure that each class implements the characteristic on its own (because each member is abstract). |
|*Class* |Blueprint of an object: defines the *methods and data of an object* of its type.|
|*Object*|An *entity with responsibilities*.<br> A special, self-contained holder of both data and procedures that operate on that data. An object’s data is protected from external objects.|
|*Derived class*|A class that is *specialized from a base class*. Contains all of the attributes and methods of the base class but may also contain other attributes or different method implementations.|
|*Concrete Class* | A class that *implements a particular type of behavior* for an abstract class.<br> Concrete classes are specific, nonchanging implementations of a concept.|
|*Attribute*|Data associated with an object (also called a data member)|
|*Inheritance*| A class inherits from another class when it receives some or all of the qualities of that class.<br>The starting class is called the *base, super, parent, or generalized class*, whereas the inheriting class is called the *derived, sub, child, or specialized class*.|
|*Instance* | A *particular example of a class. (It is always an object.)* A particular instance or entity of a class.<br>Each object has its own state. This enables us to have several objects of the same type (class).  |
|*Attribute*|Data associated with an object (also called a data member)|
|软件上层视角|解释|
|*Encapsulation* | Typically defined as data hiding, but better thought of as *any kind of hiding (type, implementation, design, and so on)*.|
|*Perspectives* | There are three different perspectives for *looking at objects*: *conceptual, specification, and implementation.* <br>These distinctions are helpful in understanding the relationship between abstract classes and their derivations.<br> The *abstract class defines how to solve things conceptually*.<br> It also *gives the specification for communicating* with any object derived from it.<br> *Each derivation provides the specific implementation* needed. |
|*Polymorphism* | Being able to *refer to different derivations of a class in the same way*, but *getting the behavior appropriate to the derived class* being referred to. |
|*Functional decomposition*|Structured programmers usually approach program design with functional decomposition.<br> Functional decomposition is the method of *breaking down a problem into smaller and smaller functions*. Each function is *subdivided until it is manageable*.|
|*Changing requirements*|Changing requirements are *inherent to the development process*.<br>Rather than blaming users or ourselves about the seemingly impossible task of getting good and complete requirements, we should *use development methods that deal with changing requirements* more effectively.|
