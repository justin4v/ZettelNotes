# 功能分解
*functional decomposition*：将问题分解成更小的问题。

## 示例
**需求**
访问在数据库中存储的形状描述然后显示出来。
**分析**
按照所需结构化的步骤来思考。按照以下步骤解决这个问题：
1. 在数据库中找到形状列表。 
2. 打开形状列表。 
3. 按某种规则将列表排序。
4. 在显示器上显示各个形状

**继续分解**
还可以选取以上任意一个步骤，进一步分解成实现所必需的若干步。例如 ， 可以将步骤 4 分解，对于列表中所有形状，都可以按照以下步骤进行： 
4a. 识别形状的类型。 
4b. 获取形状的位置。 
4c. 以形状的位置作为参数，调用显示形状的函数 diaplay()。

这种方法称为“**功能分解（functional decomposition）**”，分析人员将问题分解成了多个功能步骤。

## 问题
功能分解方法的问题：
1. 它通常会导致**一个“主”程序负责控制子程序**，这是将功能分解为多个子功能的自然结果。
2. **主程序所承受的责任太多**：确保一切正确工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。
3. 它还**难以适应未来可能出现的变化**，所有处理逻辑都在一个大的主函数中，需求变化必须要修改该模块。

## 解决
如果让一些**子函数负责自己的行为**，而且能够*通知主函数*执行某些任务，这种方式比功能分解的方式要容易得多，在编程中就是所谓**委托（delegation）**。


## 使用功能分解应对变化
使用*功能分解模块化各个步骤，以封装变化*
如上例中几何图形需要在屏幕上显示，*call the appropriate function that will display the shape, giving it the shape’s location*。
```plaintext
function: display shape 
input: type of shape, description of shape 
action: 
	switch (**type of shape**) 
		case square: put display function for square here 
		case circle: put display function for circle here
```

### 问题
1. 函数的输入是形状的一致性描述 type of shape；
2. 不同的存储方式下，对所有形状都适用的*一致描述可能存在，也可能不存在*。

**分析**
- 模块化确实有利于*提高代码的可读性，从而更加可维护*；
- 但是模块化**并不总是有利于应对变化**。

# 功能分解的问题
## 低内聚 Weak Cohesion

**Cohesion**： **how closely the operations in a routine are related.**

## 高耦合 Tight Coupling


# 需求变化
- 需求是不完整的。
- 需求经常是错误的。 
- 需求（和用户）容易让人误解。
- 需求并不会告诉你全部情况



