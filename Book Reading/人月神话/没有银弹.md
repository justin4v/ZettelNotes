1. 软件活动的**根本任务**：**打造由抽象软件实体构成的复杂概念结构**；
2. **次要任务**：**使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言**。


#  本质困难
1. 一个*相互牵制关联的概念结构*，是软件实体必不可少的部分；
2. 包括：*数据集合、数据条目之间的关系、算法、功能调用*等等。
3. 困难是*规格化、设计和测试这些概念上的结构*，而*不是对概念进行表达和对实现逼真程度进行验证*。


## 软件内在的固有特性
### 复杂度
- 随着“软件吞噬世界”不断深入，软件对应的社会活动也越来越复杂。所实现业务的复杂，代表着软件系统的成功，同时意味更容易失败。
- 规模上，软件实体可能比任何由人类创造的其他实体要复杂，没有任何两个软件部分是相同的（至少是在语句的级别）。
- *软件的复杂度是必要属性，不是次要因素*。因此，抽掉复杂度的软件实体描述常常也去掉了一些本质属性。

### 一致性
- 软件开发到一定规模后，协同成本成为新增或修改业务的主要障碍，维持较高生产效率的一个思路是将系统控制在一定规模内
- 软件工程师必须控制的很多复杂度是随心所欲、毫无规则可言的，*来自不同的、必须遵循的人为惯例和系统*。

### 可变性
- 软件实体经常会遭受到持续的变更压力
- 部分原因是软件*包含了很多功能*，而功能是最容易感受变更压力的部分。
- 软件*可以很容易地进行修改*——它是纯粹思维活动的产物，可以无限扩展。

### 不可见性
- 软件是*不可见的和无法可视化的*
- 软件的客观存在不具有空间的形体特征


# 总结
1.  尽管软件开发的根本困难无法解决，软件开发的很多*次要困难*在硬件的发展中不断得到解决：
	1.  *高级语言*的流行；
	2.  *分时思路*的应用
	3.  *统一编程环境*的推广
2.  面向对象，更好的编程语言，人工智能，专家系统，可能成为更接近银弹的事物，这些技术的*目标是让具体应用的复杂度与程序本身相分离*
3. *客户并不知道自己需要什么*，所以快速可用的原型开发和然后与客户讨论并快速迭代才是必要
4. 原型的作用是对重要的界面进行模拟演示，然后增量开发
5. *增量开发*的做法对士气有很大提升，但同时需要更好的概念设计和自上而下的开发


# 再论没有银弹
1.  软件开发的必要部分是概念结构，次要部分是实现过程
4.  *软件的复杂性是最严重的内在困难*，不可避免，最好通过在更高级别开发软件，*使用已有的大构件拼接来简化这个部分*
5.  开发时需要注意做好*层次化方便重用和增量化使系统能持续运行*
6.  当软件销量达到一定程度时，支配性问题就是质量，性能，维护成本
7.  面向对象在整个开发周期中都需要运用，投入很大，但是收益在后续维护中才会体现，所以很多人不喜欢，但是这是非常有用的
8.  重用的模块常常是通用功能，所以很多构件无法重用，这是限制
9.  随着高级语言越来越丰富和复杂，软件重用会面临越来越复杂的选择，越来越大的词汇量
10.  随着时代的发展，越来越可以关注于纯粹的概念设计了，但是银弹仍不存在，仍然应该关注于解决次要问题而非寻找通式