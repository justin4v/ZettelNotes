#Redis #Stream #Message-queue

# 简介
- Redis Stream 是 Redis 5.0 版本*新增加的数据结构*。
- Redis Stream 主要用于*消息队列（MQ，Message Queue）*；
- Redis 本身有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能：
	- 但消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。
	- 发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。
- Redis Stream 提供了消息的*持久化和主备复制* 功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。

## Redis Stream 功能

1.  提供了对于消费者和消费者组的**阻塞、非阻塞的获取消息**的功能。
2.  提供了**消息多播**的功能，同一个消息可被分发给多个单消费者和消费者组；
3.  提供了**消息持久化**的功能，可以让任何消费者访问任何时刻的历史消息；
4.  提供了强大的**消费者组的功能**：
    1.  消费者组实现*同组多个消费者并行但不重复消费消息的能力，提升消费能力*。
    2.  消费者组能够记住最新消费的信息，**保证消息连续消费**；
    3.  消费者组能够记住消息转移次数，实现**消费失败重试以及永久性故障的消息转移**。
    4.  消费者组能够记住消息转移次数，借此*可以实现死信消息的功能（需自己实现）*。
    5.  消费者组提供了*PEL未确认列表和ACK确认机制*，保证消息被成功消费，不丢失；

  
## 对比
**基于Reids的消息队列实现有很多种，比如基于PUB/SUB（订阅/发布）模式、基于List的 PUSH和POP一系列命令的实现、基于Sorted-Set的实现。虽然它们都有各自的特点，比如List支持阻塞式的获取消息，Pub/Sub支持消息多播，Sorted Set支持延时消息，但它们有太多的缺点：**

1.  Redis List：
	1. 没有消息多播功能；
	2. 没有 ACK 机制；
	3. 无法重复消费等等。
2.  Redis Pub/Sub ：
	1. 消息无法持久化，只管发送；
	2. 如果出现网络断开、Redis 宕机等，消息就直接没了；
	3. 没有ACK机制。
3.  Redis Sorted Set：
	1. 不支持阻塞式获取消息；
	2. 不允许重复消费；
	3. 不支持分组。

  

# Stream 结构

![[Redis Stream结构示意.png]]


Redis Stream 的结构如上所示：
- 有一个*消息链表*，将所有加入的消息都串起来；
- 每个消息都有一个唯一的 ID 和对应的内容；
- 每个 *Stream 实例都有唯一的名称，即 Redis 的 key*；

## 相关概念
1.  `消费者组：` Consumer Group，使用 `XGROUP CREATE` 命令创建的，一个消费者组中可以存在多个消费者，这些消费者之间是`竞争`关系。
    1.  同一条消息，只能被这个消费者组中的某个消费者获取。
    2.  多个消费者之间是相互独立的，互不干扰。
2.  `消费者：` Consumer 消费消息。
3.  `last_delivered_id：` 这个id保证了在同一个消费者组中，一个消息只能被一个消费者获取。每当消费者组的某个消费者读取到了这个消息后，这个last_delivered_id的值会往后移动一位，保证消费者不会读取到重复的消息。
4.  `pending_ids`：记录了消费者读取到但还没有处理的消息 id 列表；
	1. 处理完成后，返回 ACK 到服务端确认可以从消费组中 evict 消息。
5.  `消息内容：`是一个`键值对`的格式。
6.  `Stream 中 消息的 ID：` 默认情况下，ID使用 `*` ，redis可以自动生成一个，格式为 `时间戳-序列号`，也可以自己指定，一般使用默认生成的即可，且后生成的id号要比之前生成的大。



# 和专业 MQ 中间件对比
 ## 队列中间件会不会丢消息？

Redis 在以下 2 个场景下，都会导致数据丢失。
1.  AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能；
2.  主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）；
3. **Redis 本身的无法保证严格的数据完整性**。

专业的消息队列中间件是如何解决这个问题的？

- 像 RabbitMQ 或 Kafka 这类专业的队列中间件，一般是部署一个集群；
- 生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。
- 即便其中一个节点挂了，也能保证集群的数据不丢失。
- 因此，消息队列在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。

## 消息积压如何处理？

- Redis 的数据都存储在内存中，所以一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。
- Redis 的 Stream 提供了可以指定队列最大长度的功能，是为了避免这种情况发生。
- 但 Kafka、RabbitMQ 这类消息队列，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多。

## 总结
把 Redis 当作队列来使用时，始终面临的 2 个问题：
1.  Redis 本身可能会丢数据
2.  面对消息积压，Redis 内存资源紧张


- 如果你的业务场景足够简单，对于**数据丢失不敏感，而且消息积压概率比较小**的情况下，把 Redis 当作队列是完全可以的。
- Redis 相比于 Kafka、RabbitMQ，部署和运维**也更加轻量**。

# 参考
1. [Redis入门 - 数据类型：Stream详解 ](https://www.cnblogs.com/pengdai/p/14664214.html)
2. [Redis Stream 流的深度解析与实现高级消息队列](https://juejin.cn/post/7112825943231561741)